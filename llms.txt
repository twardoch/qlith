This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: *.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
gui/
  container_qt5.cpp
  fontcache.cpp
  litehtmlwidget.cpp
  main.cpp
  mainwindow.cpp
qlith/
  affinetransform.h
  bitmapimage.h
  color.h
  common.h
  container_qt5_wrapper.h
  container_qt5.h
  context.h
  contextshadow.h
  floatpoint.h
  floatpoint3d.h
  floatquad.h
  floatrect.h
  floatsize.h
  fontcache.h
  gradient.h
  graphicscontext.h
  image.h
  imagedecoder.h
  imagedecoderqt.h
  imageobserver.h
  imagesource.h
  intpoint.h
  intrect.h
  intsize.h
  litehtml.h
  litehtmlwidget.h
  mainwindow.h
  mimetyperegistry.h
  mimetyperegistryqt.h
  pathqt.h
  pngimagedecoder.h
  purgeablebuffer.h
  rgba32bufferqt.h
  shadowdata.h
  sharedbuffer.h
  stillimageqt.h
  styleimage.h
  transformationmatrix.h
  vectortraits.h
affinetransform.cpp
bitmapimage.cpp
CMakeLists.txt
color_test.cpp
color.cpp
common.cpp
container_qpainter_p.h
container_qpainter.cpp
container_qpainter.h
contextshadow.cpp
floatpoint.cpp
floatpoint3d.cpp
floatquad.cpp
floatrect.cpp
floatsize.cpp
gradient.cpp
graphicscontext.cpp
image.cpp
imagedecoder.cpp
imagedecoderqt.cpp
imageobserver.cpp
imagesource.cpp
intpoint.cpp
intrect.cpp
intsize.cpp
litehtml-qt.js_plugin_import.cpp
main.cpp
mainwindow.cpp
mainwindow.h
mimetyperegistry.cpp
mimetyperegistryqt.cpp
pathqt.cpp
pngimagedecoder.cpp
purgeablebuffer.cpp
qlith_global.h
qlithwidget.cpp
qlithwidget.h
rgba32bufferqt.cpp
shadowdata.cpp
sharedbuffer.cpp
stillimageqt.cpp
styleimage.cpp
transformationmatrix.cpp
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="CMakeLists.txt">
set(QLITH_LIB_SRCS
    qlithwidget.cpp
    container_qpainter.cpp
    qlithwidget.h
    qlith_global.h
    container_qpainter.h
    container_qpainter_p.h
)

# Create qlith library
add_library(qlith SHARED ${QLITH_LIB_SRCS})

target_compile_definitions(qlith PRIVATE QLITH_LIBRARY)

# Include directories
target_include_directories(qlith
    PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>
        $<INSTALL_INTERFACE:include>
    PRIVATE
        ${ZLIB_INCLUDE_DIRS}
)

# Link with Qt, litehtml and zlib
target_link_libraries(qlith
    PUBLIC
        Qt5::Widgets
        Qt5::Network
        litehtml
    PRIVATE
        ${ZLIB_LIBRARIES}
)

# Set output properties
set_target_properties(qlith PROPERTIES
    VERSION ${PROJECT_VERSION}
    SOVERSION ${PROJECT_VERSION_MAJOR}
    EXPORT_NAME "qlith"
)

# Generate export header
include(GenerateExportHeader)
generate_export_header(qlith
    EXPORT_FILE_NAME qlith_export.h
)

# Installation
install(TARGETS qlith
    EXPORT qlithTargets
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
    RUNTIME DESTINATION bin
    INCLUDES DESTINATION include
)

install(FILES
    qlithwidget.h
    qlith_global.h
    container_qpainter.h
    ${CMAKE_CURRENT_BINARY_DIR}/qlith_export.h
    DESTINATION include/qlith
)

# Export targets
install(EXPORT qlithTargets
    FILE qlithTargets.cmake
    NAMESPACE qlith::
    DESTINATION lib/cmake/qlith
)

# Create and install config file
configure_file(
    ${CMAKE_SOURCE_DIR}/cmake/qlithConfig.cmake.in
    ${CMAKE_CURRENT_BINARY_DIR}/qlithConfig.cmake
    @ONLY
)

install(FILES
    ${CMAKE_CURRENT_BINARY_DIR}/qlithConfig.cmake
    ${CMAKE_BINARY_DIR}/qlithConfigVersion.cmake
    DESTINATION lib/cmake/qlith
)
</file>

<file path="CMakeLists.txt">
set(QLITH_LIB_SRCS
    qlithwidget.cpp
    container_qpainter.cpp
    qlithwidget.h
    qlith_global.h
    container_qpainter.h
    container_qpainter_p.h
)

# Create qlith library
add_library(qlith SHARED ${QLITH_LIB_SRCS})

target_compile_definitions(qlith PRIVATE QLITH_LIBRARY)

# Include directories
target_include_directories(qlith
    PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>
        $<INSTALL_INTERFACE:include>
    PRIVATE
        ${ZLIB_INCLUDE_DIRS}
)

# Link with Qt, litehtml and zlib
target_link_libraries(qlith
    PUBLIC
        Qt5::Widgets
        Qt5::Network
        litehtml
    PRIVATE
        ${ZLIB_LIBRARIES}
)

# Set output properties
set_target_properties(qlith PROPERTIES
    VERSION ${PROJECT_VERSION}
    SOVERSION ${PROJECT_VERSION_MAJOR}
    EXPORT_NAME "qlith"
)

# Generate export header
include(GenerateExportHeader)
generate_export_header(qlith
    EXPORT_FILE_NAME qlith_export.h
)

# Installation
install(TARGETS qlith
    EXPORT qlithTargets
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
    RUNTIME DESTINATION bin
    INCLUDES DESTINATION include
)

install(FILES
    qlithwidget.h
    qlith_global.h
    container_qpainter.h
    ${CMAKE_CURRENT_BINARY_DIR}/qlith_export.h
    DESTINATION include/qlith
)

# Export targets
install(EXPORT qlithTargets
    FILE qlithTargets.cmake
    NAMESPACE qlith::
    DESTINATION lib/cmake/qlith
)

# Create and install config file
configure_file(
    ${CMAKE_SOURCE_DIR}/cmake/qlithConfig.cmake.in
    ${CMAKE_CURRENT_BINARY_DIR}/qlithConfig.cmake
    @ONLY
)

install(FILES
    ${CMAKE_CURRENT_BINARY_DIR}/qlithConfig.cmake
    ${CMAKE_BINARY_DIR}/qlithConfigVersion.cmake
    DESTINATION lib/cmake/qlith
)
</file>

<file path="container_qpainter_p.h">
// this_file: qlith/src/container_qpainter_p.h
#ifndef CONTAINER_QPAINTER_P_H
#define CONTAINER_QPAINTER_P_H

#include <QFont>
#include <QFontMetrics>
#include <QMap>
#include <QString>

// Font information cache
struct font_metrics_t
{
    QFont font;
    QFontMetrics metrics;

    font_metrics_t() : metrics(font) {}
    font_metrics_t(const QFont& f) : font(f), metrics(font) {}
};

#endif // CONTAINER_QPAINTER_P_H
</file>

<file path="container_qpainter.cpp">
// this_file: qlith-mini/src/container_qpainter.cpp
#include "container_qpainter.h"
#include "container_qpainter_p.h"

#include <QApplication>
#include <QDebug>
#include <QDir>
#include <QFontDatabase>
#include <QFontMetrics>
#include <QPainter>
#include <QScreen>
#include <QUrl>
#include <QFile>

// Default font settings
static const int DEFAULT_FONT_SIZE = 16;
static const QString DEFAULT_FONT_FAMILY = "Arial";

// Constructor
ContainerQPainter::ContainerQPainter(QObject* parent)
    : QObject(parent)
    , m_painter(nullptr)
    , m_devicePixelRatio(1.0)
    , m_defaultFontName(DEFAULT_FONT_FAMILY)
    , m_defaultFontSize(DEFAULT_FONT_SIZE)
    , m_nextFontId(1)
{
    // Initialize with system fonts
    QFontDatabase fontDb;
    if (fontDb.families().contains("Arial")) {
        m_defaultFontName = "Arial";
    } else if (fontDb.families().contains("Helvetica")) {
        m_defaultFontName = "Helvetica";
    } else if (!fontDb.families().isEmpty()) {
        m_defaultFontName = fontDb.families().first();
    }

    // Get device pixel ratio from primary screen
    if (QApplication::primaryScreen()) {
        m_devicePixelRatio = QApplication::primaryScreen()->devicePixelRatio();
    }
}

// Destructor
ContainerQPainter::~ContainerQPainter()
{
    // Clean up any remaining resources
    m_images.clear();
    m_fonts.clear();
}

// Set the base URL for resolving relative paths
void ContainerQPainter::setBaseUrl(const QString& baseUrl)
{
    m_baseUrl = baseUrl;
}

// Get the current base URL
QString ContainerQPainter::baseUrl() const
{
    return m_baseUrl;
}

// Set the device pixel ratio for high-DPI screens
void ContainerQPainter::setDevicePixelRatio(qreal ratio)
{
    m_devicePixelRatio = ratio;
}

// Get the current device pixel ratio
qreal ContainerQPainter::devicePixelRatio() const
{
    return m_devicePixelRatio;
}

// Set the default font name
void ContainerQPainter::setDefaultFontName(const QString& fontName)
{
    m_defaultFontName = fontName;
}

// Get the default font name
QString ContainerQPainter::defaultFontName() const
{
    return m_defaultFontName;
}

// Set the default font size
void ContainerQPainter::setDefaultFontSize(int size)
{
    m_defaultFontSize = size;
}

// Get the default font size
int ContainerQPainter::defaultFontSize() const
{
    return m_defaultFontSize;
}

// Start painting on the given QPainter
void ContainerQPainter::beginPaint(QPainter* painter, const QRect& rect)
{
    m_painter = painter;
    m_paintRect = rect;

    if (m_painter) {
        m_painter->save();
        m_painter->setClipRect(m_paintRect);
    }
}

// Finish painting
void ContainerQPainter::endPaint()
{
    if (m_painter) {
        m_painter->restore();
        m_painter = nullptr;
    }
}

// Create a font for use with the container
litehtml::uint_ptr ContainerQPainter::create_font(const litehtml::font_description& descr, const litehtml::document* doc, litehtml::font_metrics* fm)
{
    // Create a QFont from the parameters
    QFont font;
    font.setFamily(QString::fromUtf8(descr.family.c_str()));
    font.setPixelSize(descr.size);
    font.setWeight(descr.weight);
    font.setItalic(descr.style == litehtml::font_style_italic);
    font.setUnderline(descr.decoration_line & litehtml::text_decoration_line_underline);
    font.setStrikeOut(descr.decoration_line & litehtml::text_decoration_line_line_through);

    // Store font metrics
    font_metrics_t metrics(font);

    // Fill in the metrics if requested
    if (fm) {
        QFontMetrics qfm(font);
        fm->height = qfm.height();
        fm->ascent = qfm.ascent();
        fm->descent = qfm.descent();
        fm->x_height = qfm.boundingRect('x').height();
    }

    // Store the font and assign an ID
    int fontId = m_nextFontId++;
    m_fonts[fontId] = metrics;

    return static_cast<litehtml::uint_ptr>(fontId);
}

// Delete a font created with create_font
void ContainerQPainter::delete_font(litehtml::uint_ptr hFont)
{
    int fontId = static_cast<int>(hFont);
    m_fonts.remove(fontId);
}

// Get text width for measurement
int ContainerQPainter::text_width(const char* text, litehtml::uint_ptr hFont)
{
    int fontId = static_cast<int>(hFont);
    if (!m_fonts.contains(fontId)) {
        return 0;
    }

    const font_metrics_t& metrics = m_fonts[fontId];
    return metrics.metrics.horizontalAdvance(QString::fromUtf8(text));
}

// Draw text with the given font and color
void ContainerQPainter::draw_text(litehtml::uint_ptr hdc, const char* text, litehtml::uint_ptr hFont, litehtml::web_color color, const litehtml::position& pos)
{
    if (!m_painter) return;

    int fontId = static_cast<int>(hFont);
    if (!m_fonts.contains(fontId)) {
        return;
    }

    // Set up painter
    m_painter->save();
    m_painter->setPen(QColor(color.red, color.green, color.blue, color.alpha));
    m_painter->setFont(m_fonts[fontId].font);

    // Draw the text
    const QFontMetrics& metrics = m_fonts[fontId].metrics;
    m_painter->drawText(pos.x, pos.y + metrics.ascent(), QString::fromUtf8(text));

    m_painter->restore();
}

// Convert points to pixels
int ContainerQPainter::pt_to_px(int pt) const
{
    // Standard conversion: 1 point = 1/72 inch
    // Use device pixel ratio for high DPI screens
    // First convert points to device-independent pixels (DIPs)
    // Then apply device pixel ratio to get device pixels
    double dips = pt * (96.0 / 72.0); // Convert point to DIP (96 DPI standard)
    return qRound(dips * m_devicePixelRatio);
}

// Get the default font size
int ContainerQPainter::get_default_font_size() const
{
    return m_defaultFontSize;
}

// Get the default font name
const char* ContainerQPainter::get_default_font_name() const
{
    static QByteArray fontName;
    fontName = m_defaultFontName.toUtf8();
    return fontName.constData();
}

// Draw list marker (bullet, number, etc.)
void ContainerQPainter::draw_list_marker(litehtml::uint_ptr hdc, const litehtml::list_marker& marker)
{
    if (!m_painter) return;

    m_painter->save();

    // Draw based on marker type
    QColor markerColor(marker.color.red, marker.color.green, marker.color.blue, marker.color.alpha);
    m_painter->setPen(markerColor);
    m_painter->setBrush(markerColor);

    if (marker.image.empty()) {
        // Draw the marker based on type
        QRect rect(marker.pos.x, marker.pos.y, marker.pos.width, marker.pos.height);

        switch (marker.marker_type) {
            case litehtml::list_style_type_circle:
                m_painter->drawEllipse(rect);
                break;

            case litehtml::list_style_type_disc:
                m_painter->setBrush(markerColor);
                m_painter->drawEllipse(rect);
                break;

            case litehtml::list_style_type_square:
                m_painter->drawRect(rect);
                break;

            default:
                // For other types (decimal, alpha, roman, etc.), draw the text
                if (marker.index >= 0) {
                    QString indexStr = QString::number(marker.index);
                    m_painter->drawText(rect, Qt::AlignCenter, indexStr);
                }
                break;
        }
    } else {
        // Draw an image marker if available
        QString imgUrl = QString::fromUtf8(marker.image.c_str());
        if (m_images.contains(imgUrl)) {
            QRect rect(marker.pos.x, marker.pos.y, marker.pos.width, marker.pos.height);
            m_painter->drawImage(rect, m_images[imgUrl]);
        }
    }

    m_painter->restore();
}

// Load image from URL
void ContainerQPainter::load_image(const char* src, const char* baseurl, bool redraw_on_ready)
{
    QString url = QString::fromUtf8(src);
    QString base = QString::fromUtf8(baseurl);

    // Resolve relative URLs
    QUrl resolvedUrl;
    if (QUrl(url).isRelative() && !base.isEmpty()) {
        resolvedUrl = QUrl(base).resolved(QUrl(url));
    } else {
        resolvedUrl = QUrl(url);
    }

    QString urlString = resolvedUrl.toString();

    // Skip if already loaded
    if (m_images.contains(urlString)) {
        return;
    }

    // For local files, load directly
    if (resolvedUrl.isLocalFile()) {
        QImage img(resolvedUrl.toLocalFile());
        if (!img.isNull()) {
            m_images[urlString] = img;
            if (redraw_on_ready) {
                // Emit a signal or update UI if needed
            }
        }
    } else {
        // For remote URLs, we'd need to implement network fetching
        // For now, just log that we need to implement this
        qDebug() << "Remote image loading not implemented for:" << urlString;
    }
}

// Get image size for layout
void ContainerQPainter::get_image_size(const char* src, const char* baseurl, litehtml::size& sz)
{
    QString url = QString::fromUtf8(src);
    QString base = QString::fromUtf8(baseurl);

    // Resolve URL
    QUrl resolvedUrl;
    if (QUrl(url).isRelative() && !base.isEmpty()) {
        resolvedUrl = QUrl(base).resolved(QUrl(url));
    } else {
        resolvedUrl = QUrl(url);
    }

    QString urlString = resolvedUrl.toString();

    // If image is loaded, get its size
    if (m_images.contains(urlString)) {
        const QImage& img = m_images[urlString];
        sz.width = img.width();
        sz.height = img.height();
    } else {
        // Default size if image not loaded yet
        sz.width = 0;
        sz.height = 0;
    }
}

// Draw image background
void ContainerQPainter::draw_image(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const std::string& url, const std::string& base_url)
{
    if (!m_painter) return;

    m_painter->save();

    QString imgUrl = QString::fromStdString(url);
    if (m_images.contains(imgUrl)) {
        const QImage& img = m_images[imgUrl];

        QRect clipRect(layer.clip_box.x, layer.clip_box.y, layer.clip_box.width, layer.clip_box.height);
        m_painter->setClipRect(clipRect);

        // Calculate image position and size based on background-position and background-size
        // In this simplified implementation, we just place it at the origin_box position
        QRect imgRect(layer.origin_box.x, layer.origin_box.y, img.width(), img.height());

        // Handle different background-repeat values
        if (layer.repeat == litehtml::background_repeat_no_repeat) {
            m_painter->drawImage(imgRect, img);
        } else if (layer.repeat == litehtml::background_repeat_repeat_x) {
            for (int x = layer.origin_box.x; x < clipRect.right(); x += img.width()) {
                m_painter->drawImage(QRect(x, layer.origin_box.y, img.width(), img.height()), img);
            }
        } else if (layer.repeat == litehtml::background_repeat_repeat_y) {
            for (int y = layer.origin_box.y; y < clipRect.bottom(); y += img.height()) {
                m_painter->drawImage(QRect(layer.origin_box.x, y, img.width(), img.height()), img);
            }
        } else if (layer.repeat == litehtml::background_repeat_repeat) {
            for (int y = layer.origin_box.y; y < clipRect.bottom(); y += img.height()) {
                for (int x = layer.origin_box.x; x < clipRect.right(); x += img.width()) {
                    m_painter->drawImage(QRect(x, y, img.width(), img.height()), img);
                }
            }
        }
    }

    m_painter->restore();
}

// Draw solid fill background
void ContainerQPainter::draw_solid_fill(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::web_color& color)
{
    if (!m_painter) return;

    m_painter->save();

    QColor bgColor(color.red, color.green, color.blue, color.alpha);
    m_painter->fillRect(layer.clip_box.x, layer.clip_box.y, layer.clip_box.width, layer.clip_box.height, bgColor);

    m_painter->restore();
}

// Draw linear gradient
void ContainerQPainter::draw_linear_gradient(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::background_layer::linear_gradient& gradient)
{
    if (!m_painter) return;

    m_painter->save();

    QRect clipRect(layer.clip_box.x, layer.clip_box.y, layer.clip_box.width, layer.clip_box.height);
    m_painter->setClipRect(clipRect);

    // Create a linear gradient
    QLinearGradient qgradient;
    qgradient.setStart(gradient.start.x, gradient.start.y);
    qgradient.setFinalStop(gradient.end.x, gradient.end.y);

    // Add color stops
    for (const auto& stop : gradient.color_points) {
        QColor stopColor(stop.color.red, stop.color.green, stop.color.blue, stop.color.alpha);
        qgradient.setColorAt(stop.offset, stopColor);
    }

    // Draw the gradient
    m_painter->fillRect(clipRect, qgradient);

    m_painter->restore();
}

// Draw radial gradient
void ContainerQPainter::draw_radial_gradient(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::background_layer::radial_gradient& gradient)
{
    if (!m_painter) return;

    m_painter->save();

    QRect clipRect(layer.clip_box.x, layer.clip_box.y, layer.clip_box.width, layer.clip_box.height);
    m_painter->setClipRect(clipRect);

    // Create a radial gradient
    QRadialGradient qgradient(gradient.position.x, gradient.position.y, gradient.radius.x);

    // Add color stops
    for (const auto& stop : gradient.color_points) {
        QColor stopColor(stop.color.red, stop.color.green, stop.color.blue, stop.color.alpha);
        qgradient.setColorAt(stop.offset, stopColor);
    }

    // Draw the gradient
    m_painter->fillRect(clipRect, qgradient);

    m_painter->restore();
}

// Draw conic gradient (not fully supported in Qt, approximated)
void ContainerQPainter::draw_conic_gradient(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::background_layer::conic_gradient& gradient)
{
    if (!m_painter) return;

    m_painter->save();

    QRect clipRect(layer.clip_box.x, layer.clip_box.y, layer.clip_box.width, layer.clip_box.height);
    m_painter->setClipRect(clipRect);

    // Qt doesn't have direct support for conic gradients. This is a simplified implementation.
    // For a more accurate implementation, we would need to draw a custom shader or image.
    QConicalGradient qgradient(gradient.position.x, gradient.position.y, gradient.angle);

    // Add color stops
    for (const auto& stop : gradient.color_points) {
        QColor stopColor(stop.color.red, stop.color.green, stop.color.blue, stop.color.alpha);
        qgradient.setColorAt(stop.offset, stopColor);
    }

    // Draw the gradient
    m_painter->fillRect(clipRect, qgradient);

    m_painter->restore();
}

// Draw borders
void ContainerQPainter::draw_borders(litehtml::uint_ptr hdc, const litehtml::borders& borders, const litehtml::position& draw_pos, bool root)
{
    if (!m_painter || root) return;

    m_painter->save();

    QRect borderRect(draw_pos.x, draw_pos.y, draw_pos.width, draw_pos.height);

    // Draw top border
    if (borders.top.width > 0 && borders.top.style != litehtml::border_style_none) {
        QPen pen(QColor(borders.top.color.red, borders.top.color.green, borders.top.color.blue, borders.top.color.alpha));
        pen.setWidth(borders.top.width);

        switch (borders.top.style) {
            case litehtml::border_style_dotted:
                pen.setStyle(Qt::DotLine);
                break;
            case litehtml::border_style_dashed:
                pen.setStyle(Qt::DashLine);
                break;
            default:
                pen.setStyle(Qt::SolidLine);
                break;
        }

        m_painter->setPen(pen);
        m_painter->drawLine(borderRect.left(), borderRect.top() + borders.top.width/2,
                            borderRect.right(), borderRect.top() + borders.top.width/2);
    }

    // Draw right border
    if (borders.right.width > 0 && borders.right.style != litehtml::border_style_none) {
        QPen pen(QColor(borders.right.color.red, borders.right.color.green, borders.right.color.blue, borders.right.color.alpha));
        pen.setWidth(borders.right.width);

        switch (borders.right.style) {
            case litehtml::border_style_dotted:
                pen.setStyle(Qt::DotLine);
                break;
            case litehtml::border_style_dashed:
                pen.setStyle(Qt::DashLine);
                break;
            default:
                pen.setStyle(Qt::SolidLine);
                break;
        }

        m_painter->setPen(pen);
        m_painter->drawLine(borderRect.right() - borders.right.width/2, borderRect.top(),
                            borderRect.right() - borders.right.width/2, borderRect.bottom());
    }

    // Draw bottom border
    if (borders.bottom.width > 0 && borders.bottom.style != litehtml::border_style_none) {
        QPen pen(QColor(borders.bottom.color.red, borders.bottom.color.green, borders.bottom.color.blue, borders.bottom.color.alpha));
        pen.setWidth(borders.bottom.width);

        switch (borders.bottom.style) {
            case litehtml::border_style_dotted:
                pen.setStyle(Qt::DotLine);
                break;
            case litehtml::border_style_dashed:
                pen.setStyle(Qt::DashLine);
                break;
            default:
                pen.setStyle(Qt::SolidLine);
                break;
        }

        m_painter->setPen(pen);
        m_painter->drawLine(borderRect.left(), borderRect.bottom() - borders.bottom.width/2,
                            borderRect.right(), borderRect.bottom() - borders.bottom.width/2);
    }

    // Draw left border
    if (borders.left.width > 0 && borders.left.style != litehtml::border_style_none) {
        QPen pen(QColor(borders.left.color.red, borders.left.color.green, borders.left.color.blue, borders.left.color.alpha));
        pen.setWidth(borders.left.width);

        switch (borders.left.style) {
            case litehtml::border_style_dotted:
                pen.setStyle(Qt::DotLine);
                break;
            case litehtml::border_style_dashed:
                pen.setStyle(Qt::DashLine);
                break;
            default:
                pen.setStyle(Qt::SolidLine);
                break;
        }

        m_painter->setPen(pen);
        m_painter->drawLine(borderRect.left() + borders.left.width/2, borderRect.top(),
                            borderRect.left() + borders.left.width/2, borderRect.bottom());
    }

    m_painter->restore();
}

// Get viewport dimensions
void ContainerQPainter::get_viewport(litehtml::position& viewport) const
{
    if (m_painter) {
        QRect viewRect = m_painter->viewport();

        // Use the device pixel ratio to scale the viewport correctly
        qreal dpr = m_devicePixelRatio;

        viewport.x = viewRect.x();
        viewport.y = viewRect.y();
        viewport.width = viewRect.width();

        // Set height to a large value to ensure full content is considered during layout
        // This prevents content from being cut off
        viewport.height = qMax(viewRect.height(), 10000);  // Use large height to ensure full document is rendered

        qDebug() << "Container viewport size:" << viewport.width << "x" << viewport.height
                 << "(device pixel ratio:" << dpr << ")";
    } else {
        viewport.x = 0;
        viewport.y = 0;
        viewport.width = 800;  // Default fallback width
        viewport.height = 10000; // Large fallback height to ensure full content rendering
    }
}

// Get media features for media queries
void ContainerQPainter::get_media_features(litehtml::media_features& media) const
{
    QRect screenRect;

    if (QApplication::primaryScreen()) {
        screenRect = QApplication::primaryScreen()->geometry();
    } else {
        // Fallback if no screen is available
        screenRect = QRect(0, 0, 1024, 768);
    }

    media.type = litehtml::media_type_screen;
    media.width = screenRect.width();
    media.height = screenRect.height();
    media.device_width = screenRect.width();
    media.device_height = screenRect.height();
    media.color = 24; // Assume 24-bit color
    media.monochrome = 0;
    media.color_index = 0;
    media.resolution = 96; // Standard resolution

    // Apply device pixel ratio for high DPI screens
    if (m_devicePixelRatio > 1.0) {
        media.resolution = static_cast<int>(media.resolution * m_devicePixelRatio);
    }
}

// Handle document title
void ContainerQPainter::set_caption(const char* caption)
{
    QString title = QString::fromUtf8(caption);
    emit titleChanged(title);
}

// Set base URL for document
void ContainerQPainter::set_base_url(const char* base_url)
{
    m_baseUrl = QString::fromUtf8(base_url);
}

// Handle document link elements
void ContainerQPainter::link(const std::shared_ptr<litehtml::document>& doc, const litehtml::element::ptr& el)
{
    // Implementation for link processing if needed
}

// Handle anchor clicks
void ContainerQPainter::on_anchor_click(const char* url, const litehtml::element::ptr& el)
{
    QString linkUrl = QString::fromUtf8(url);
    emit anchorClicked(linkUrl);
}

// Handle mouse events
void ContainerQPainter::on_mouse_event(const litehtml::element::ptr& el, litehtml::mouse_event event)
{
    // Implementation for mouse events if needed
}

// Set cursor based on element
void ContainerQPainter::set_cursor(const char* cursor)
{
    QString cursorName = QString::fromUtf8(cursor);
    emit cursorChanged(cursorName);
}

// Transform text based on CSS text-transform
void ContainerQPainter::transform_text(litehtml::string& text, litehtml::text_transform tt)
{
    if (text.empty()) return;

    QString qtext = QString::fromUtf8(text.c_str());

    switch (tt) {
        case litehtml::text_transform_capitalize:
            qtext = qtext.toLower();
            if (!qtext.isEmpty()) {
                qtext[0] = qtext[0].toUpper();
            }
            break;

        case litehtml::text_transform_uppercase:
            qtext = qtext.toUpper();
            break;

        case litehtml::text_transform_lowercase:
            qtext = qtext.toLower();
            break;

        default:
            break;
    }

    QByteArray utf8 = qtext.toUtf8();
    text = std::string(utf8.constData(), utf8.length());
}

// Import CSS from URL
void ContainerQPainter::import_css(litehtml::string& text, const litehtml::string& url, litehtml::string& baseurl)
{
    // Implementation for CSS loading if needed
    // For now, just leave it empty
}

// Set clipping region
void ContainerQPainter::set_clip(const litehtml::position& pos, const litehtml::border_radiuses& bdr_radius)
{
    if (!m_painter) return;

    QRect clipRect(pos.x, pos.y, pos.width, pos.height);
    m_painter->setClipRect(clipRect, Qt::IntersectClip);
}

// Remove clipping
void ContainerQPainter::del_clip()
{
    // QPainter handles clipping stack via save/restore, so we don't need explicit implementation
}

// Get language settings
void ContainerQPainter::get_language(litehtml::string& language, litehtml::string& culture) const
{
    // Use the system locale for language
    QLocale locale = QLocale::system();

    // Convert language code to string
    language = locale.name().left(2).toStdString(); // e.g., "en"
    culture = locale.name().toStdString();          // e.g., "en_US"
}

// Create custom element
litehtml::element::ptr ContainerQPainter::create_element(const char* tag_name,
                                                        const litehtml::string_map& attributes,
                                                        const std::shared_ptr<litehtml::document>& doc)
{
    // We don't need to create custom elements, let litehtml handle it
    return nullptr;
}

// Callback for image loading
void ContainerQPainter::onImageLoaded(const QString& url, const QImage& image)
{
    if (!image.isNull()) {
        m_images[url] = image;
    }
}

// Callback for CSS loading
void ContainerQPainter::onCssLoaded(const QString& url, const QString& css)
{
    // Implementation for CSS loading callback if needed
}
</file>

<file path="container_qpainter.h">
// this_file: qlith/src/container_qpainter.h
#ifndef CONTAINER_QPAINTER_H
#define CONTAINER_QPAINTER_H

#include <QColor>
#include <QFont>
#include <QFontMetrics>
#include <QImage>
#include <QMap>
#include <QObject>
#include <QPainter>
#include <QRect>
#include <QUrl>

#include <litehtml/document.h>
#include <litehtml/document_container.h>

class ContainerQPainter : public QObject, public litehtml::document_container
{
    Q_OBJECT

public:
    /**
     * @brief Constructs a ContainerQPainter object.
     * @param parent The parent QObject.
     */
    explicit ContainerQPainter(QObject* parent = nullptr);

    /**
     * @brief Destroys the ContainerQPainter object.
     */
    ~ContainerQPainter() override;

    /**
     * @brief Set the base URL for resolving relative paths.
     * @param baseUrl The base URL to use.
     */
    void setBaseUrl(const QString& baseUrl);

    /**
     * @brief Get the current base URL.
     * @return The base URL.
     */
    QString baseUrl() const;

    /**
     * @brief Set the device pixel ratio for high-DPI screens.
     * @param ratio The device pixel ratio.
     */
    void setDevicePixelRatio(qreal ratio);

    /**
     * @brief Get the current device pixel ratio.
     * @return The device pixel ratio.
     */
    qreal devicePixelRatio() const;

    /**
     * @brief Set the default font name.
     * @param fontName The default font name.
     */
    void setDefaultFontName(const QString& fontName);

    /**
     * @brief Get the default font name.
     * @return The default font name.
     */
    QString defaultFontName() const;

    /**
     * @brief Set the default font size.
     * @param size The default font size in pixels.
     */
    void setDefaultFontSize(int size);

    /**
     * @brief Get the default font size.
     * @return The default font size in pixels.
     */
    int defaultFontSize() const;

    /**
     * @brief Start painting on the given QPainter.
     * @param painter The QPainter to use for rendering.
     * @param rect The rectangle to paint in.
     */
    void beginPaint(QPainter* painter, const QRect& rect);

    /**
     * @brief Finish painting.
     */
    void endPaint();

    // litehtml::document_container implementation
    litehtml::uint_ptr create_font(const litehtml::font_description& descr, const litehtml::document* doc, litehtml::font_metrics* fm) override;
    void delete_font(litehtml::uint_ptr hFont) override;
    int text_width(const char* text, litehtml::uint_ptr hFont) override;
    void draw_text(litehtml::uint_ptr hdc, const char* text, litehtml::uint_ptr hFont, litehtml::web_color color, const litehtml::position& pos) override;
    int pt_to_px(int pt) const override;
    int get_default_font_size() const override;
    const char* get_default_font_name() const override;
    void draw_list_marker(litehtml::uint_ptr hdc, const litehtml::list_marker& marker) override;
    void load_image(const char* src, const char* baseurl, bool redraw_on_ready) override;
    void get_image_size(const char* src, const char* baseurl, litehtml::size& sz) override;
    void draw_image(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const std::string& url, const std::string& base_url) override;
    void draw_solid_fill(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::web_color& color) override;
    void draw_linear_gradient(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::background_layer::linear_gradient& gradient) override;
    void draw_radial_gradient(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::background_layer::radial_gradient& gradient) override;
    void draw_conic_gradient(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::background_layer::conic_gradient& gradient) override;
    void draw_borders(litehtml::uint_ptr hdc, const litehtml::borders& borders, const litehtml::position& draw_pos, bool root) override;
    void get_viewport(litehtml::position& viewport) const override;
    void get_media_features(litehtml::media_features& media) const override;
    void set_caption(const char* caption) override;
    void set_base_url(const char* base_url) override;
    void link(const std::shared_ptr<litehtml::document>& doc, const litehtml::element::ptr& el) override;
    void on_anchor_click(const char* url, const litehtml::element::ptr& el) override;
    void on_mouse_event(const litehtml::element::ptr& el, litehtml::mouse_event event) override;
    void set_cursor(const char* cursor) override;
    void transform_text(litehtml::string& text, litehtml::text_transform tt) override;
    void import_css(litehtml::string& text, const litehtml::string& url, litehtml::string& baseurl) override;
    void set_clip(const litehtml::position& pos, const litehtml::border_radiuses& bdr_radius) override;
    void del_clip() override;
    void get_language(litehtml::string& language, litehtml::string& culture) const override;
    litehtml::element::ptr create_element(const char* tag_name,
                                          const litehtml::string_map& attributes,
                                          const std::shared_ptr<litehtml::document>& doc) override;

    // URL resolving and resource loading
    void onImageLoaded(const QString& url, const QImage& image);
    void onCssLoaded(const QString& url, const QString& css);

signals:
    void titleChanged(const QString& title);
    void anchorClicked(const QString& url);
    void cursorChanged(const QString& cursor);

private:
    QPainter* m_painter;
    QRect m_paintRect;
    QString m_baseUrl;
    qreal m_devicePixelRatio;
    QString m_defaultFontName;
    int m_defaultFontSize;

    QMap<QString, QImage> m_images;
    QMap<int, struct font_metrics_t> m_fonts;
    int m_nextFontId;
};

#endif // CONTAINER_QPAINTER_H
</file>

<file path="qlith_global.h">
// this_file: qlith/src/qlith_global.h
#ifndef QLITH_GLOBAL_H
#define QLITH_GLOBAL_H

#include <QtCore/qglobal.h>
#include "qlith_export.h"

#endif // QLITH_GLOBAL_H
</file>

<file path="qlithwidget.cpp">
#include "qlithwidget.h"
#include "container_qpainter.h"

#include <QMouseEvent>
#include <QPainter>
#include <QResizeEvent>
#include <QApplication>
#include <QMimeData>
#include <QClipboard>
#include <QDebug>
#include <QNetworkAccessManager>
#include <QNetworkRequest>
#include <QNetworkReply>
#include <QFile>
#include <QDir>
#include <QUrl>
#include <QDesktopServices>
#include <QStandardPaths>
#include <QDateTime>
#include <QBuffer>
#include <QTemporaryFile>
#include <QLocale>
#include <QFileInfo>

// Helper function for debugging
static void saveDebugContent(const QString &content, const QString &identifier, const QString &extension)
{
#ifdef QLITH_DEBUG_DIR
    QDir dir(QLITH_DEBUG_DIR);
    if (!dir.exists()) {
        dir.mkpath(".");
    }

    // Create a filename based on the current timestamp and identifier
    QString timestamp = QDateTime::currentDateTime().toString("yyyyMMdd_hhmmss_zzz");
    QString filename = dir.filePath(QString("%1_%2%3").arg(timestamp).arg(identifier.section('/', -1).section('?', 0, 0)).arg(extension));

    // Save content to file
    QFile file(filename);
    if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        QTextStream stream(&file);
        stream << content;
        file.close();
        qDebug() << "Debug content saved to" << filename;
    } else {
        qWarning() << "Failed to save debug content to" << filename;
    }
#endif
}

// Forward declaration
class QlithWidget;

// Private implementation class
class QlithWidgetPrivate : public QObject {
    Q_OBJECT
public:
    QlithWidgetPrivate(QlithWidget *owner);
    ~QlithWidgetPrivate();

    // Content loading methods
    void loadHtml(const QString &html, const QUrl &url);
    void loadUrl(const QUrl &url);
    void loadLocalFile(const QString &filePath);
    void loadRemoteUrl(const QUrl &url);

    // Layout handling
    void updateWithLayout();

public slots:
    // Handle network reply for assets (images, CSS, etc.)
    void handleNetworkReply(QNetworkReply *reply);

public:
    QlithWidget *q;
    ContainerQPainter *container;
    QNetworkAccessManager *networkManager;
    std::shared_ptr<litehtml::document> document;
    QMap<QUrl, QNetworkReply*> pendingResources;

    QString currentHtml;
    QUrl currentUrl;
    QUrl baseUrl;
    QColor backgroundColor;
    QString defaultCss;

    bool loading;
    bool needsLayout;
};

// Implementation of QlithWidgetPrivate methods
QlithWidgetPrivate::QlithWidgetPrivate(QlithWidget *owner)
    : QObject(owner)
    , q(owner)
    , container(new ContainerQPainter(owner))
    , networkManager(new QNetworkAccessManager(owner))
    , loading(false)
    , needsLayout(true)
    , currentUrl("about:blank")
    , backgroundColor(Qt::white)
    , defaultCss(
        "html { background-color: white; color: black; font-family: Arial, sans-serif; }"
        "body { margin: 8px; }"
        "a { color: blue; text-decoration: underline; }"
        "img { border: none; }"
    )
{
    // Connect container signals
    QObject::connect(container, &ContainerQPainter::titleChanged,
                    owner, &QlithWidget::titleChanged);

    QObject::connect(container, &ContainerQPainter::anchorClicked,
                    [this](const QString &url) {
                        if (url.startsWith("http:") || url.startsWith("https:") || url.startsWith("file:")) {
                            emit q->linkClicked(QUrl(url));
                        } else {
                            QUrl resolved = currentUrl.resolved(QUrl(url));
                            emit q->linkClicked(resolved);
                        }
                    });

    // Connect network manager signals
    QObject::connect(networkManager, &QNetworkAccessManager::finished,
                    this, &QlithWidgetPrivate::handleNetworkReply);
}

QlithWidgetPrivate::~QlithWidgetPrivate() {
    // Clear any pending requests
    for (QNetworkReply* reply : pendingResources.values()) {
        reply->abort();
        reply->deleteLater();
    }
    pendingResources.clear();
}

// Load HTML content
void QlithWidgetPrivate::loadHtml(const QString &html, const QUrl &url) {
    currentHtml = html;
    currentUrl = url;

    // Set base URL for the container
    container->setBaseUrl(url.toString());

    // Create and render document
    if (document) {
        document.reset();
    }

    // Prepare master CSS
    QString masterCss = defaultCss;

    // Create context for litehtml
    // Implementation depends on the litehtml version, here's a simplified approach
    QByteArray htmlData = html.toUtf8();

    try {
        qDebug() << "QlithWidget: Creating litehtml document from string, length:" << htmlData.size();

        // Create litehtml document
        document = litehtml::document::createFromString(
            htmlData.constData(),
            container
        );

        if (document) {
            // Get device pixel ratio for proper scaling
            qreal devicePixelRatio = container->devicePixelRatio();
            int scaledWidth = qRound(q->width() / devicePixelRatio);

            qDebug() << "QlithWidget: Document created successfully, rendering with device pixel ratio:"
                     << devicePixelRatio << ", widget width:" << q->width()
                     << ", scaled width for rendering:" << scaledWidth;

            // Render using scaled width to account for device pixel ratio
            document->render(scaledWidth);
            needsLayout = false;
            q->update();

            qDebug() << "QlithWidget: Document rendered, emitting loadFinished(true)";
            loading = false;
            emit q->loadFinished(true);
        } else {
            qWarning() << "QlithWidget: Failed to create litehtml document";
            loading = false;
            emit q->loadFinished(false);
        }
    } catch (const std::exception &e) {
        qWarning() << "QlithWidget: Exception creating document:" << e.what();
        loading = false;
        emit q->loadFinished(false);
    } catch (...) {
        qWarning() << "QlithWidget: Unknown exception creating document";
        loading = false;
        emit q->loadFinished(false);
    }
}

// Load URL
void QlithWidgetPrivate::loadUrl(const QUrl &url) {
    // Skip if same URL and already loaded
    if (url == currentUrl && !needsLayout) {
        return;
    }

    currentUrl = url;
    loading = true;
    needsLayout = true;

    // Debug output
    qDebug() << "QlithWidget::loadUrl - Loading URL:" << url.toString() << ", scheme:" << url.scheme();

    emit q->loadStarted();

    // Handle different URL schemes
    if (url.scheme() == "file") {
        qDebug() << "QlithWidget::loadUrl - Loading local file:" << url.toLocalFile();
        loadLocalFile(url.toLocalFile());
    } else if (url.scheme() == "http" || url.scheme() == "https") {
        loadRemoteUrl(url);
    } else if (url.scheme() == "about" && url.path() == "blank") {
        loadHtml("<html><body></body></html>", url);
    } else {
        qWarning() << "Unsupported URL scheme:" << url.scheme();
        emit q->loadFinished(false);
    }
}

// Load local file
void QlithWidgetPrivate::loadLocalFile(const QString &filePath) {
    // Debug output
    qDebug() << "QlithWidget::loadLocalFile - Attempting to load file:" << filePath;
    QFileInfo fileInfo(filePath);
    qDebug() << "  - Absolute file path:" << fileInfo.absoluteFilePath();
    qDebug() << "  - File exists:" << fileInfo.exists();

    QFile file(filePath);
    if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        QString html = QString::fromUtf8(file.readAll());
        loadHtml(html, QUrl::fromLocalFile(filePath));
    } else {
        qWarning() << "Failed to open file:" << filePath << " - " << file.errorString();
        emit q->loadFinished(false);
    }
}

// Load remote URL
void QlithWidgetPrivate::loadRemoteUrl(const QUrl &url) {
    QNetworkRequest request(url);
    request.setHeader(QNetworkRequest::UserAgentHeader, "Qlith/1.0");

    QNetworkReply *reply = networkManager->get(request);

    QObject::connect(reply, &QNetworkReply::finished, [this, reply, url]() {
        if (reply->error() == QNetworkReply::NoError) {
            QString contentType = reply->header(QNetworkRequest::ContentTypeHeader).toString();
            QByteArray data = reply->readAll();

            if (contentType.contains("text/html", Qt::CaseInsensitive) ||
                url.path().endsWith(".html", Qt::CaseInsensitive) ||
                url.path().endsWith(".htm", Qt::CaseInsensitive)) {

                QString html = QString::fromUtf8(data);
                loadHtml(html, url);
            } else {
                qWarning() << "URL did not return HTML content:" << url;
                emit q->loadFinished(false);
            }
        } else {
            qWarning() << "Failed to load URL:" << url << " - " << reply->errorString();
            emit q->loadFinished(false);
        }

        reply->deleteLater();
    });
}

// Handle network reply for assets (images, CSS, etc.)
void QlithWidgetPrivate::handleNetworkReply(QNetworkReply *reply) {
    if (!reply) return;

    QUrl url = reply->url();
    QString urlStr = url.toString();

    if (reply->error() == QNetworkReply::NoError) {
        QByteArray data = reply->readAll();

        // Handle based on content type
        QString contentType = reply->header(QNetworkRequest::ContentTypeHeader).toString();

        if (contentType.startsWith("image/", Qt::CaseInsensitive) ||
            url.path().endsWith(".png", Qt::CaseInsensitive) ||
            url.path().endsWith(".jpg", Qt::CaseInsensitive) ||
            url.path().endsWith(".jpeg", Qt::CaseInsensitive) ||
            url.path().endsWith(".gif", Qt::CaseInsensitive)) {

            // Handle image
            QImage image;
            if (image.loadFromData(data)) {
                container->onImageLoaded(urlStr, image);
                q->update();
            }
        } else if (contentType.contains("text/css", Qt::CaseInsensitive) ||
                  url.path().endsWith(".css", Qt::CaseInsensitive)) {

            // Handle CSS
            QString css = QString::fromUtf8(data);
            container->onCssLoaded(urlStr, css);
            q->update();
        }
    }

    // Remove reply from pending list
    pendingResources.remove(url);
    reply->deleteLater();
}

// Redraw with layout if needed
void QlithWidgetPrivate::updateWithLayout() {
    if (needsLayout && document) {
        // Get device pixel ratio for proper scaling
        qreal devicePixelRatio = container->devicePixelRatio();
        int scaledWidth = qRound(q->width() / devicePixelRatio);

        qDebug() << "QlithWidget::updateWithLayout - Rendering with device pixel ratio:"
                 << devicePixelRatio << ", widget width:" << q->width()
                 << ", scaled width for rendering:" << scaledWidth;

        // Render using scaled width to account for device pixel ratio
        document->render(scaledWidth);
        needsLayout = false;
    }
    q->update();
}

//
// QlithWidget implementation
//

QlithWidget::QlithWidget(QWidget* parent)
    : QWidget(parent)
    , d_ptr(new QlithWidgetPrivate(this))
{
    // Set widget attributes
    setAttribute(Qt::WA_OpaquePaintEvent);
    setMouseTracking(true);
    setFocusPolicy(Qt::StrongFocus);
}

QlithWidget::~QlithWidget()
{
}

void QlithWidget::setHtml(const QString& html)
{
    Q_D(QlithWidget);
    emit loadStarted();
    d->loadHtml(html, d->baseUrl.isEmpty() ? QUrl("about:blank") : d->baseUrl);
}

void QlithWidget::load(const QUrl& url)
{
    Q_D(QlithWidget);
    d->loadUrl(url);
}

void QlithWidget::setBaseUrl(const QUrl& url)
{
    Q_D(QlithWidget);
    if (d->baseUrl != url) {
        d->baseUrl = url;
        d->container->setBaseUrl(url.toString());
        emit baseUrlChanged(url);
    }
}

QUrl QlithWidget::baseUrl() const
{
    Q_D(const QlithWidget);
    return d->baseUrl;
}

void QlithWidget::setBackgroundColor(const QColor& color)
{
    Q_D(QlithWidget);
    if (d->backgroundColor != color) {
        d->backgroundColor = color;
        update();
        emit backgroundColorChanged(color);
    }
}

QColor QlithWidget::backgroundColor() const
{
    Q_D(const QlithWidget);
    return d->backgroundColor;
}

void QlithWidget::setDefaultStyleSheet(const QString& css)
{
    Q_D(QlithWidget);
    d->defaultCss = css;
    // Reload if we have a document
    if (d->document) {
        setHtml(d->currentHtml);
    }
}

QString QlithWidget::documentTitle() const
{
    Q_D(const QlithWidget);
    // This would require accessing the document title
    // We would need to implement this with litehtml
    return QString();
}

std::shared_ptr<litehtml::document> QlithWidget::document() const
{
    Q_D(const QlithWidget);
    return d->document;
}

QSize QlithWidget::documentSize() const
{
    Q_D(const QlithWidget);
    if (d->document) {
        return QSize(d->document->width(), d->document->height());
    }
    return QSize();
}

bool QlithWidget::needsVerticalScrolling() const
{
    Q_D(const QlithWidget);
    if (d->document) {
        return d->document->height() > height();
    }
    return false;
}

void QlithWidget::reload()
{
    Q_D(QlithWidget);
    if (d->currentUrl.isValid()) {
        load(d->currentUrl);
    } else if (!d->currentHtml.isEmpty()) {
        setHtml(d->currentHtml);
    }
}

void QlithWidget::stop()
{
    Q_D(QlithWidget);
    // Abort any ongoing network requests
    for (QNetworkReply* reply : d->pendingResources.values()) {
        reply->abort();
        reply->deleteLater();
    }
    d->pendingResources.clear();
    d->loading = false;
}

// Widget events

void QlithWidget::paintEvent(QPaintEvent* event)
{
    Q_D(QlithWidget);
    QPainter painter(this);

    // Fill background
    painter.fillRect(rect(), d->backgroundColor);

    // Render document if available
    if (d->document) {
        d->container->beginPaint(&painter, rect());

        // Create clip position that accommodates the full document height
        int docWidth = d->document->width();
        int docHeight = d->document->height();

        // Use the maximum of widget height and document height to ensure all content is rendered
        litehtml::position clip(0, 0, width(), qMax(height(), docHeight));

        qDebug() << "QlithWidget::paintEvent - Document size:" << docWidth << "x" << docHeight
                 << ", Widget size:" << width() << "x" << height()
                 << ", Using clip size:" << clip.width << "x" << clip.height;

        d->document->draw((litehtml::uint_ptr)&painter, 0, 0, &clip);

        d->container->endPaint();
    }
}

void QlithWidget::resizeEvent(QResizeEvent* event)
{
    Q_D(QlithWidget);
    if (d->document) {
        // Mark for relayout
        d->needsLayout = true;
        // Layout immediately
        d->updateWithLayout();
    }
    QWidget::resizeEvent(event);
}

void QlithWidget::mousePressEvent(QMouseEvent* event)
{
    Q_D(QlithWidget);
    if (d->document) {
        litehtml::position::vector redraw_boxes;
        int x = event->pos().x();
        int y = event->pos().y();

        if (event->button() == Qt::LeftButton) {
            d->document->on_lbutton_down(x, y, x, y, redraw_boxes);
            if (!redraw_boxes.empty()) {
                update();
            }
        }
    }
    QWidget::mousePressEvent(event);
}

void QlithWidget::mouseReleaseEvent(QMouseEvent* event)
{
    Q_D(QlithWidget);
    if (d->document) {
        litehtml::position::vector redraw_boxes;
        int x = event->pos().x();
        int y = event->pos().y();

        if (event->button() == Qt::LeftButton) {
            d->document->on_lbutton_up(x, y, x, y, redraw_boxes);
            if (!redraw_boxes.empty()) {
                update();
            }
        }
    }
    QWidget::mouseReleaseEvent(event);
}

void QlithWidget::mouseMoveEvent(QMouseEvent* event)
{
    Q_D(QlithWidget);
    if (d->document) {
        litehtml::position::vector redraw_boxes;
        int x = event->pos().x();
        int y = event->pos().y();

        d->document->on_mouse_over(x, y, x, y, redraw_boxes);
        if (!redraw_boxes.empty()) {
            update();
        }
    }
    QWidget::mouseMoveEvent(event);
}

void QlithWidget::wheelEvent(QWheelEvent* event)
{
    // We're not implementing scrolling in this basic widget
    // A scrollable version would handle this
    QWidget::wheelEvent(event);
}

void QlithWidget::keyPressEvent(QKeyEvent* event)
{
    // Handle key events if needed
    QWidget::keyPressEvent(event);
}

#include "qlithwidget.moc"
</file>

<file path="qlithwidget.h">
// this_file: qlith/src/qlithwidget.h
#ifndef QLITHWIDGET_H
#define QLITHWIDGET_H

#include <QWidget>
#include <QUrl>
#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QTimer>
#include <QColor>
#include <QScopedPointer>
#include <memory>

#include <litehtml/document.h>
#include "qlith_global.h"

class ContainerQPainter;
class QlithWidgetPrivate;

/**
 * @brief The QlithWidget class provides a Qt widget for displaying HTML content using litehtml.
 *
 * QlithWidget renders HTML and CSS using the litehtml library, providing a lightweight HTML
 * rendering capability within Qt applications.
 */
class QLITH_EXPORT QlithWidget : public QWidget
{
    Q_OBJECT
    Q_PROPERTY(QUrl baseUrl READ baseUrl WRITE setBaseUrl NOTIFY baseUrlChanged)
    Q_PROPERTY(QColor backgroundColor READ backgroundColor WRITE setBackgroundColor NOTIFY backgroundColorChanged)

public:
    /**
     * @brief Constructs a QlithWidget.
     * @param parent The parent widget.
     */
    explicit QlithWidget(QWidget* parent = nullptr);

    /**
     * @brief Destroys the QlithWidget.
     */
    ~QlithWidget() override;

    /**
     * @brief Load HTML content from a string.
     * @param html The HTML content to load.
     */
    void setHtml(const QString& html);

    /**
     * @brief Load HTML content from a URL.
     * @param url The URL to load.
     */
    void load(const QUrl& url);

    /**
     * @brief Set the base URL for resolving relative URLs.
     * @param url The base URL.
     */
    void setBaseUrl(const QUrl& url);

    /**
     * @brief Get the current base URL.
     * @return The base URL.
     */
    QUrl baseUrl() const;

    /**
     * @brief Set the background color of the widget.
     * @param color The background color.
     */
    void setBackgroundColor(const QColor& color);

    /**
     * @brief Get the current background color.
     * @return The background color.
     */
    QColor backgroundColor() const;

    /**
     * @brief Set the default CSS stylesheet to use.
     * @param css The CSS stylesheet.
     */
    void setDefaultStyleSheet(const QString& css);

    /**
     * @brief Get the document title.
     * @return The title of the HTML document.
     */
    QString documentTitle() const;

    /**
     * @brief Get the litehtml document object.
     * @return A shared pointer to the litehtml document.
     */
    std::shared_ptr<litehtml::document> document() const;

    /**
     * @brief Get the size of the document (width and height).
     * @return The size of the document.
     */
    QSize documentSize() const;

    /**
     * @brief Check if the document needs vertical scrolling.
     * @return True if the document needs vertical scrolling, false otherwise.
     */
    bool needsVerticalScrolling() const;

public slots:
    /**
     * @brief Reload the current content.
     */
    void reload();

    /**
     * @brief Stop loading the current content.
     */
    void stop();

signals:
    /**
     * @brief Signal emitted when the base URL changes.
     * @param url The new base URL.
     */
    void baseUrlChanged(const QUrl& url);

    /**
     * @brief Signal emitted when the background color changes.
     * @param color The new background color.
     */
    void backgroundColorChanged(const QColor& color);

    /**
     * @brief Signal emitted when loading of content starts.
     */
    void loadStarted();

    /**
     * @brief Signal emitted when loading of content finishes.
     */
    void loadFinished(bool ok);

    /**
     * @brief Signal emitted when the document title changes.
     * @param title The new document title.
     */
    void titleChanged(const QString& title);

    /**
     * @brief Signal emitted when a link is clicked.
     * @param url The URL of the clicked link.
     */
    void linkClicked(const QUrl& url);

protected:
    // Reimplemented widget events
    void paintEvent(QPaintEvent* event) override;
    void resizeEvent(QResizeEvent* event) override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void wheelEvent(QWheelEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;

private:
    QScopedPointer<QlithWidgetPrivate> d_ptr;
    Q_DECLARE_PRIVATE(QlithWidget)
};

#endif // QLITHWIDGET_H
</file>

<file path="CMakeLists.txt">
set(BROWSER_SRCS
    main.cpp
    mainwindow.cpp
    mainwindow.h
)

# Define browser executable
add_executable(qlith_browser
    MACOSX_BUNDLE
    ${BROWSER_SRCS}
)

# Include directories
target_include_directories(qlith_browser PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}
    ${CMAKE_SOURCE_DIR}/src
)

# Link with required libraries
target_link_libraries(qlith_browser
    PRIVATE
    Qt5::Widgets
    Qt5::Network
    Qt5::Svg
    qlith
)

# Set application properties
set_target_properties(qlith_browser PROPERTIES
    OUTPUT_NAME "qlith"
    MACOSX_BUNDLE_INFO_PLIST "${CMAKE_SOURCE_DIR}/cmake/MacOSXBundleInfo.plist.in"
)

# Installation
install(TARGETS qlith_browser
    BUNDLE DESTINATION .
    RUNTIME DESTINATION bin
)
</file>

<file path="CMakeLists.txt">
set(BROWSER_SRCS
    main.cpp
    mainwindow.cpp
    mainwindow.h
)

# Define browser executable
add_executable(qlith_browser
    MACOSX_BUNDLE
    ${BROWSER_SRCS}
)

# Include directories
target_include_directories(qlith_browser PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}
    ${CMAKE_SOURCE_DIR}/src
)

# Link with required libraries
target_link_libraries(qlith_browser
    PRIVATE
    Qt5::Widgets
    Qt5::Network
    Qt5::Svg
    qlith
)

# Set application properties
set_target_properties(qlith_browser PROPERTIES
    OUTPUT_NAME "qlith"
    MACOSX_BUNDLE_INFO_PLIST "${CMAKE_SOURCE_DIR}/cmake/MacOSXBundleInfo.plist.in"
)

# Installation
install(TARGETS qlith_browser
    BUNDLE DESTINATION .
    RUNTIME DESTINATION bin
)
</file>

<file path="main.cpp">
// this_file: qlith/browser/main.cpp
#include <QApplication>
#include <QCommandLineParser>
#include <QUrl>
#include <QSurfaceFormat>
#include <QDir>
#include <QStandardPaths>
#include <QFileInfo>
#include <QFile>
#include <QTimer>
#include <QDebug>

#include "mainwindow.h"

int main(int argc, char *argv[])
{
    // Set application information
    QCoreApplication::setApplicationName("Qlith Browser");
    QCoreApplication::setApplicationVersion("1.0");
    QCoreApplication::setOrganizationName("Qlith");
    QCoreApplication::setOrganizationDomain("qlith.org");

    // Create application
    QApplication app(argc, argv);

    // Set up high DPI scaling
    QCoreApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);
    QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);

    // Set up OpenGL settings for better rendering performance
    QSurfaceFormat format;
    format.setDepthBufferSize(24);
    format.setStencilBufferSize(8);
    format.setSamples(4);
    QSurfaceFormat::setDefaultFormat(format);

    // Parse command line arguments
    QCommandLineParser parser;
    parser.setApplicationDescription("Qlith - A lightweight HTML browser");
    parser.addHelpOption();
    parser.addVersionOption();
    parser.addPositionalArgument("url", "The URL to open, optional.", "[url]");

    // Add export options
    QCommandLineOption svgOption(QStringList() << "svg", "Render to SVG file and quit.", "path");
    parser.addOption(svgOption);

    QCommandLineOption pngOption(QStringList() << "png", "Render to PNG file and quit.", "path");
    parser.addOption(pngOption);

    // Add width and height options
    QCommandLineOption widthOption(QStringList() << "width", "Set rendering width in pixels.", "pixels", "2048");
    parser.addOption(widthOption);

    QCommandLineOption heightOption(QStringList() << "height", "Set rendering height in pixels.", "pixels", "2048");
    parser.addOption(heightOption);

    parser.process(app);

    // Get export paths
    QString svgPath = parser.value(svgOption);
    QString pngPath = parser.value(pngOption);

    // Get width and height
    int renderWidth = parser.value(widthOption).toInt();
    int renderHeight = parser.value(heightOption).toInt();

    qDebug() << "Render size:" << renderWidth << "x" << renderHeight;

    // Create debug directory if in debug mode
#ifdef QLITH_DEBUG_DIR
    QDir dir(QLITH_DEBUG_DIR);
    if (!dir.exists()) {
        dir.mkpath(".");
    }
#endif

    // Create main window
    MainWindow mainWindow;

    // Set the render size for export
    mainWindow.setRenderSize(QSize(renderWidth, renderHeight));

    // Handle export mode
    bool exportMode = !svgPath.isEmpty() || !pngPath.isEmpty();

    qDebug() << "Export mode:" << (exportMode ? "true" : "false");
    if (exportMode) {
        qDebug() << "PNG export path:" << pngPath;
        qDebug() << "SVG export path:" << svgPath;
    }

    // Always show the window, even in export mode for proper rendering
    mainWindow.show();

    // Load URL if specified
    const QStringList args = parser.positionalArguments();
    if (!args.isEmpty()) {
        QString userInput = args.first();
        QUrl url;

        // Check if the user input is a relative path to an existing file
        QFileInfo fileInfo(userInput);
        if (fileInfo.exists() && fileInfo.isRelative())
        {
            // If it's a relative path and the file exists, convert to absolute path
            url = QUrl::fromLocalFile(fileInfo.absoluteFilePath());
        }
        else
        {
            // Otherwise, let QUrl try to figure it out (handles absolute paths, URLs)
            // Or if it's a relative path but the file *doesn't* exist,
            // fromUserInput might interpret it as a search term or a non-file URL, which is fine.
            url = QUrl::fromUserInput(userInput);
        }

        qDebug() << "Loading URL:" << url.toString();
        mainWindow.load(url);

        // If in export mode, perform export after page load
        if (exportMode) {
            // Explicitly capture needed variables to avoid dangling references
            QObject::connect(&mainWindow, &MainWindow::loadFinished,
                [&app, &mainWindow, svgPath, pngPath]() {
                    qDebug() << "Load finished, exporting...";
                    if (!svgPath.isEmpty()) {
                        mainWindow.exportToSvg(svgPath);
                    }
                    if (!pngPath.isEmpty()) {
                        qDebug() << "Exporting to PNG:" << pngPath;
                        bool success = mainWindow.exportToPng(pngPath);
                        qDebug() << "PNG export result:" << (success ? "Success" : "Failed");
                    }
                    // Quit after export with a short delay to ensure proper cleanup
                    QTimer::singleShot(100, &app, &QApplication::quit);
                });

            // Set a backup timer in case loadFinished signal is never emitted
            QTimer::singleShot(5000, [&app, &mainWindow, svgPath, pngPath]() {
                qDebug() << "Backup timer triggered - forcing export";
                if (!svgPath.isEmpty()) {
                    mainWindow.exportToSvg(svgPath);
                }
                if (!pngPath.isEmpty()) {
                    qDebug() << "Exporting to PNG (backup):" << pngPath;
                    bool success = mainWindow.exportToPng(pngPath);
                    qDebug() << "Backup PNG export result:" << (success ? "Success" : "Failed");
                }
                // Quit after export
                QTimer::singleShot(100, &app, &QApplication::quit);
            });
        }
    } else {
        // Load default homepage
        QString homePage = "about:blank"; // Use a simpler default for faster load
        qDebug() << "Loading default URL:" << homePage;
        mainWindow.load(QUrl(homePage));

        // If in export mode, perform export after page load
        if (exportMode) {
            // Explicitly capture needed variables to avoid dangling references
            QObject::connect(&mainWindow, &MainWindow::loadFinished,
                [&app, &mainWindow, svgPath, pngPath]() {
                    qDebug() << "Load finished, exporting...";
                    if (!svgPath.isEmpty()) {
                        mainWindow.exportToSvg(svgPath);
                    }
                    if (!pngPath.isEmpty()) {
                        qDebug() << "Exporting to PNG:" << pngPath;
                        bool success = mainWindow.exportToPng(pngPath);
                        qDebug() << "PNG export result:" << (success ? "Success" : "Failed");
                    }
                    // Quit after export with a short delay to ensure proper cleanup
                    QTimer::singleShot(100, &app, &QApplication::quit);
                });

            // Set a backup timer in case loadFinished signal is never emitted
            QTimer::singleShot(5000, [&app, &mainWindow, svgPath, pngPath]() {
                qDebug() << "Backup timer triggered - forcing export";
                if (!svgPath.isEmpty()) {
                    mainWindow.exportToSvg(svgPath);
                }
                if (!pngPath.isEmpty()) {
                    qDebug() << "Exporting to PNG (backup):" << pngPath;
                    bool success = mainWindow.exportToPng(pngPath);
                    qDebug() << "Backup PNG export result:" << (success ? "Success" : "Failed");
                }
                // Quit after export
                QTimer::singleShot(100, &app, &QApplication::quit);
            });
        }
    }

    return app.exec();
}
</file>

<file path="main.cpp">
// this_file: qlith/browser/main.cpp
#include <QApplication>
#include <QCommandLineParser>
#include <QUrl>
#include <QSurfaceFormat>
#include <QDir>
#include <QStandardPaths>
#include <QFileInfo>
#include <QFile>
#include <QTimer>
#include <QDebug>

#include "mainwindow.h"

int main(int argc, char *argv[])
{
    // Set application information
    QCoreApplication::setApplicationName("Qlith Browser");
    QCoreApplication::setApplicationVersion("1.0");
    QCoreApplication::setOrganizationName("Qlith");
    QCoreApplication::setOrganizationDomain("qlith.org");

    // Create application
    QApplication app(argc, argv);

    // Set up high DPI scaling
    QCoreApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);
    QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);

    // Set up OpenGL settings for better rendering performance
    QSurfaceFormat format;
    format.setDepthBufferSize(24);
    format.setStencilBufferSize(8);
    format.setSamples(4);
    QSurfaceFormat::setDefaultFormat(format);

    // Parse command line arguments
    QCommandLineParser parser;
    parser.setApplicationDescription("Qlith - A lightweight HTML browser");
    parser.addHelpOption();
    parser.addVersionOption();
    parser.addPositionalArgument("url", "The URL to open, optional.", "[url]");

    // Add export options
    QCommandLineOption svgOption(QStringList() << "svg", "Render to SVG file and quit.", "path");
    parser.addOption(svgOption);

    QCommandLineOption pngOption(QStringList() << "png", "Render to PNG file and quit.", "path");
    parser.addOption(pngOption);

    // Add width and height options
    QCommandLineOption widthOption(QStringList() << "width", "Set rendering width in pixels.", "pixels", "2048");
    parser.addOption(widthOption);

    QCommandLineOption heightOption(QStringList() << "height", "Set rendering height in pixels.", "pixels", "2048");
    parser.addOption(heightOption);

    parser.process(app);

    // Get export paths
    QString svgPath = parser.value(svgOption);
    QString pngPath = parser.value(pngOption);

    // Get width and height
    int renderWidth = parser.value(widthOption).toInt();
    int renderHeight = parser.value(heightOption).toInt();

    qDebug() << "Render size:" << renderWidth << "x" << renderHeight;

    // Create debug directory if in debug mode
#ifdef QLITH_DEBUG_DIR
    QDir dir(QLITH_DEBUG_DIR);
    if (!dir.exists()) {
        dir.mkpath(".");
    }
#endif

    // Create main window
    MainWindow mainWindow;

    // Set the render size for export
    mainWindow.setRenderSize(QSize(renderWidth, renderHeight));

    // Handle export mode
    bool exportMode = !svgPath.isEmpty() || !pngPath.isEmpty();

    qDebug() << "Export mode:" << (exportMode ? "true" : "false");
    if (exportMode) {
        qDebug() << "PNG export path:" << pngPath;
        qDebug() << "SVG export path:" << svgPath;
    }

    // Always show the window, even in export mode for proper rendering
    mainWindow.show();

    // Load URL if specified
    const QStringList args = parser.positionalArguments();
    if (!args.isEmpty()) {
        QString userInput = args.first();
        QUrl url;

        // Check if the user input is a relative path to an existing file
        QFileInfo fileInfo(userInput);
        if (fileInfo.exists() && fileInfo.isRelative())
        {
            // If it's a relative path and the file exists, convert to absolute path
            url = QUrl::fromLocalFile(fileInfo.absoluteFilePath());
        }
        else
        {
            // Otherwise, let QUrl try to figure it out (handles absolute paths, URLs)
            // Or if it's a relative path but the file *doesn't* exist,
            // fromUserInput might interpret it as a search term or a non-file URL, which is fine.
            url = QUrl::fromUserInput(userInput);
        }

        qDebug() << "Loading URL:" << url.toString();
        mainWindow.load(url);

        // If in export mode, perform export after page load
        if (exportMode) {
            // Explicitly capture needed variables to avoid dangling references
            QObject::connect(&mainWindow, &MainWindow::loadFinished,
                [&app, &mainWindow, svgPath, pngPath]() {
                    qDebug() << "Load finished, exporting...";
                    if (!svgPath.isEmpty()) {
                        mainWindow.exportToSvg(svgPath);
                    }
                    if (!pngPath.isEmpty()) {
                        qDebug() << "Exporting to PNG:" << pngPath;
                        bool success = mainWindow.exportToPng(pngPath);
                        qDebug() << "PNG export result:" << (success ? "Success" : "Failed");
                    }
                    // Quit after export with a short delay to ensure proper cleanup
                    QTimer::singleShot(100, &app, &QApplication::quit);
                });

            // Set a backup timer in case loadFinished signal is never emitted
            QTimer::singleShot(5000, [&app, &mainWindow, svgPath, pngPath]() {
                qDebug() << "Backup timer triggered - forcing export";
                if (!svgPath.isEmpty()) {
                    mainWindow.exportToSvg(svgPath);
                }
                if (!pngPath.isEmpty()) {
                    qDebug() << "Exporting to PNG (backup):" << pngPath;
                    bool success = mainWindow.exportToPng(pngPath);
                    qDebug() << "Backup PNG export result:" << (success ? "Success" : "Failed");
                }
                // Quit after export
                QTimer::singleShot(100, &app, &QApplication::quit);
            });
        }
    } else {
        // Load default homepage
        QString homePage = "about:blank"; // Use a simpler default for faster load
        qDebug() << "Loading default URL:" << homePage;
        mainWindow.load(QUrl(homePage));

        // If in export mode, perform export after page load
        if (exportMode) {
            // Explicitly capture needed variables to avoid dangling references
            QObject::connect(&mainWindow, &MainWindow::loadFinished,
                [&app, &mainWindow, svgPath, pngPath]() {
                    qDebug() << "Load finished, exporting...";
                    if (!svgPath.isEmpty()) {
                        mainWindow.exportToSvg(svgPath);
                    }
                    if (!pngPath.isEmpty()) {
                        qDebug() << "Exporting to PNG:" << pngPath;
                        bool success = mainWindow.exportToPng(pngPath);
                        qDebug() << "PNG export result:" << (success ? "Success" : "Failed");
                    }
                    // Quit after export with a short delay to ensure proper cleanup
                    QTimer::singleShot(100, &app, &QApplication::quit);
                });

            // Set a backup timer in case loadFinished signal is never emitted
            QTimer::singleShot(5000, [&app, &mainWindow, svgPath, pngPath]() {
                qDebug() << "Backup timer triggered - forcing export";
                if (!svgPath.isEmpty()) {
                    mainWindow.exportToSvg(svgPath);
                }
                if (!pngPath.isEmpty()) {
                    qDebug() << "Exporting to PNG (backup):" << pngPath;
                    bool success = mainWindow.exportToPng(pngPath);
                    qDebug() << "Backup PNG export result:" << (success ? "Success" : "Failed");
                }
                // Quit after export
                QTimer::singleShot(100, &app, &QApplication::quit);
            });
        }
    }

    return app.exec();
}
</file>

<file path="mainwindow.cpp">
#include "mainwindow.h"
#include "../src/qlithwidget.h"

#include <QApplication>
#include <QToolBar>
#include <QStatusBar>
#include <QLineEdit>
#include <QLabel>
#include <QComboBox>
#include <QFileDialog>
#include <QMessageBox>
#include <QSettings>
#include <QCloseEvent>
#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QMenuBar>
#include <QMenu>
#include <QPalette>
#include <QPainter>
#include <QSvgGenerator>
#include <QDebug>
#include <QStandardPaths>
#include <QDir>
#include <QDateTime>
#include <QTextStream>
#include <QFile>
#include <QProgressBar>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , m_htmlWidget(new QlithWidget(this))
    , m_urlEdit(nullptr)
    , m_progressBar(nullptr)
    , m_navigationToolBar(nullptr)
    , m_statusBar(nullptr)
    , m_historyIndex(-1)
    , m_zoomFactor(1.0f)
    , m_renderSize(800, 600) // Default render size
{
    setCentralWidget(m_htmlWidget);
    setMinimumSize(800, 600);
    showMaximized(); // Start with a maximized window

    setupUi();
    setupActions();
    setupMenus();
    setupToolbar();
    setupStatusBar();
    setupConnections();

    loadSettings();

    // Load default page
    load(QUrl("about:blank"));
}

void MainWindow::onLoadFinished(bool ok)
{
    // Update status bar
    if (m_statusBar) {
        m_statusBar->showMessage(tr("Ready"));
    }

    // Update window title
    updateTitle(QString());

    qDebug() << "MainWindow::onLoadFinished called with status:" << (ok ? "success" : "failure");

    // Additional debug functionality can be re-implemented if needed

    // Emit loadFinished signal
    emit loadFinished(ok);
}

MainWindow::~MainWindow()
{
}

void MainWindow::loadUrl()
{
    if (!m_urlEdit)
        return;

    QString text = m_urlEdit->text().trimmed();
    if (text.isEmpty())
        return;

    QUrl url = QUrl::fromUserInput(text);
    load(url);
}

void MainWindow::closeEvent(QCloseEvent *event)
{
    saveSettings();
    event->accept();
}

void MainWindow::updateUrlBar(const QUrl& url)
{
    if (m_urlEdit) {
        m_urlEdit->setText(url.toString());
    }
}

void MainWindow::reload()
{
    if (m_historyIndex >= 0 && m_historyIndex < m_history.size()) {
        QUrl currentUrl = m_history.at(m_historyIndex);
        m_htmlWidget->load(currentUrl);
    }
}

void MainWindow::goBack()
{
    if (m_historyIndex > 0) {
        m_historyIndex--;
        QUrl url = m_history.at(m_historyIndex);

        if (m_urlEdit) {
            m_urlEdit->setText(url.toString());
        }

        m_htmlWidget->load(url);

        // Update UI
        if (m_backAction && m_forwardAction) {
            m_backAction->setEnabled(m_historyIndex > 0);
            m_forwardAction->setEnabled(m_historyIndex < m_history.size() - 1);
        }

        updateTitle(QString());
    }
}

void MainWindow::goForward()
{
    if (m_historyIndex < m_history.size() - 1) {
        m_historyIndex++;
        QUrl url = m_history.at(m_historyIndex);

        if (m_urlEdit) {
            m_urlEdit->setText(url.toString());
        }

        m_htmlWidget->load(url);

        // Update UI
        if (m_backAction && m_forwardAction) {
            m_backAction->setEnabled(m_historyIndex > 0);
            m_forwardAction->setEnabled(m_historyIndex < m_history.size() - 1);
        }

        updateTitle(QString());
    }
}

void MainWindow::zoomIn()
{
    // Implement zoom functionality
}

void MainWindow::zoomOut()
{
    // Implement zoom functionality
}

void MainWindow::resetZoom()
{
    // Implement zoom functionality
}

void MainWindow::about()
{
    QMessageBox::about(this, tr("About Qlith Browser"),
                       tr("A simple HTML browser demo using the Qlith library."));
}

void MainWindow::handleLinkClick(const QUrl &url)
{
    // Handle clicked links - navigate to them
    load(url);
}

void MainWindow::updateTitle(const QString &title)
{
    QString windowTitle;

    if (!title.isEmpty()) {
        windowTitle = title;
    } else if (m_historyIndex >= 0 && m_historyIndex < m_history.size()) {
        windowTitle = m_history.at(m_historyIndex).toString();
    } else {
        windowTitle = tr("Qlith Browser");
    }

    // Add browser name if not already there
    if (!windowTitle.contains("Qlith Browser")) {
        windowTitle = tr("%1 - Qlith Browser").arg(windowTitle);
    }

    setWindowTitle(windowTitle);
}

void MainWindow::onLoadStarted()
{
    // Update status bar
    if (m_statusBar) {
        m_statusBar->showMessage(tr("Loading..."));
    }
}

void MainWindow::setupConnections()
{
    // Connect QlithWidget signals
    connect(m_htmlWidget, &QlithWidget::loadStarted, this, &MainWindow::onLoadStarted);
    connect(m_htmlWidget, &QlithWidget::loadFinished, this, &MainWindow::onLoadFinished);
    connect(m_htmlWidget, &QlithWidget::titleChanged, this, &MainWindow::updateTitle);
    connect(m_htmlWidget, &QlithWidget::linkClicked, this, &MainWindow::handleLinkClick);

    // Connect URL bar
    if (m_urlEdit) {
        connect(m_urlEdit, &QLineEdit::returnPressed, this, &MainWindow::loadUrl);
    }

    // Connect actions
    if (m_backAction) {
        connect(m_backAction, &QAction::triggered, this, &MainWindow::goBack);
    }

    if (m_forwardAction) {
        connect(m_forwardAction, &QAction::triggered, this, &MainWindow::goForward);
    }

    if (m_reloadAction) {
        connect(m_reloadAction, &QAction::triggered, this, &MainWindow::reload);
    }

    if (m_stopAction) {
        connect(m_stopAction, &QAction::triggered, this, &MainWindow::stop);
    }
}

void MainWindow::load(const QUrl& url)
{
    if (!url.isValid())
        return;

    if (m_urlEdit) {
        m_urlEdit->setText(url.toString());
    }

    m_htmlWidget->load(url);

    // Add to history
    if (m_historyIndex >= 0 && m_historyIndex < m_history.size() - 1) {
        // Remove forward history if we navigate from a point in history
        m_history.erase(m_history.begin() + m_historyIndex + 1, m_history.end());
    }

    m_history.append(url);
    // Limit history size
    while (m_history.size() > 100) {
        m_history.removeFirst();
    }
    m_historyIndex = m_history.size() - 1;

    // Update UI
    if (m_backAction && m_forwardAction) {
        m_backAction->setEnabled(m_historyIndex > 0);
        m_forwardAction->setEnabled(m_historyIndex < m_history.size() - 1);
    }
}

void MainWindow::stop()
{
    if (m_htmlWidget) {
        m_htmlWidget->stop();
    }

    // Update status bar
    if (m_statusBar) {
        m_statusBar->showMessage(tr("Stopped"));
    }
}

void MainWindow::setupUi()
{
    // Main widget is already set in constructor
    // Additional UI setup if needed
}

void MainWindow::setupActions()
{
    m_backAction = new QAction(tr("Back"), this);
    m_backAction->setIcon(QIcon::fromTheme("go-previous"));
    m_backAction->setShortcut(QKeySequence::Back);
    m_backAction->setToolTip(tr("Go back to previous page"));

    m_forwardAction = new QAction(tr("Forward"), this);
    m_forwardAction->setIcon(QIcon::fromTheme("go-next"));
    m_forwardAction->setShortcut(QKeySequence::Forward);
    m_forwardAction->setToolTip(tr("Go forward to next page"));

    m_reloadAction = new QAction(tr("Reload"), this);
    m_reloadAction->setIcon(QIcon::fromTheme("view-refresh"));
    m_reloadAction->setShortcut(QKeySequence::Refresh);
    m_reloadAction->setToolTip(tr("Reload current page"));

    m_stopAction = new QAction(tr("Stop"), this);
    m_stopAction->setIcon(QIcon::fromTheme("process-stop"));
    m_stopAction->setShortcut(Qt::Key_Escape);
    m_stopAction->setToolTip(tr("Stop loading page"));

    m_viewSourceAction = new QAction(tr("View Source"), this);
    m_viewSourceAction->setToolTip(tr("View page source"));

    m_zoomInAction = new QAction(tr("Zoom In"), this);
    m_zoomInAction->setIcon(QIcon::fromTheme("zoom-in"));
    m_zoomInAction->setShortcut(QKeySequence::ZoomIn);

    m_zoomOutAction = new QAction(tr("Zoom Out"), this);
    m_zoomOutAction->setIcon(QIcon::fromTheme("zoom-out"));
    m_zoomOutAction->setShortcut(QKeySequence::ZoomOut);

    m_resetZoomAction = new QAction(tr("Reset Zoom"), this);
    m_resetZoomAction->setIcon(QIcon::fromTheme("zoom-original"));
    m_resetZoomAction->setShortcut(QKeySequence(tr("Ctrl+0")));

    m_exitAction = new QAction(tr("Exit"), this);
    m_exitAction->setShortcut(QKeySequence::Quit);
    connect(m_exitAction, &QAction::triggered, this, &QWidget::close);

    m_aboutAction = new QAction(tr("About"), this);
    connect(m_aboutAction, &QAction::triggered, this, &MainWindow::about);

    // Update initial state
    m_backAction->setEnabled(false);
    m_forwardAction->setEnabled(false);
}

void MainWindow::setupMenus()
{
    m_fileMenu = menuBar()->addMenu(tr("&File"));
    m_fileMenu->addAction(m_exitAction);

    m_viewMenu = menuBar()->addMenu(tr("&View"));
    m_viewMenu->addAction(m_backAction);
    m_viewMenu->addAction(m_forwardAction);
    m_viewMenu->addAction(m_reloadAction);
    m_viewMenu->addAction(m_stopAction);
    m_viewMenu->addSeparator();
    m_viewMenu->addAction(m_zoomInAction);
    m_viewMenu->addAction(m_zoomOutAction);
    m_viewMenu->addAction(m_resetZoomAction);
    m_viewMenu->addSeparator();
    m_viewMenu->addAction(m_viewSourceAction);

    m_helpMenu = menuBar()->addMenu(tr("&Help"));
    m_helpMenu->addAction(m_aboutAction);
}

void MainWindow::setupToolbar()
{
    m_navigationToolBar = addToolBar(tr("Navigation"));
    m_navigationToolBar->addAction(m_backAction);
    m_navigationToolBar->addAction(m_forwardAction);
    m_navigationToolBar->addAction(m_reloadAction);
    m_navigationToolBar->addAction(m_stopAction);

    // Add URL bar
    m_urlEdit = new QLineEdit(this);
    m_urlEdit->setClearButtonEnabled(true);
    m_urlEdit->setPlaceholderText(tr("Enter URL..."));
    m_navigationToolBar->addWidget(m_urlEdit);
}

void MainWindow::setupStatusBar()
{
    m_statusBar = statusBar();
    m_statusBar->showMessage(tr("Ready"));

    // Add progress bar
    m_progressBar = new QProgressBar(this);
    m_progressBar->setMaximumWidth(150);
    m_progressBar->setMaximumHeight(16);
    m_progressBar->setVisible(false);
    m_statusBar->addPermanentWidget(m_progressBar);
}

void MainWindow::loadSettings()
{
    QSettings settings;

    // Window geometry
    const QByteArray geometry = settings.value("geometry", QByteArray()).toByteArray();
    if (!geometry.isEmpty()) {
        restoreGeometry(geometry);
    }

    // Start URL
    m_startUrl = settings.value("startUrl", QUrl("about:blank")).toUrl();
    if (m_startUrl.isValid()) {
        load(m_startUrl);
    }
}

void MainWindow::saveSettings()
{
    QSettings settings;

    // Window geometry
    settings.setValue("geometry", saveGeometry());

    // Current URL
    if (m_historyIndex >= 0 && m_historyIndex < m_history.size()) {
        settings.setValue("startUrl", m_history.at(m_historyIndex));
    }
}

void MainWindow::viewSource()
{
    // Simple implementation to view the HTML source
    if (m_historyIndex >= 0 && m_historyIndex < m_history.size()) {
        // Get the HTML from the current page
        // This would require access to the raw HTML content
        QMessageBox::information(this, tr("View Source"),
                              tr("View source not implemented yet."));
    }
}

void MainWindow::setRenderSize(const QSize& size)
{
    qDebug() << "Setting render size to:" << size;
    m_renderSize = size;
}

bool MainWindow::exportToSvg(const QString& filePath)
{
    if (!m_htmlWidget) {
        return false;
    }

    // Create directory if it doesn't exist
    QFileInfo fileInfo(filePath);
    QDir dir = fileInfo.dir();
    if (!dir.exists()) {
        if (!dir.mkpath(".")) {
            qWarning() << "Failed to create directory for SVG export:" << dir.path();
            return false;
        }
    }

    // Create SVG generator
    QSvgGenerator generator;
    generator.setFileName(filePath);

    // Get sizes - in qlith-mini we need to get document size directly from the document
    QSize widgetSize = m_htmlWidget->size();
    QSize documentSize;

    // Get document size from litehtml document if available
    auto doc = m_htmlWidget->document();
    if (doc) {
        documentSize = QSize(doc->width(), doc->height());
    }

    qDebug() << "SVG Export - Widget size:" << widgetSize;
    qDebug() << "SVG Export - Document size:" << documentSize;
    qDebug() << "SVG Export - Requested render size:" << m_renderSize;

    // Use custom render size if set, or document size, or widget size as fallback
    QSize exportSize;
    if (m_renderSize.isValid()) {
        exportSize = m_renderSize;
    } else if (documentSize.isValid() && documentSize.width() > 0 && documentSize.height() > 0) {
        exportSize = documentSize;
    } else {
        exportSize = widgetSize;
    }

    qDebug() << "SVG Export - Using export size:" << exportSize;

    generator.setSize(exportSize);
    generator.setViewBox(QRect(0, 0, exportSize.width(), exportSize.height()));
    generator.setTitle(windowTitle());
    generator.setDescription(tr("Generated by Qlith Browser"));

    // Render to SVG
    QPainter painter;
    if (!painter.begin(&generator)) {
        qWarning() << "Failed to start painting to SVG file:" << filePath;
        return false;
    }

    // Apply appropriate scaling
    if (documentSize.isValid() && documentSize.width() > 0 && documentSize.height() > 0) {
        // Scale based on document size while maintaining aspect ratio
        double scaleX = (double)exportSize.width() / documentSize.width();
        double scaleY = (double)exportSize.height() / documentSize.height();

        // Use the minimum scale factor to fit while preserving aspect ratio
        double scale = qMin(scaleX, scaleY);
        painter.scale(scale, scale);

        // Center the content
        if (scaleX > scaleY) {
            double offsetX = (exportSize.width() - documentSize.width() * scale) / (2 * scale);
            painter.translate(offsetX, 0);
        } else {
            double offsetY = (exportSize.height() - documentSize.height() * scale) / (2 * scale);
            painter.translate(0, offsetY);
        }

        qDebug() << "SVG Export - Applied scale:" << scale << "with centering";
    }

    // Let the widget render into the painter
    m_htmlWidget->render(&painter);

    painter.end();

    qInfo() << "Exported SVG to:" << filePath;
    return true;
}

bool MainWindow::exportToPng(const QString& filePath)
{
    if (!m_htmlWidget) {
        qWarning() << "exportToPng: HTML widget is null";
        return false;
    }

    qDebug() << "exportToPng: Starting PNG export to" << filePath;

    // Create directory if it doesn't exist
    QFileInfo fileInfo(filePath);
    QDir dir = fileInfo.dir();
    if (!dir.exists()) {
        if (!dir.mkpath(".")) {
            qWarning() << "Failed to create directory for PNG export:" << dir.path();
            return false;
        }
    }

    // Get document object to determine its true size
    auto doc = m_htmlWidget->document();
    if (!doc) {
        qWarning() << "exportToPng: No document available for rendering";
        return false;
    }

    // Get sizes - in qlith-mini we need to get document size directly from the document
    QSize widgetSize = m_htmlWidget->size();
    QSize documentSize(doc->width(), doc->height());
    QSize originalRenderSize = m_renderSize;

    qDebug() << "PNG Export - Widget size:" << widgetSize;
    qDebug() << "PNG Export - Document size:" << documentSize;
    qDebug() << "PNG Export - Requested render size:" << m_renderSize;

    // Ensure the widget is large enough to render the full content
    QSize targetSize;
    if (m_renderSize.isValid()) {
        // If render size is specified, use it but ensure it's at least as large as the document
        targetSize = QSize(
            qMax(m_renderSize.width(), documentSize.width()),
            qMax(m_renderSize.height(), documentSize.height())
        );
    } else {
        // If no render size specified, use the document size
        targetSize = documentSize;
    }

    qDebug() << "PNG Export - Target render size:" << targetSize;

    // Temporarily resize widget to ensure full content is visible
    m_htmlWidget->resize(targetSize);

    // Force a relayout
    m_htmlWidget->reload();

    // Process events to ensure the layout is complete
    QApplication::processEvents();

    // Get the document size again after resize, as it may have changed
    if (doc) {
        documentSize = QSize(doc->width(), doc->height());
        qDebug() << "PNG Export - Document size after resize:" << documentSize;
    }

    // Create a pixmap that's large enough for the entire document
    QSize exportSize = QSize(
        qMax(targetSize.width(), documentSize.width()),
        qMax(targetSize.height(), documentSize.height())
    );

    qDebug() << "PNG Export - Final export size:" << exportSize;

    // Create a pixmap with the export size
    QPixmap pixmap(exportSize);
    pixmap.fill(Qt::white);

    // Create a painter for the pixmap
    QPainter painter(&pixmap);

    // Let the widget render into the painter - document will draw at full height
    qDebug() << "Rendering widget to pixmap";
    m_htmlWidget->render(&painter);
    painter.end();

    // Save to PNG
    qDebug() << "Saving pixmap to PNG file:" << filePath;
    bool result = pixmap.save(filePath, "PNG");
    if (result) {
        qInfo() << "Successfully exported PNG to:" << filePath;
    } else {
        qWarning() << "Failed to save PNG to:" << filePath;
    }

    // Restore original widget size if we resized it
    if (originalRenderSize.isValid()) {
        m_htmlWidget->resize(originalRenderSize);
        m_htmlWidget->reload();
    }

    return result;
}
</file>

<file path="mainwindow.h">
// this_file: qlith/browser/mainwindow.h
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include <QUrl>

class QLineEdit;
class QProgressBar;
class QlithWidget;
class QAction;
class QToolBar;
class QStatusBar;
class QMenu;

/**
 * @brief The MainWindow class provides the main browser window for the qlith browser.
 *
 * This class represents the main window of the browser application, containing
 * a QlithWidget for rendering HTML content, navigation controls, and other browser
 * functionality.
 */
class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    /**
     * @brief Constructs a MainWindow.
     * @param parent The parent widget.
     */
    explicit MainWindow(QWidget* parent = nullptr);

    /**
     * @brief Destroys the MainWindow.
     */
    ~MainWindow() override;

    /**
     * @brief Load content from a URL.
     * @param url The URL to load.
     */
    void load(const QUrl& url);

    /**
     * @brief Export the current view to an SVG file.
     * @param filePath The path where to save the SVG file.
     * @return True if export was successful, false otherwise.
     */
    bool exportToSvg(const QString& filePath);

    /**
     * @brief Export the current view to a PNG file.
     * @param filePath The path where to save the PNG file.
     * @return True if export was successful, false otherwise.
     */
    bool exportToPng(const QString& filePath);

    /**
     * @brief Set the rendering size for export operations.
     * @param size The size to use for rendering.
     */
    void setRenderSize(const QSize& size);

signals:
    /**
     * @brief Signal emitted when page loading is finished.
     * @param ok True if loading was successful, false otherwise.
     */
    void loadFinished(bool ok);

protected:
    void closeEvent(QCloseEvent* event) override;

private slots:
    void loadUrl();
    void updateUrlBar(const QUrl& url);
    void updateTitle(const QString& title);
    void handleLinkClick(const QUrl& url);
    void onLoadStarted();
    void onLoadFinished(bool ok);

    // Actions
    void goBack();
    void goForward();
    void reload();
    void stop();
    void zoomIn();
    void zoomOut();
    void resetZoom();
    void viewSource();
    void about();

private:
    void setupUi();
    void setupActions();
    void setupMenus();
    void setupToolbar();
    void setupStatusBar();
    void setupConnections();
    void loadSettings();
    void saveSettings();

    QlithWidget* m_htmlWidget;
    QLineEdit* m_urlEdit;
    QProgressBar* m_progressBar;
    QToolBar* m_navigationToolBar;
    QStatusBar* m_statusBar;

    // Menus
    QMenu* m_fileMenu;
    QMenu* m_viewMenu;
    QMenu* m_helpMenu;

    // Actions
    QAction* m_backAction;
    QAction* m_forwardAction;
    QAction* m_reloadAction;
    QAction* m_stopAction;
    QAction* m_zoomInAction;
    QAction* m_zoomOutAction;
    QAction* m_resetZoomAction;
    QAction* m_viewSourceAction;
    QAction* m_exitAction;
    QAction* m_aboutAction;

    // History management
    QList<QUrl> m_history;
    int m_historyIndex;
    QUrl m_startUrl;

    // Zoom
    float m_zoomFactor;

    // Rendering size for export operations
    QSize m_renderSize;
};

#endif // MAINWINDOW_H
</file>

<file path="qlith/affinetransform.h">
// this_file: qlith-pro/include/qlith/affinetransform.h
#pragma once

#include "qlith/transformationmatrix.h"

#include "qlith/common.h"

//#include <string.h> // for memcpy

#include <QTransform>

#include <memory>
#include <cstdio>
#include <cstring>

#include "qlith/floatquad.h"

using namespace std;

/*#include <wtf/FastAllocBase.h>

#if PLATFORM(CG)
#include <CoreGraphics/CGAffineTransform.h>
#elif PLATFORM(CAIRO)
#include <cairo.h>
#elif PLATFORM(OPENVG)
#include "VGUtils.h"
#elif PLATFORM(QT)
#include <QTransform>
#elif PLATFORM(SKIA)
#include <SkMatrix.h>
#elif PLATFORM(WX) && USE(WXGC)
#include <wx/graphics.h>
#endif*/

/*class FloatPoint;
class FloatQuad;
class FloatRect;
class IntPoint;
class IntRect;
class TransformationMatrix;*/

class AffineTransform /*: public FastAllocBase*/ {
public:
    typedef double Transform[6];

    AffineTransform();
    AffineTransform(double a, double b, double c, double d, double e, double f);

    void setMatrix(double a, double b, double c, double d, double e, double f);

    void map(double x, double y, double& x2, double& y2) const;

    // Rounds the mapped point to the nearest integer value.
    IntPoint mapPoint(const IntPoint&) const;

    FloatPoint mapPoint(const FloatPoint&) const;

    // Rounds the resulting mapped rectangle out. This is helpful for bounding
    // box computations but may not be what is wanted in other contexts.
    IntRect mapRect(const IntRect&) const;

    FloatRect mapRect(const FloatRect&) const;
    FloatQuad mapQuad(const FloatQuad&) const;

    bool isIdentity() const;

    double a() const { return m_transform[0]; }
    void setA(double a) { m_transform[0] = a; }
    double b() const { return m_transform[1]; }
    void setB(double b) { m_transform[1] = b; }
    double c() const { return m_transform[2]; }
    void setC(double c) { m_transform[2] = c; }
    double d() const { return m_transform[3]; }
    void setD(double d) { m_transform[3] = d; }
    double e() const { return m_transform[4]; }
    void setE(double e) { m_transform[4] = e; }
    double f() const { return m_transform[5]; }
    void setF(double f) { m_transform[5] = f; }

    void makeIdentity();

    AffineTransform& multiply(const AffineTransform&);
    AffineTransform& multLeft(const AffineTransform&);
    AffineTransform& scale(double);
    AffineTransform& scale(double sx, double sy);
    AffineTransform& scaleNonUniform(double sx, double sy);
    AffineTransform& rotate(double d);
    AffineTransform& rotateFromVector(double x, double y);
    AffineTransform& translate(double tx, double ty);
    AffineTransform& translateRight(double tx, double ty);
    AffineTransform& shear(double sx, double sy);
    AffineTransform& flipX();
    AffineTransform& flipY();
    AffineTransform& skew(double angleX, double angleY);
    AffineTransform& skewX(double angle);
    AffineTransform& skewY(double angle);

    double xScale() const;
    double yScale() const;

    double det() const;
    bool isInvertible() const;
    AffineTransform inverse() const;

    void blend(const AffineTransform& from, double progress);

    TransformationMatrix toTransformationMatrix() const;

    bool isIdentityOrTranslation() const
    {
        return m_transform[0] == 1 && m_transform[1] == 0 && m_transform[2] == 0 && m_transform[3] == 1;
    }

    bool isIdentityOrTranslationOrFlipped() const
    {
        return m_transform[0] == 1 && m_transform[1] == 0 && m_transform[2] == 0 && (m_transform[3] == 1 || m_transform[3] == -1);
    }

    bool operator== (const AffineTransform& m2) const
    {
        return (m_transform[0] == m2.m_transform[0]
             && m_transform[1] == m2.m_transform[1]
             && m_transform[2] == m2.m_transform[2]
             && m_transform[3] == m2.m_transform[3]
             && m_transform[4] == m2.m_transform[4]
             && m_transform[5] == m2.m_transform[5]);
    }

    bool operator!=(const AffineTransform& other) const { return !(*this == other); }

    // *this = *this * t (i.e., a multRight)
    AffineTransform& operator*=(const AffineTransform& t)
    {
        *this = *this * t;
        return *this;
    }

    // result = *this * t (i.e., a multRight)
    AffineTransform operator*(const AffineTransform& t) const
    {
        AffineTransform result = t;
        result.multLeft(*this);
        return result;
    }

  operator QTransform() const;

/*#if PLATFORM(CG)
    operator CGAffineTransform() const;
#elif PLATFORM(CAIRO)
    operator cairo_matrix_t() const;
#elif PLATFORM(OPENVG)
    operator VGMatrix() const;
#elif PLATFORM(QT)
    operator QTransform() const;
#elif PLATFORM(SKIA)
    operator SkMatrix() const;
#elif PLATFORM(WX) && USE(WXGC)
    operator wxGraphicsMatrix() const;
#endif*/

private:
    void setMatrix(const Transform m)
    {
        if (m && m != m_transform)
            memcpy(m_transform, m, sizeof(Transform));
    }

    Transform m_transform;
};

AffineTransform makeMapBetweenRects(const FloatRect& source, const FloatRect& dest);
</file>

<file path="qlith/bitmapimage.h">
// this_file: qlith-pro/include/qlith/bitmapimage.h
#pragma once

#include "qlith/common.h"
#include "qlith/image.h"
#include "qlith/color.h"
#include "qlith/intsize.h"
#include "qlith/imageobserver.h"

struct FrameData;

// This complicated-looking declaration tells the FrameData Vector that it should copy without
// invoking our constructor or destructor. This allows us to have a vector even for a struct
// that's not copyable.
/*namespace WTF {
    template<> struct VectorTraits<WebCore::FrameData> : public SimpleClassVectorTraits {};
}*/

    // TODO
//template <typename T> class Timer;

// ================================================
// FrameData Class
// ================================================

struct FrameData /*: Noncopyable*/ {
    FrameData()
        : m_frame(0)
        , m_haveMetadata(false)
        , m_isComplete(false)
        , m_duration(0)
        , m_hasAlpha(true)
    {
    }

    ~FrameData()
    {
        clear(true);
    }

    // Clear the cached image data on the frame, and (optionally) the metadata.
    // Returns whether there was cached image data to clear.
    bool clear(bool clearMetadata);

    NativeImagePtr m_frame;
    bool m_haveMetadata;
    bool m_isComplete;
    float m_duration;
    bool m_hasAlpha;
};

// =================================================
// BitmapImage Class
// =================================================

class BitmapImage : public Image {
    friend class GeneratedImage;
    friend class GraphicsContext;
public:
    static PassRefPtr<BitmapImage> create(NativeImagePtr nativeImage, ImageObserver* observer = 0)
    {
        return adoptRef<BitmapImage>(nativeImage, observer);
    }
    static PassRefPtr<BitmapImage> create(ImageObserver* observer = 0)
    {
        return adoptRef<BitmapImage>(observer);
    }
    ~BitmapImage();

    virtual bool isBitmapImage() const { return true; }

    virtual bool hasSingleSecurityOrigin() const { return true; }

    virtual IntSize size() const;
    IntSize currentFrameSize() const;
    virtual bool getHotSpot(IntPoint&) const;

    virtual bool dataChanged(bool allDataReceived);
    virtual String filenameExtension() const;

    // It may look unusual that there is no start animation call as public API.  This is because
    // we start and stop animating lazily.  Animation begins whenever someone draws the image.  It will
    // automatically pause once all observers no longer want to render the image anywhere.
    virtual void stopAnimation();
    virtual void resetAnimation();

    virtual unsigned decodedSize() const { return m_decodedSize; }

    virtual NativeImagePtr nativeImageForCurrentFrame() { return frameAtIndex(currentFrame()); }

//protected:
public:
    enum RepetitionCountStatus {
      Unknown,    // We haven't checked the source's repetition count.
      Uncertain,  // We have a repetition count, but it might be wrong (some GIFs have a count after the image data, and will report "loop once" until all data has been decoded).
      Certain,    // The repetition count is known to be correct.
    };

    BitmapImage(NativeImagePtr, ImageObserver* = 0);
    BitmapImage(ImageObserver* = 0);

protected:
    virtual void draw(GraphicsContext*, const FloatRect& dstRect, const FloatRect& srcRect, ColorSpace styleColorSpace, CompositeOperator);


    size_t currentFrame() const { return m_currentFrame; }
    size_t frameCount();
    NativeImagePtr frameAtIndex(size_t);
    bool frameIsCompleteAtIndex(size_t);
    float frameDurationAtIndex(size_t);
    bool frameHasAlphaAtIndex(size_t);

    // Decodes and caches a frame. Never accessed except internally.
    void cacheFrame(size_t index);

    // Called to invalidate cached data.  When |destroyAll| is true, we wipe out
    // the entire frame buffer cache and tell the image source to destroy
    // everything; this is used when e.g. we want to free some room in the image
    // cache.  If |destroyAll| is false, we only delete frames up to the current
    // one; this is used while animating large images to keep memory footprint
    // low without redecoding the whole image on every frame.
    virtual void destroyDecodedData(bool destroyAll = true);

    // If the image is large enough, calls destroyDecodedData() and passes
    // |destroyAll| along.
    void destroyDecodedDataIfNecessary(bool destroyAll);

    // Generally called by destroyDecodedData(), destroys whole-image metadata
    // and notifies observers that the memory footprint has (hopefully)
    // decreased by |framesCleared| times the size (in bytes) of a frame.
    void destroyMetadataAndNotify(int framesCleared);

    // Whether or not size is available yet.
    bool isSizeAvailable();

    // Animation.
    int repetitionCount(bool imageKnownToBeComplete);  // |imageKnownToBeComplete| should be set if the caller knows the entire image has been decoded.
    bool shouldAnimate();
    virtual void startAnimation(bool catchUpIfNecessary = true);

    // TODO
    //void advanceAnimation(Timer<BitmapImage>*);

    // Function that does the real work of advancing the animation.  When
    // skippingFrames is true, we're in the middle of a loop trying to skip over
    // a bunch of animation frames, so we should not do things like decode each
    // one or notify our observers.
    // Returns whether the animation was advanced.
    bool internalAdvanceAnimation(bool skippingFrames);

    // Handle platform-specific data
    void initPlatformData();
    void invalidatePlatformData();

    // Checks to see if the image is a 1x1 solid color.  We optimize these images and just do a fill rect instead.
    // This check should happen regardless whether m_checkedForSolidColor is already set, as the frame may have
    // changed.
    void checkForSolidColor();

    virtual bool mayFillWithSolidColor()
    {
        if (!m_checkedForSolidColor && frameCount() > 0) {
            checkForSolidColor();
            // WINCE PORT: checkForSolidColor() doesn't set m_checkedForSolidColor until
            // it gets enough information to make final decision.

            ASSERT(m_checkedForSolidColor);

        }
        return m_isSolidColor && m_currentFrame == 0;
    }
    virtual Color solidColor() const { return m_solidColor; }

    ImageSource m_source;
    mutable IntSize m_size; // The size to use for the overall image (will just be the size of the first image).

    size_t m_currentFrame; // The index of the current frame of animation.
    QVector<FrameData> m_frames; // An array of the cached frames of the animation. We have to ref frames to pin them in the cache.

    // TODO
    //Timer<BitmapImage>* m_frameTimer;

    int m_repetitionCount; // How many total animation loops we should do.  This will be cAnimationNone if this image type is incapable of animation.
    RepetitionCountStatus m_repetitionCountStatus;
    int m_repetitionsComplete;  // How many repetitions we've finished.
    double m_desiredFrameStartTime;  // The system time at which we hope to see the next call to startAnimation().

    Color m_solidColor;  // If we're a 1x1 solid color, this is the color to use to fill.
    bool m_isSolidColor;  // Whether or not we are a 1x1 solid image.
    bool m_checkedForSolidColor; // Whether we've checked the frame for solid color.

    bool m_animationFinished;  // Whether or not we've completed the entire animation.

    bool m_allDataReceived;  // Whether or not we've received all our data.

    mutable bool m_haveSize; // Whether or not our |m_size| member variable has the final overall image size yet.
    bool m_sizeAvailable; // Whether or not we can obtain the size of the first image frame yet from ImageIO.
    mutable bool m_hasUniformFrameSize;

    unsigned m_decodedSize; // The current size of all decoded frames.

    mutable bool m_haveFrameCount;
    size_t m_frameCount;
};
</file>

<file path="qlith/color.h">
// this_file: qlith-pro/include/qlith/color.h
#pragma once

#include <qglobal.h>

#include <QDebug>
#include <QFont>
#include <QFontMetrics>
#include <QPainter>
#include <QMouseEvent>
#include <QDesktopServices>
#include <QColor>

#include "qlith/common.h"

class Color;

typedef unsigned RGBA32;        // RGBA quadruplet

RGBA32 makeRGB(int r, int g, int b);
RGBA32 makeRGBA(int r, int g, int b, int a);

RGBA32 colorWithOverrideAlpha(RGBA32 color, float overrideAlpha);
RGBA32 makeRGBA32FromFloats(float r, float g, float b, float a);
RGBA32 makeRGBAFromHSLA(double h, double s, double l, double a);
RGBA32 makeRGBAFromCMYKA(float c, float m, float y, float k, float a);

int differenceSquared(const Color&, const Color&);

inline int redChannel(RGBA32 color) { return (color >> 16) & 0xFF; }
inline int greenChannel(RGBA32 color) { return (color >> 8) & 0xFF; }
inline int blueChannel(RGBA32 color) { return color & 0xFF; }
inline int alphaChannel(RGBA32 color) { return (color >> 24) & 0xFF; }

class Color /*: public FastAllocBase*/ {
public:
    Color() : m_color(0), m_valid(false) { }
    Color(RGBA32 col) : m_color(col), m_valid(true) { }
    Color(int r, int g, int b) : m_color(makeRGB(r, g, b)), m_valid(true) { }
    Color(int r, int g, int b, int a) : m_color(makeRGBA(r, g, b, a)), m_valid(true) { }
    // Color is currently limited to 32bit RGBA, perhaps some day we'll support better colors
    Color(float r, float g, float b, float a) : m_color(makeRGBA32FromFloats(r, g, b, a)), m_valid(true) { }
    // Creates a new color from the specific CMYK and alpha values.
    Color(float c, float m, float y, float k, float a) : m_color(makeRGBAFromCMYKA(c, m, y, k, a)), m_valid(true) { }
    explicit Color(const String&);
    explicit Color(const char*);

    // Returns the color serialized according to HTML5
    // - http://www.whatwg.org/specs/web-apps/current-work/#serialization-of-a-color
    //String serialized() const;

    /*String name() const;
    void setNamedColor(const String&);*/

    bool isValid() const { return m_valid; }

    bool hasAlpha() const { return alpha() < 255; }

    int red() const { return redChannel(m_color); }
    int green() const { return greenChannel(m_color); }
    int blue() const { return blueChannel(m_color); }
    int alpha() const { return alphaChannel(m_color); }

    RGBA32 rgb() const { return m_color; } // Preserve the alpha.
    void setRGB(int r, int g, int b) { m_color = makeRGB(r, g, b); m_valid = true; }
    void setRGB(RGBA32 rgb) { m_color = rgb; m_valid = true; }
    void getRGBA(float& r, float& g, float& b, float& a) const;
    void getRGBA(double& r, double& g, double& b, double& a) const;
    void getHSL(double& h, double& s, double& l) const;

    Color light() const;
    Color dark() const;

    Color blend(const Color&) const;
    Color blendWithWhite() const;

    Color(const QColor&);
    operator QColor() const;

    static bool parseHexColor(const String& name, RGBA32& rgb);
    static bool parseHexColor(const UChar* name, unsigned length, RGBA32& rgb);

    static const RGBA32 black = 0xFF000000;
    static const RGBA32 white = 0xFFFFFFFF;
    static const RGBA32 darkGray = 0xFF808080;
    static const RGBA32 gray = 0xFFA0A0A0;
    static const RGBA32 lightGray = 0xFFC0C0C0;
    static const RGBA32 transparent = 0x00000000;

private:
    RGBA32 m_color;
    bool m_valid;
};

inline bool operator==(const Color& a, const Color& b)
{
    return a.rgb() == b.rgb() && a.isValid() == b.isValid();
}

inline bool operator!=(const Color& a, const Color& b)
{
    return !(a == b);
}

Color colorFromPremultipliedARGB(unsigned);
unsigned premultipliedARGBFromColor(const Color&);

/*#if PLATFORM(CG)
CGColorRef cachedCGColor(const Color&, ColorSpace);
#endif*/
</file>

<file path="qlith/common.h">
// this_file: qlith-pro/include/qlith/common.h
#pragma once


#include <qglobal.h>

#include <QtCore>
#include <QVector>

#include <QSet>
#include <QHash>
#include <QDebug>
#include <QFont>
#include <QFontMetrics>
#include <QPainter>
#include <QMouseEvent>
#include <QDesktopServices>
#include <QColor>
#include <QPoint>
#include <QPointF>

//#include "types.h"
#include <QPainter>

#include "qlith/fontcache.h"

#define    _USE_MATH_DEFINES
#include <iostream>
#include <cmath>
#include <string>
#include <memory>
#include <string>
#include <cassert>

// Define ASSERT macro
// #define ASSERT(condition) assert(condition) // Keep Q_ASSERT below

namespace litehtml {
  struct web_color;
}

class Color;

Color toColor(const litehtml::web_color& clr);

#include "qlith/floatpoint.h"
#include "qlith/intpoint.h"
#include "qlith/intsize.h"
#include "qlith/floatsize.h"
#include "qlith/intrect.h"

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/JavaScriptCore/wtf/FastMalloc.cpp
//#define fastMalloc malloc

//#define tryFastMalloc(string) mallocc<false>(string)

///////

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/rendering/style/RenderStyleConstants.h#L90

// These have been defined in the order of their precedence for border-collapsing. Do
// not change this order!
enum EBorderStyle { BNONE, BHIDDEN, INSET, GROOVE, RIDGE, OUTSET, DOTTED, DASHED, SOLID, DOUBLE };

///////

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/DashArray.h
typedef QVector<float> DashArray;

/////////

// Use Q_ASSERT for Qt projects
#define ASSERT(condition) Q_ASSERT(condition)

#define CRASH(string) Q_ASSERT(false)

#define ALWAYS_INLINE inline

#define ASSERT_DISABLED 1

////////////

//https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/JavaScriptCore/wtf/NotFound.h
const size_t notFound = static_cast<size_t>(-1);

////////////

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/JavaScriptCore/wtf/StdLibExtras.h
#define reinterpret_cast_ptr reinterpret_cast

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/JavaScriptCore/wtf/StdLibExtras.h#L34
#ifndef DEFINE_STATIC_LOCAL
#define DEFINE_STATIC_LOCAL(type, name, arguments) \
    static type& name = *new type arguments
#endif

// OBJECT_OFFSETOF: Like the C++ offsetof macro, but you can use it with classes.
// The magic number 0x4000 is insignificant. We use it to avoid using NULL, since
// NULL can cause compiler problems, especially in cases of multiple inheritance.
#define OBJECT_OFFSETOF(class, field) (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<class*>(0x4000)->field)) - 0x4000)

// STRINGIZE: Can convert any value to quoted string, even expandable macros
#define STRINGIZE(exp) #exp
#define STRINGIZE_VALUE_OF(exp) STRINGIZE(exp)

//#define WTF std

////////////

// https://github.com/trevorlinton/webkit.js/blob/15306b5c540ccafc3be008225eafebd1932d356d/deps/WebKit/Source/WTF/wtf/ASCIICType.h#L56
template<typename CharType> inline bool isASCIIDigit(CharType c)
{
    return c >= '0' && c <= '9';
}

template<typename CharType> inline bool isASCIIHexDigit(CharType c)
{
    return isASCIIDigit(c) || ((c | 0x20) >= 'a' && (c | 0x20) <= 'f');
}

template<typename CharType> inline int toASCIIHexValue(CharType c)
{
    //ASSERT(isASCIIHexDigit(c));
    ASSERT(isASCIIHexDigit(c));
    return c < 'A' ? c - '0' : (c - 'A' + 10) & 0xF;
}

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/make-hash-tools.pl#L57
struct NamedColor {
    const char* name;
    int RGBValue;
};

// Use QString as the primary String type
typedef QString String;

template <class Key>
using HashSet = QSet<Key>;
template <class Key, class Value>
using HashMap = QHash<Key, Value>;
//template <typename A, typename B>
//typedef QHash<A,B> HashSet<A,B>;

typedef char UChar;


//////////////////
// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/FloatConversion.h#L38

    template<typename T>
    float narrowPrecisionToFloat(T);

    template<>
    inline float narrowPrecisionToFloat(double number)
    {
        return static_cast<float>(number);
    }

/////////////////

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/qt/PathQt.cpp#L266
//#define DEGREES(t) ((t) * 180.0 / M_PI)

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/qt/FloatPointQt.cpp
//#define FloatPoint QPointF

//https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/qt/FloatRectQt.cpp
//#define FloatRect QRectF

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/FloatSize.h
//#define FloatSize QSizeF

//#define FloatQuad QPolygonF

/////////////////



    typedef QPainter PlatformGraphicsContext;

    //typedef QColor Color;
    //typedef QFont Font;
    //typedef QColorSpace ColorSpace;
    //typedef QPattern Pattern;
    //typedef QPattern Gradient;
    //typedef QRect IntRect;
    //typedef QSize IntSize;
    //typedef QPoint IntPoint;
    //typedef QImage Image;

    //typedef QTransform TransformationMatrix;



    //#define Vector QVector

    #define RefPtr std::shared_ptr
    #define PassRefPtr std::shared_ptr

    #define OwnPtr std::unique_ptr
    #define PassOwnPtr std::unique_ptr

    #define adoptOwnPtr std::make_unique


    #define adoptRef std::make_shared

///////////////////////////////

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/ColorSpace.h
enum ColorSpace { DeviceColorSpace, sRGBColorSpace };

///////////////////////////////

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/rendering/RenderObject.h#L81

// Sides used when drawing borders and outlines.  This is in RenderObject rather than RenderBoxModelObject since outlines can
// be drawn by SVG around bounding boxes.
enum BoxSide {
    BSTop,
    BSBottom,
    BSLeft,
    BSRight
};

///////////////////////////////

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/JavaScriptCore/wtf/MathExtras.h

#include <cmath>
#include <cfloat>
#include <cstdlib>

/*#if OS(SOLARIS)
#include <ieeefp.h>
#endif

#if OS(OPENBSD)
#include <sys/types.h>
#include <machine/ieee.h>
#endif

#if COMPILER(MSVC)
#if OS(WINCE)
#include <stdlib.h>
#endif
#include <limits>
#endif*/

#ifndef M_PI
const double piDouble = 3.14159265358979323846;
const float piFloat = 3.14159265358979323846f;
#else
const double piDouble = M_PI;
const float piFloat = static_cast<float>(M_PI);
#endif

#ifndef M_PI_2
const double piOverTwoDouble = 1.57079632679489661923;
const float piOverTwoFloat = 1.57079632679489661923f;
#else
const double piOverTwoDouble = M_PI_2;
const float piOverTwoFloat = static_cast<float>(M_PI_2);
#endif

#ifndef M_PI_4
const double piOverFourDouble = 0.785398163397448309616;
const float piOverFourFloat = 0.785398163397448309616f;
#else
const double piOverFourDouble = M_PI_4;
const float piOverFourFloat = static_cast<float>(M_PI_4);
#endif

/*#if OS(DARWIN)

// Work around a bug in the Mac OS X libc where ceil(-0.1) return +0.
inline double wtf_ceil(double x) { return copysign(ceil(x), x); }

#define ceil(x) wtf_ceil(x)

#endif

#if OS(SOLARIS)

#ifndef isfinite
inline bool isfinite(double x) { return finite(x) && !isnand(x); }
#endif
#ifndef isinf
inline bool isinf(double x) { return !finite(x) && !isnand(x); }
#endif
#ifndef signbit
inline bool signbit(double x) { return x < 0.0; } // FIXME: Wrong for negative 0.
#endif

#endif

#if OS(OPENBSD)

#ifndef isfinite
inline bool isfinite(double x) { return finite(x); }
#endif
#ifndef signbit
inline bool signbit(double x) { struct ieee_double *p = (struct ieee_double *)&x; return p->dbl_sign; }
#endif

#endif

#if COMPILER(MSVC) || COMPILER(RVCT)

// We must not do 'num + 0.5' or 'num - 0.5' because they can cause precision loss.
static double round(double num)
{
    double integer = ceil(num);
    if (num > 0)
        return integer - num > 0.5 ? integer - 1.0 : integer;
    return integer - num >= 0.5 ? integer - 1.0 : integer;
}
static float roundf(float num)
{
    float integer = ceilf(num);
    if (num > 0)
        return integer - num > 0.5f ? integer - 1.0f : integer;
    return integer - num >= 0.5f ? integer - 1.0f : integer;
}
inline long long llround(double num) { return static_cast<long long>(round(num)); }
inline long long llroundf(float num) { return static_cast<long long>(roundf(num)); }
inline long lround(double num) { return static_cast<long>(round(num)); }
inline long lroundf(float num) { return static_cast<long>(roundf(num)); }
inline double trunc(double num) { return num > 0 ? floor(num) : ceil(num); }

#endif

#if COMPILER(MSVC)
// The 64bit version of abs() is already defined in stdlib.h which comes with VC10
#if COMPILER(MSVC9_OR_LOWER)
inline long long abs(long long num) { return _abs64(num); }
#endif

inline bool isinf(double num) { return !_finite(num) && !_isnan(num); }
inline bool isnan(double num) { return !!_isnan(num); }
inline bool signbit(double num) { return _copysign(1.0, num) < 0; }

inline double nextafter(double x, double y) { return _nextafter(x, y); }
inline float nextafterf(float x, float y) { return x > y ? x - FLT_EPSILON : x + FLT_EPSILON; }

inline double copysign(double x, double y) { return _copysign(x, y); }
inline int isfinite(double x) { return _finite(x); }

// Work around a bug in Win, where atan2(+-infinity, +-infinity) yields NaN instead of specific values.
inline double wtf_atan2(double x, double y)
{
    double posInf = std::numeric_limits<double>::infinity();
    double negInf = -std::numeric_limits<double>::infinity();
    double nan = std::numeric_limits<double>::quiet_NaN();

    double result = nan;

    if (x == posInf && y == posInf)
        result = piOverFourDouble;
    else if (x == posInf && y == negInf)
        result = 3 * piOverFourDouble;
    else if (x == negInf && y == posInf)
        result = -piOverFourDouble;
    else if (x == negInf && y == negInf)
        result = -3 * piOverFourDouble;
    else
        result = ::atan2(x, y);

    return result;
}

// Work around a bug in the Microsoft CRT, where fmod(x, +-infinity) yields NaN instead of x.
inline double wtf_fmod(double x, double y) { return (!isinf(x) && isinf(y)) ? x : fmod(x, y); }

// Work around a bug in the Microsoft CRT, where pow(NaN, 0) yields NaN instead of 1.
inline double wtf_pow(double x, double y) { return y == 0 ? 1 : pow(x, y); }

#define atan2(x, y) wtf_atan2(x, y)
#define fmod(x, y) wtf_fmod(x, y)
#define pow(x, y) wtf_pow(x, y)

#endif // COMPILER(MSVC)*/

inline double deg2rad(double d)  { return d * piDouble / 180.0; }
inline double rad2deg(double r)  { return r * 180.0 / piDouble; }
inline double deg2grad(double d) { return d * 400.0 / 360.0; }
inline double grad2deg(double g) { return g * 360.0 / 400.0; }
inline double turn2deg(double t) { return t * 360.0; }
inline double deg2turn(double d) { return d / 360.0; }
inline double rad2grad(double r) { return r * 200.0 / piDouble; }
inline double grad2rad(double g) { return g * piDouble / 200.0; }

inline float deg2rad(float d)  { return d * piFloat / 180.0f; }
inline float rad2deg(float r)  { return r * 180.0f / piFloat; }
inline float deg2grad(float d) { return d * 400.0f / 360.0f; }
inline float grad2deg(float g) { return g * 360.0f / 400.0f; }
inline float turn2deg(float t) { return t * 360.0f; }
inline float deg2turn(float d) { return d / 360.0f; }
inline float rad2grad(float r) { return r * 200.0f / piFloat; }
inline float grad2rad(float g) { return g * piFloat / 200.0f; }

/*#if !COMPILER(MSVC) && !COMPILER(WINSCW) && !(COMPILER(RVCT) && (OS(SYMBIAN) || PLATFORM(BREWMP)))
using std::isfinite;
using std::isinf;
using std::isnan;
using std::signbit;
#endif*/

/////////////////////

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/GraphicsTypes.h

   // Note: These constants exactly match the NSCompositeOperator constants of
    // AppKit on Mac OS X Tiger. If these ever change, we'll need to change the
    // Mac OS X Tiger platform code to map one to the other.
    enum CompositeOperator {
        CompositeClear,
        CompositeCopy,
        CompositeSourceOver,
        CompositeSourceIn,
        CompositeSourceOut,
        CompositeSourceAtop,
        CompositeDestinationOver,
        CompositeDestinationIn,
        CompositeDestinationOut,
        CompositeDestinationAtop,
        CompositeXOR,
        CompositePlusDarker,
        CompositeHighlight,
        CompositePlusLighter
    };

    // FIXME: Currently these constants have to match the values used in the SVG
    // DOM API. That's a mistake. We need to make cut that dependency.
    enum GradientSpreadMethod {
        SpreadMethodPad = 1,
        SpreadMethodReflect = 2,
        SpreadMethodRepeat = 3
    };

    enum LineCap { ButtCap, RoundCap, SquareCap };

    enum LineJoin { MiterJoin, RoundJoin, BevelJoin };

    enum HorizontalAlignment { AlignLeft, AlignRight, AlignHCenter };

    enum TextBaseline { AlphabeticTextBaseline, TopTextBaseline, MiddleTextBaseline, BottomTextBaseline, IdeographicTextBaseline, HangingTextBaseline };

    enum TextAlign { StartTextAlign, EndTextAlign, LeftTextAlign, CenterTextAlign, RightTextAlign };

    String compositeOperatorName(CompositeOperator);
    bool parseCompositeOperator(const String&, CompositeOperator&);

    String lineCapName(LineCap);
    bool parseLineCap(const String&, LineCap&);

    String lineJoinName(LineJoin);
    bool parseLineJoin(const String&, LineJoin&);

    String textAlignName(TextAlign);
    bool parseTextAlign(const String&, TextAlign&);

    String textBaselineName(TextBaseline);
    bool parseTextBaseline(const String&, TextBaseline&);

///////////////////

class FloatRect;
class GraphicsContext;
class IntSize;

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/Generator.h

class Generator /*: public RefCounted<Generator>*/ {
public:
    virtual ~Generator() {};

    virtual void fill(GraphicsContext*, const FloatRect&) = 0;
    virtual void adjustParametersForTiledDrawing(IntSize& /* size */, FloatRect& /* srcRect */) { }
};
</file>

<file path="qlith/container_qt5_wrapper.h">
// this_file: qlith-pro/include/qlith/container_qt5_wrapper.h
#pragma once

#include <QtCore/QtGlobal>
#include <QtCore/QObject>
#include <QtCore/QString>
#include <QtCore/QPoint>
#include <QtGui/QPainter>
#include <QtWidgets/QWidget>

#include "container_qt5.h"
</file>

<file path="qlith/container_qt5.h">
// this_file: qlith-pro/include/qlith/container_qt5.h
#pragma once

#include <litehtml.h>
#include <litehtml/document.h>
#include <litehtml/document_container.h>
#include <QObject>
#include <QWidget>
#include <QHash>
#include <QImage>
#include <QFont>
#include <QPainter>
#include <QPoint>
#include <QMap>
#include <QFontMetrics>
#include <functional>

// Forward declarations
class litehtmlWidget;

/**
 * Implementation of the litehtml document_container for Qt5
 */
class container_qt5 : public QObject, public litehtml::document_container
{
  Q_OBJECT

signals:
  void docSizeChanged(int w, int h);
  void documentSizeChanged(int w, int h);
  void titleChanged(const QString& title);
  void anchorClicked(const QString& url);
  void cursorChanged(const QString& cursor);

public:
    std::shared_ptr<litehtml::document> _doc;

    // Set a custom color resolver function for testing
    using ColorResolverFunc = std::function<std::string(const std::string&)>;
    void setCustomColorResolver(ColorResolverFunc resolver) {
        m_customColorResolver = resolver;
    }

private:
    QHash<QString, QByteArray> m_loaded_css;
    QHash<QString, QImage> m_images;
    int lastCursorX = 0;
    int lastCursorY = 0;
    int lastCursorClientX = 0;
    int lastCursorClientY = 0;
    int offsetX = 0;
    int offsetY = 0;
    QPoint m_Scroll{0,0};
    int m_lastDocWidth = 0, m_lastDocHeight = 0;
    QString m_defaultFontName; // Default font name (e.g., "Arial")
    int m_defaultFontSize;     // Default font size in pixels
    QString m_baseUrl;         // Base URL for resolving relative paths
    QWidget* m_owner;
    QPainter* m_painter = nullptr;

    // Font storage
    struct font_metrics_t {
        QFont font;
        QFontMetrics metrics;

        font_metrics_t() : metrics(font) {}
        explicit font_metrics_t(const QFont& f) : font(f), metrics(f) {}
    };

    QMap<int, font_metrics_t> m_fonts;
    int m_nextFontId = 1;

    // Custom color resolver for testing
    ColorResolverFunc m_customColorResolver;

  public:
    /**
     * Default constructor
     */
    explicit container_qt5(QWidget *parent = nullptr);

    /**
     * Destructor
     */
    ~container_qt5();

    void setLastMouseCoords(int x, int y, int xClient, int yClient);

    std::shared_ptr<litehtml::document> getDocument()
    {
      return _doc;
    }

  void set_document(std::shared_ptr<litehtml::document> doc);

  // Additional methods for mouse interaction
  void on_lbutton_down(std::shared_ptr<litehtml::document>& doc, int x, int y, int client_x);
  void on_lbutton_up(std::shared_ptr<litehtml::document>& doc, int x, int y, int client_x);
  void on_mouse_over(std::shared_ptr<litehtml::document>& doc, int x, int y, int client_x);

  // Drawing method
  void draw(std::shared_ptr<litehtml::document>& doc, QPainter* painter, int x, int y, const litehtml::position* clip);

  // litehtml::document_container implementation
  litehtml::uint_ptr create_font(const litehtml::font_description& descr, const litehtml::document* doc, litehtml::font_metrics* fm) override;
  void delete_font(litehtml::uint_ptr hFont) override;
  int text_width(const char* text, litehtml::uint_ptr hFont) override;
  void draw_text(litehtml::uint_ptr hdc, const char* text, litehtml::uint_ptr hFont, litehtml::web_color color, const litehtml::position& pos) override;
  int pt_to_px(int pt) const override;
  int get_default_font_size() const override;
  const char* get_default_font_name() const override;
  void draw_list_marker(litehtml::uint_ptr hdc, const litehtml::list_marker& marker) override;
  void load_image(const char* src, const char* baseurl, bool redraw_on_ready) override;
  void get_image_size(const char* src, const char* baseurl, litehtml::size& sz) override;
  void draw_image(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const std::string& url, const std::string& base_url) override;
  void draw_solid_fill(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::web_color& color) override;
  void draw_linear_gradient(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::background_layer::linear_gradient& gradient) override;
  void draw_radial_gradient(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::background_layer::radial_gradient& gradient) override;
  void draw_conic_gradient(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::background_layer::conic_gradient& gradient) override;
  void draw_borders(litehtml::uint_ptr hdc, const litehtml::borders& borders, const litehtml::position& draw_pos, bool root) override;
  void set_caption(const char* caption) override;
  void set_base_url(const char* base_url) override;
  void link(const std::shared_ptr<litehtml::document>& doc, const litehtml::element::ptr& el) override;
  void on_anchor_click(const char* url, const litehtml::element::ptr& el) override;
  void on_mouse_event(const litehtml::element::ptr& el, litehtml::mouse_event event) override;
  void set_cursor(const char* cursor) override;
  void transform_text(litehtml::string& text, litehtml::text_transform tt) override;
  void import_css(litehtml::string& text, const litehtml::string& url, litehtml::string& baseurl) override;
  void set_clip(const litehtml::position& pos, const litehtml::border_radiuses& bdr_radius) override;
  void del_clip() override;
  void get_viewport(litehtml::position& viewport) const override;
  void get_media_features(litehtml::media_features& media) const override;
  void get_language(litehtml::string& language, litehtml::string& culture) const override;
  litehtml::element::ptr create_element(const char* tag_name,
                                       const litehtml::string_map& attributes,
                                       const std::shared_ptr<litehtml::document>& doc) override;
  litehtml::string resolve_color(const litehtml::string& color) const override;

  // Helper methods
  void repaint(QPainter& painter);
  QPoint getScroll() const;
  void setScroll(const QPoint &val);
  void setScrollX(const int &val);
  void setScrollY(const int &val);
  void setPainter(QPainter* painter);
  void onImageLoaded(const QString& url, const QImage& image);

  // Convert litehtml web_color to QColor
  static QColor webColorToQColor(const litehtml::web_color &color)
  {
    return QColor(color.red, color.green, color.blue, color.alpha);
  }
};

Q_DECLARE_METATYPE(container_qt5*)
</file>

<file path="qlith/context.h">
#pragma once

#include <litehtml.h>
#include <string>

/**
 * @brief Wrapper class for litehtml document creation
 */
class litehtml_context
{
public:
    /**
     * @brief Constructor
     */
    litehtml_context() = default;

    /**
     * @brief Load the master stylesheet
     * @param css CSS stylesheet content
     */
    void load_master_stylesheet(const char* css)
    {
        master_css = css;
    }

    /**
     * @brief Get the master CSS
     * @return The master stylesheet content
     */
    const std::string& get_master_css() const
    {
        return master_css;
    }

private:
    std::string master_css;
};
</file>

<file path="qlith/contextshadow.h">
// this_file: qlith-pro/include/qlith/contextshadow.h
#pragma once

#include "qlith/common.h"

#include "qlith/color.h"
#include "qlith/floatrect.h"
//#include "graphicscontext.h"
#include "qlith/intrect.h"
//#include "RefCounted.h"

/*#include "Color.h"
#include "FloatRect.h"
#include "GraphicsContext.h"
#include "IntRect.h"
#include "RefCounted.h"*/

#include <QImage>
class QPainter;
typedef QImage PlatformImage;
typedef QPainter* PlatformContext;

// This is to track and keep the shadow state. We use this rather than
// using GraphicsContextState to allow possible optimizations (right now
// only to determine the shadow type, but in future it might covers things
// like cached scratch image, persistent shader, etc).

// This class should be copyable since GraphicsContextQt keeps a stack of
// the shadow state for savePlatformState and restorePlatformState.

class ContextShadow {
public:
    enum {
        NoShadow,
        SolidShadow,
        BlurShadow
    } m_type;

    Color m_color;
    int m_blurDistance;
    FloatSize m_offset;

    ContextShadow();
    ContextShadow(const Color&, float radius, const FloatSize& offset);

    void clear();

    // The pair beginShadowLayer and endShadowLayer creates a temporary image
    // where the caller can draw onto, using the returned context. This context
    // must be used only to draw between the call to beginShadowLayer and
    // endShadowLayer.
    //
    // Note: multiple/nested shadow layers are NOT allowed.
    //
    // The current clip region will be used to optimize the size of the
    // temporary image. Thus, the original context should not change any
    // clipping until endShadowLayer. If the shadow will be completely outside
    // the clipping region, beginShadowLayer will return 0.
    //
    // The returned context will have the transformation matrix and clipping
    // properly initialized to start doing the painting (no need to account for
    // the shadow offset), however it will not have the same render hints, pen,
    // brush, etc as the passed context. This is intentional, usually shadows
    // have different properties than the shapes which cast them.
    //
    // Once endShadowLayer is called, the temporary image will be drawn with the
    // original context. If blur radius is specified, the shadow will be
    // filtered first.

    PlatformContext beginShadowLayer(PlatformContext, const FloatRect& layerArea);
    void endShadowLayer(PlatformContext);
    static void purgeScratchBuffer();
/*#if PLATFORM(CAIRO)
    void drawRectShadow(GraphicsContext* context, const IntRect& rect, const IntSize& topLeftRadius, const IntSize& topRightRadius, const IntSize& bottomLeftRadius, const IntSize& bottomRightRadius);
#endif*/

//#if PLATFORM(QT)
    QPointF offset() { return QPointF(m_offset.width(), m_offset.height()); }
//#endif


private:
    IntRect m_layerRect;
    PlatformImage m_layerImage;
    PlatformContext m_layerContext;

    void blurLayerImage(unsigned char*, const IntSize& imageSize, int stride);
    void calculateLayerBoundingRect(const FloatRect& layerArea, const IntRect& clipRect);
/*#if PLATFORM(CAIRO)
    void drawRectShadowWithoutTiling(PlatformContext context, const IntRect& shadowRect, const IntSize& topLeftRadius, const IntSize& topRightRadius, const IntSize& bottomLeftRadius, const IntSize& bottomRightRadius, float alpha);
#endif*/
};
</file>

<file path="qlith/floatpoint.h">
// this_file: qlith-pro/include/qlith/floatpoint.h
#pragma once


#include "qlith/common.h"
#include "qlith/intpoint.h"
#include "qlith/floatsize.h"

/*#include "IntPoint.h"
#include <wtf/MathExtras.h>*/

#include "qglobal.h"
QT_BEGIN_NAMESPACE
class QPointF;
QT_END_NAMESPACE

class AffineTransform;
class TransformationMatrix;
//class IntPoint;

class FloatPoint {
public:
    FloatPoint() : m_x(0), m_y(0) { }
    FloatPoint(float x, float y) : m_x(x), m_y(y) { }
    FloatPoint(const IntPoint&);


    static FloatPoint zero() { return FloatPoint(); }

    static FloatPoint narrowPrecision(double x, double y);

    float x() const { return m_x; }
    float y() const { return m_y; }

    void setX(float x) { m_x = x; }
    void setY(float y) { m_y = y; }
    void set(float x, float y)
    {
        m_x = x;
        m_y = y;
    }
    void move(float dx, float dy)
    {
        m_x += dx;
        m_y += dy;
    }
    void scale(float sx, float sy)
    {
        m_x *= sx;
        m_y *= sy;
    }

    void normalize();

    float dot(const FloatPoint& a) const
    {
        return m_x * a.x() + m_y * a.y();
    }

    float length() const;
    float lengthSquared() const
    {
        return m_x * m_x + m_y * m_y;
    }

    FloatPoint(const QPointF&);
    operator QPointF() const;

    FloatPoint matrixTransform(const TransformationMatrix&) const;
    FloatPoint matrixTransform(const AffineTransform&) const;

private:
    float m_x, m_y;
};


inline FloatPoint& operator+=(FloatPoint& a, const FloatSize& b)
{
    a.move(b.width(), b.height());
    return a;
}

inline FloatPoint& operator+=(FloatPoint& a, const FloatPoint& b)
{
    a.move(b.x(), b.y());
    return a;
}

inline FloatPoint& operator-=(FloatPoint& a, const FloatSize& b)
{
    a.move(-b.width(), -b.height());
    return a;
}

inline FloatPoint operator+(const FloatPoint& a, const FloatSize& b)
{
    return FloatPoint(a.x() + b.width(), a.y() + b.height());
}

inline FloatPoint operator+(const FloatPoint& a, const FloatPoint& b)
{
    return FloatPoint(a.x() + b.x(), a.y() + b.y());
}

inline FloatSize operator-(const FloatPoint& a, const FloatPoint& b)
{
    return FloatSize(a.x() - b.x(), a.y() - b.y());
}

inline FloatPoint operator-(const FloatPoint& a, const FloatSize& b)
{
    return FloatPoint(a.x() - b.width(), a.y() - b.height());
}

inline bool operator==(const FloatPoint& a, const FloatPoint& b)
{
    return a.x() == b.x() && a.y() == b.y();
}

inline bool operator!=(const FloatPoint& a, const FloatPoint& b)
{
    return a.x() != b.x() || a.y() != b.y();
}

inline float operator*(const FloatPoint& a, const FloatPoint& b)
{
    // dot product
    return a.dot(b);
}

inline IntPoint roundedIntPoint(const FloatPoint& p)
{
    return IntPoint(static_cast<int>(roundf(p.x())), static_cast<int>(roundf(p.y())));
}
</file>

<file path="qlith/floatpoint3d.h">
// this_file: qlith-pro/include/qlith/floatpoint3d.h
#pragma once

#include "qlith/floatpoint.h"

class FloatPoint3D {
public:
    FloatPoint3D()
        : m_x(0)
        , m_y(0)
        , m_z(0)
    {
    }

    FloatPoint3D(float x, float y, float z)
        : m_x(x)
        , m_y(y)
        , m_z(z)
    {
    }

    FloatPoint3D(const FloatPoint& p)
        : m_x(p.x())
        , m_y(p.y())
        , m_z(0)
    {
    }

    FloatPoint3D(const FloatPoint3D& p)
        : m_x(p.x())
        , m_y(p.y())
        , m_z(p.z())
    {
    }

    float x() const { return m_x; }
    void setX(float x) { m_x = x; }

    float y() const { return m_y; }
    void setY(float y) { m_y = y; }

    float z() const { return m_z; }
    void setZ(float z) { m_z = z; }
    void set(float x, float y, float z)
    {
        m_x = x;
        m_y = y;
        m_z = z;
    }
    void move(float dx, float dy, float dz)
    {
        m_x += dx;
        m_y += dy;
        m_z += dz;
    }
    void scale(float sx, float sy, float sz)
    {
        m_x *= sx;
        m_y *= sy;
        m_z *= sz;
    }

    void normalize();

    float dot(const FloatPoint3D& a) const
    {
        return m_x * a.x() + m_y * a.y() + m_z * a.z();
    }

    // Sets this FloatPoint3D to the cross product of the passed two.
    // It is safe for "this" to be the same as either or both of the
    // arguments.
    void cross(const FloatPoint3D& a, const FloatPoint3D& b)
    {
        float x = a.y() * b.z() - a.z() * b.y();
        float y = a.z() * b.x() - a.x() * b.z();
        float z = a.x() * b.y() - a.y() * b.x();
        m_x = x;
        m_y = y;
        m_z = z;
    }

    // Convenience function returning "this cross point" as a
    // stack-allocated result.
    FloatPoint3D cross(const FloatPoint3D& point) const
    {
        FloatPoint3D result;
        result.cross(*this, point);
        return result;
    }

    float length() const;
    float lengthSquared() const { return this->dot(*this); }

private:
    float m_x;
    float m_y;
    float m_z;
};

inline FloatPoint3D& operator +=(FloatPoint3D& a, const FloatPoint3D& b)
{
    a.move(b.x(), b.y(), b.z());
    return a;
}

inline FloatPoint3D& operator -=(FloatPoint3D& a, const FloatPoint3D& b)
{
    a.move(-b.x(), -b.y(), -b.z());
    return a;
}

inline FloatPoint3D operator+(const FloatPoint3D& a, const FloatPoint3D& b)
{
    return FloatPoint3D(a.x() + b.x(), a.y() + b.y(), a.z() + b.z());
}

inline FloatPoint3D operator-(const FloatPoint3D& a, const FloatPoint3D& b)
{
    return FloatPoint3D(a.x() - b.x(), a.y() - b.y(), a.z() - b.z());
}

inline bool operator==(const FloatPoint3D& a, const FloatPoint3D& b)
{
    return a.x() == b.x() && a.y() == b.y() && a.z() == b.z();
}

inline bool operator!=(const FloatPoint3D& a, const FloatPoint3D& b)
{
    return a.x() != b.x() || a.y() != b.y() || a.z() != b.z();
}

inline float operator*(const FloatPoint3D& a, const FloatPoint3D& b)
{
    // dot product
    return a.dot(b);
}
</file>

<file path="qlith/floatquad.h">
// this_file: qlith-pro/include/qlith/floatquad.h
#pragma once


#include "qlith/floatpoint.h"
#include "qlith/floatrect.h"
#include "qlith/intrect.h"

// A FloatQuad is a collection of 4 points, often representing the result of
// mapping a rectangle through transforms. When initialized from a rect, the
// points are in clockwise order from top left.
class FloatQuad {
public:
    FloatQuad()
    {
    }

    FloatQuad(const FloatPoint& p1, const FloatPoint& p2, const FloatPoint& p3, const FloatPoint& p4)
        : m_p1(p1)
        , m_p2(p2)
        , m_p3(p3)
        , m_p4(p4)
    {
    }

    FloatQuad(const FloatRect& inRect)
        : m_p1(inRect.location())
        , m_p2(inRect.right(), inRect.y())
        , m_p3(inRect.right(), inRect.bottom())
        , m_p4(inRect.x(), inRect.bottom())
    {
    }

    FloatPoint p1() const { return m_p1; }
    FloatPoint p2() const { return m_p2; }
    FloatPoint p3() const { return m_p3; }
    FloatPoint p4() const { return m_p4; }

    void setP1(const FloatPoint& p) { m_p1 = p; }
    void setP2(const FloatPoint& p) { m_p2 = p; }
    void setP3(const FloatPoint& p) { m_p3 = p; }
    void setP4(const FloatPoint& p) { m_p4 = p; }

    // isEmpty tests that the bounding box is empty. This will not identify
    // "slanted" empty quads.
    bool isEmpty() const { return boundingBox().isEmpty(); }

    // Tests whether this quad can be losslessly represented by a FloatRect,
    // that is, if two edges are parallel to the x-axis and the other two
    // are parallel to the y-axis. If this method returns true, the
    // corresponding FloatRect can be retrieved with boundingBox().
    bool isRectilinear() const;

    // Tests whether the given point is inside, or on an edge or corner of this quad.
    bool containsPoint(const FloatPoint&) const;

    // Tests whether the four corners of other are inside, or coincident with the sides of this quad.
    // Note that this only works for convex quads, but that includes all quads that originate
    // from transformed rects.
    bool containsQuad(const FloatQuad&) const;

    FloatRect boundingBox() const;
    IntRect enclosingBoundingBox() const
    {
        return enclosingIntRect(boundingBox());
    }

    void move(const FloatSize& offset)
    {
        m_p1 += offset;
        m_p2 += offset;
        m_p3 += offset;
        m_p4 += offset;
    }

    void move(float dx, float dy)
    {
        m_p1.move(dx, dy);
        m_p2.move(dx, dy);
        m_p3.move(dx, dy);
        m_p4.move(dx, dy);
    }

private:
    FloatPoint m_p1;
    FloatPoint m_p2;
    FloatPoint m_p3;
    FloatPoint m_p4;
};

inline FloatQuad& operator+=(FloatQuad& a, const FloatSize& b)
{
    a.move(b);
    return a;
}

inline FloatQuad& operator-=(FloatQuad& a, const FloatSize& b)
{
    a.move(-b.width(), -b.height());
    return a;
}

inline bool operator==(const FloatQuad& a, const FloatQuad& b)
{
    return a.p1() == b.p1() &&
           a.p2() == b.p2() &&
           a.p3() == b.p3() &&
           a.p4() == b.p4();
}

inline bool operator!=(const FloatQuad& a, const FloatQuad& b)
{
    return a.p1() != b.p1() ||
           a.p2() != b.p2() ||
           a.p3() != b.p3() ||
           a.p4() != b.p4();
}
</file>

<file path="qlith/floatrect.h">
// this_file: qlith-pro/include/qlith/floatrect.h
#pragma once

#include "qlith/floatpoint.h"
#include "qlith/floatsize.h"
#include "qlith/common.h"
#include "qlith/intrect.h"
//#include "vector.h"

QT_BEGIN_NAMESPACE
class QRectF;
QT_END_NAMESPACE

//class IntRect;

class FloatRect {
public:
    FloatRect() { }
    FloatRect(const FloatPoint& location, const FloatSize& size)
        : m_location(location), m_size(size) { }
    FloatRect(float x, float y, float width, float height)
        : m_location(FloatPoint(x, y)), m_size(FloatSize(width, height)) { }
    FloatRect(const IntRect&);

    static FloatRect narrowPrecision(double x, double y, double width, double height);

    FloatPoint location() const { return m_location; }
    FloatSize size() const { return m_size; }

    void setLocation(const FloatPoint& location) { m_location = location; }
    void setSize(const FloatSize& size) { m_size = size; }

    float x() const { return m_location.x(); }
    float y() const { return m_location.y(); }
    float width() const { return m_size.width(); }
    float height() const { return m_size.height(); }

    void setX(float x) { m_location.setX(x); }
    void setY(float y) { m_location.setY(y); }
    void setWidth(float width) { m_size.setWidth(width); }
    void setHeight(float height) { m_size.setHeight(height); }

    bool isEmpty() const { return m_size.isEmpty(); }

    float left() const { return x(); }
    float right() const { return x() + width(); }
    float top() const { return y(); }
    float bottom() const { return y() + height(); }

    FloatPoint center() const { return FloatPoint(x() + width() / 2, y() + height() / 2); }

    void move(const FloatSize& delta) { m_location += delta; }
    void move(float dx, float dy) { m_location.move(dx, dy); }

    bool intersects(const FloatRect&) const;
    bool contains(const FloatRect&) const;

    void intersect(const FloatRect&);
    void unite(const FloatRect&);

    // Note, this doesn't match what IntRect::contains(IntPoint&) does; the int version
    // is really checking for containment of 1x1 rect, but that doesn't make sense with floats.
    bool contains(float px, float py) const
        { return px >= x() && px <= right() && py >= y() && py <= bottom(); }
    bool contains(const FloatPoint& point) const { return contains(point.x(), point.y()); }


    void inflateX(float dx) {
        m_location.setX(m_location.x() - dx);
        m_size.setWidth(m_size.width() + dx + dx);
    }
    void inflateY(float dy) {
        m_location.setY(m_location.y() - dy);
        m_size.setHeight(m_size.height() + dy + dy);
    }
    void inflate(float d) { inflateX(d); inflateY(d); }
    void scale(float s) { scale(s, s); }
    void scale(float sx, float sy);

    // Re-initializes this rectangle to fit the sets of passed points.
    void fitToPoints(const FloatPoint& p0, const FloatPoint& p1);
    void fitToPoints(const FloatPoint& p0, const FloatPoint& p1, const FloatPoint& p2);
    void fitToPoints(const FloatPoint& p0, const FloatPoint& p1, const FloatPoint& p2, const FloatPoint& p3);



    FloatRect(const QRectF&);
    operator QRectF() const;
    FloatRect normalized() const;

private:
    FloatPoint m_location;
    FloatSize m_size;

    void setLocationAndSizeFromEdges(float left, float top, float right, float bottom)
    {
        m_location.set(left, top);
        m_size.setWidth(right - left);
        m_size.setHeight(bottom - top);
    }
};

inline FloatRect intersection(const FloatRect& a, const FloatRect& b)
{
    FloatRect c = a;
    c.intersect(b);
    return c;
}

inline FloatRect unionRect(const FloatRect& a, const FloatRect& b)
{
    FloatRect c = a;
    c.unite(b);
    return c;
}


inline bool operator==(const FloatRect& a, const FloatRect& b)
{
    return a.location() == b.location() && a.size() == b.size();
}

inline bool operator!=(const FloatRect& a, const FloatRect& b)
{
    return a.location() != b.location() || a.size() != b.size();
}

IntRect enclosingIntRect(const FloatRect&);

// Map rect r from srcRect to an equivalent rect in destRect.
FloatRect mapRect(const FloatRect& r, const FloatRect& srcRect, const FloatRect& destRect);
</file>

<file path="qlith/floatsize.h">
// this_file: qlith-pro/include/qlith/floatsize.h
#pragma once

#include "qlith/common.h"

#include "qlith/intsize.h"

//class IntSize;

class FloatSize {
public:
    FloatSize() : m_width(0), m_height(0) { }
    FloatSize(float width, float height) : m_width(width), m_height(height) { }
    FloatSize(const IntSize&);

    static FloatSize narrowPrecision(double width, double height);

    float width() const { return m_width; }
    float height() const { return m_height; }

    void setWidth(float width) { m_width = width; }
    void setHeight(float height) { m_height = height; }

    bool isEmpty() const { return m_width <= 0 || m_height <= 0; }

    float aspectRatio() const { return m_width / m_height; }

    void scale(float scale)
    {
        m_width *= scale;
        m_height *= scale;
    }

    FloatSize expandedTo(const FloatSize& other) const
    {
        return FloatSize(m_width > other.m_width ? m_width : other.m_width,
            m_height > other.m_height ? m_height : other.m_height);
    }

    FloatSize shrunkTo(const FloatSize& other) const
    {
       return FloatSize(m_width < other.m_width ? m_width : other.m_width,
           m_height < other.m_height ? m_height : other.m_height);
    }

    float diagonalLength() const;
    float diagonalLengthSquared() const
    {
        return m_width * m_width + m_height * m_height;
    }

private:
    float m_width, m_height;
};

inline FloatSize& operator+=(FloatSize& a, const FloatSize& b)
{
    a.setWidth(a.width() + b.width());
    a.setHeight(a.height() + b.height());
    return a;
}

inline FloatSize& operator-=(FloatSize& a, const FloatSize& b)
{
    a.setWidth(a.width() - b.width());
    a.setHeight(a.height() - b.height());
    return a;
}

inline FloatSize operator+(const FloatSize& a, const FloatSize& b)
{
    return FloatSize(a.width() + b.width(), a.height() + b.height());
}

inline FloatSize operator-(const FloatSize& a, const FloatSize& b)
{
    return FloatSize(a.width() - b.width(), a.height() - b.height());
}

inline FloatSize operator-(const FloatSize& size)
{
    return FloatSize(-size.width(), -size.height());
}

inline bool operator==(const FloatSize& a, const FloatSize& b)
{
    return a.width() == b.width() && a.height() == b.height();
}

inline bool operator!=(const FloatSize& a, const FloatSize& b)
{
    return a.width() != b.width() || a.height() != b.height();
}

inline IntSize roundedIntSize(const FloatSize& p)
{
    return IntSize(static_cast<int>(roundf(p.width())), static_cast<int>(roundf(p.height())));
}
</file>

<file path="qlith/fontcache.h">
// this_file: qlith-pro/include/qlith/fontcache.h
// -*- coding: utf-8 -*-

#pragma once

#include <QStringList>
#include <QFile>
#include <QHash>
#include <QFont>
#include <QTextStream>
#include <QFontDatabase>
#include <QtDebug>

class FontCache
{
public:
  FontCache();

  ~FontCache();

  static FontCache* getInstance();

  static QString getDefaultFontName();

  QFont* getFont(const QString& name) const;

  QFont* addFont(const QString& path, const QString& name, int pixelSize = 12);

private:
  QHash<QString, QFont*> cache;

  /* Here will be the instance stored. */
  static FontCache* instance;

  static QString defaultFontName;
};
</file>

<file path="qlith/gradient.h">
// this_file: qlith-pro/include/qlith/gradient.h
#pragma once

#include "qlith/common.h"

#include "qlith/affinetransform.h"
#include "qlith/floatpoint.h"
//#include "graphicscontext.h"
#include "qlith/intsize.h"
#include "qlith/floatrect.h"

//#include "Generator.h"
//#include "GraphicsTypes.h"
//#include <wtf/PassRefPtr.h>
//#include <wtf/Vector.h>

QT_BEGIN_NAMESPACE
class QGradient;
QT_END_NAMESPACE
typedef QGradient* PlatformGradient;

    class Color;

    class Gradient : public Generator {
    public:
        static PassRefPtr<Gradient> create(const FloatPoint& p0, const FloatPoint& p1)
        {
            //return adoptRef(new Gradient(p0, p1));
            return adoptRef<Gradient>(p0, p1);
        }
        static PassRefPtr<Gradient> create(const FloatPoint& p0, float r0, const FloatPoint& p1, float r1)
        {
            //return adoptRef(new Gradient(p0, r0, p1, r1));
            return adoptRef<Gradient>(p0, r0, p1, r1);
        }
        virtual ~Gradient();

        struct ColorStop;
        void addColorStop(const ColorStop&);
        void addColorStop(float, const Color&);

        void getColor(float value, float* r, float* g, float* b, float* a) const;

        bool isRadial() const { return m_radial; }
        bool isZeroSize() const { return m_p0.x() == m_p1.x() && m_p0.y() == m_p1.y() && (!m_radial || m_r0 == m_r1); }

        PlatformGradient platformGradient();

        struct ColorStop {
            float stop;
            float red;
            float green;
            float blue;
            float alpha;

            ColorStop() : stop(0), red(0), green(0), blue(0), alpha(0) { }
            ColorStop(float s, float r, float g, float b, float a) : stop(s), red(r), green(g), blue(b), alpha(a) { }
        };

        void setStopsSorted(bool s) { m_stopsSorted = s; }

        void setSpreadMethod(GradientSpreadMethod);
        GradientSpreadMethod spreadMethod() { return m_spreadMethod; }
        void setGradientSpaceTransform(const AffineTransform& gradientSpaceTransformation);
        // Qt and CG transform the gradient at draw time
        AffineTransform gradientSpaceTransform() { return m_gradientSpaceTransformation; }

        virtual void fill(GraphicsContext*, const FloatRect&);
        virtual void adjustParametersForTiledDrawing(IntSize& size, FloatRect& srcRect);

        void setPlatformGradientSpaceTransform(const AffineTransform& gradientSpaceTransformation);

    //private:
    public:
        Gradient(const FloatPoint& p0, const FloatPoint& p1);
        Gradient(const FloatPoint& p0, float r0, const FloatPoint& p1, float r1);
    private:
        void platformInit() { m_gradient = 0; }
        void platformDestroy();

        int findStop(float value) const;
        void sortStopsIfNecessary();

        bool m_radial;
        FloatPoint m_p0;
        FloatPoint m_p1;
        float m_r0;
        float m_r1;

        //mutable Vector<ColorStop, 2> m_stops;
        mutable QVector<ColorStop> m_stops;

        mutable bool m_stopsSorted;
        mutable int m_lastStop;
        GradientSpreadMethod m_spreadMethod;
        AffineTransform m_gradientSpaceTransformation;

        PlatformGradient m_gradient;
    };
</file>

<file path="qlith/graphicscontext.h">
// this_file: qlith-pro/include/qlith/graphicscontext.h
#pragma once

#include <QDebug>
#include <QFont>
#include <QFontMetrics>
#include <QPainter>
#include <QMouseEvent>
#include <QDesktopServices>

#include "qlith/fontcache.h"
#include <cmath>
#include <memory>

#include "qlith/pathqt.h"

#include "qlith/contextshadow.h"

#include "qlith/color.h"

#include "qlith/common.h"

#include "qlith/gradient.h"

#include "qlith/image.h"
#include "qlith/stillimageqt.h"

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/GraphicsContext.h
//class GraphicsContextPrivate;
//class GraphicsContextPlatformPrivate;

    const int cMisspellingLineThickness = 3;
    const int cMisspellingLinePatternWidth = 4;
    const int cMisspellingLinePatternGapWidth = 1;

    // These bits can be ORed together for a total of 8 possible text drawing modes.
    const int cTextInvisible = 0;
    const int cTextFill = 1;
    const int cTextStroke = 2;
    const int cTextClip = 4;

    enum StrokeStyle {
        NoStroke,
        SolidStroke,
        DottedStroke,
        DashedStroke
    };

    enum InterpolationQuality {
        InterpolationDefault,
        InterpolationNone,
        InterpolationLow,
        InterpolationMedium,
        InterpolationHigh
    };

/////////////////////////


class GraphicsContextPlatformPrivate /*: public Noncopyable*/ {
public:
    GraphicsContextPlatformPrivate(QPainter* painter);
    ~GraphicsContextPlatformPrivate();

    inline QPainter* p() const
    {
      return painter;
        /*if (layers.isEmpty())
            return painter;
        return &layers.top()->painter;*/
    }

    bool antiAliasingForRectsAndLines;

    //QStack<TransparencyLayer*> layers;
    // Counting real layers. Required by inTransparencyLayer() calls
    // For example, layers with valid alphaMask are not real layers
    int layerCount;

    // reuse this brush for solid color (to prevent expensive QBrush construction)
    QBrush solidColor;

    InterpolationQuality imageInterpolationQuality;

    // Only used by SVG for now.
    QPainterPath currentPath;

    ContextShadow shadow;
    QStack<ContextShadow> shadowStack;

    bool hasShadow() const
    {
        return shadow.m_type != ContextShadow::NoShadow;
    }

    inline void clearCurrentPath()
    {
        if (!currentPath.elementCount())
            return;
        currentPath = QPainterPath();
    }

    QRectF clipBoundingRect() const
    {
#if QT_VERSION >= QT_VERSION_CHECK(4, 8, 0)
        return p()->clipBoundingRect();
#else
        return p()->clipRegion().boundingRect();
#endif
    }

private:
    QPainter* painter;
};


/////////////////////////



    struct GraphicsContextState {
        GraphicsContextState()
            : textDrawingMode(cTextFill)
            , strokeStyle(SolidStroke)
            , strokeThickness(0)
            , strokeColor(Color::black)
            , strokeColorSpace(DeviceColorSpace)
            , fillRule(RULE_NONZERO)
            , fillColor(Color::black)
            , fillColorSpace(DeviceColorSpace)
            , shouldAntialias(true)
            , paintingDisabled(false)
            , shadowBlur(0)
            , shadowsIgnoreTransforms(false)
        {
        }

        int textDrawingMode;

        StrokeStyle strokeStyle;
        float strokeThickness;
        Color strokeColor;
        ColorSpace strokeColorSpace;
        RefPtr<Gradient> strokeGradient;
        /*RefPtr<Pattern> strokePattern;*/

        WindRule fillRule;
        Color fillColor;
        ColorSpace fillColorSpace;
        RefPtr<Gradient> fillGradient;
        /*RefPtr<Pattern> fillPattern;*/

        bool shouldAntialias;

        bool paintingDisabled;

        FloatSize shadowOffset;
        float shadowBlur;
        Color shadowColor;

        bool shadowsIgnoreTransforms;

        TransformationMatrix pathTransform;

    };

    class GraphicsContextPrivate /*: public Noncopyable*/ {
    public:
        GraphicsContextPrivate()
            : m_updatingControlTints(false)
        {
        }

        GraphicsContextState state;
        QVector<GraphicsContextState> stack;
        bool m_updatingControlTints;

    };


/////////////////////////

class GraphicsContext
{
public:
        GraphicsContext(PlatformGraphicsContext*);
        ~GraphicsContext();

        PlatformGraphicsContext* platformContext() const;

        float strokeThickness() const;
        void setStrokeThickness(float);
        StrokeStyle strokeStyle() const;
        void setStrokeStyle(const StrokeStyle& style);
        Color strokeColor() const;
        ColorSpace strokeColorSpace() const;
        void setStrokeColor(const Color&, ColorSpace);

        /*void setStrokePattern(PassRefPtr<Pattern>);
        Pattern* strokePattern() const;*/

        void setStrokeGradient(PassRefPtr<Gradient>);
        Gradient* strokeGradient() const;

        WindRule fillRule() const;
        void setFillRule(WindRule);
        Color fillColor() const;
        ColorSpace fillColorSpace() const;
        void setFillColor(const Color&, ColorSpace);

        /*void setFillPattern(PassRefPtr<Pattern>);
        Pattern* fillPattern() const;*/

        void setFillGradient(PassRefPtr<Gradient>);
        Gradient* fillGradient() const;

        void setShadowsIgnoreTransforms(bool);

        void setShouldAntialias(bool);
        bool shouldAntialias() const;

        void save();
        void restore();

        // These draw methods will do both stroking and filling.
        // FIXME: ...except drawRect(), which fills properly but always strokes
        // using a 1-pixel stroke inset from the rect borders (of the correct
        // stroke color).
        void drawRect(const IntRect&);
        void drawLine(const IntPoint&, const IntPoint&);
        void drawEllipse(const IntRect&);
        void drawConvexPolygon(size_t numPoints, const FloatPoint*, bool shouldAntialias = false);

        void drawPath();
        void fillPath();
        void strokePath();

        // Arc drawing (used by border-radius in CSS) just supports stroking at the moment.
        void strokeArc(const IntRect&, int startAngle, int angleSpan);

        void fillRect(const FloatRect&);
        void fillRect(const FloatRect&, const Color&, ColorSpace);


        void fillRect(const FloatRect&, Generator&);


        void fillRoundedRect(const IntRect&, const IntSize& topLeft, const IntSize& topRight, const IntSize& bottomLeft, const IntSize& bottomRight, const Color&, ColorSpace);

        void clearRect(const FloatRect&);

        void strokeRect(const FloatRect&);
        void strokeRect(const FloatRect&, float lineWidth);


        void drawImage(Image*, ColorSpace styleColorSpace, const IntPoint&, CompositeOperator = CompositeSourceOver);
        void drawImage(Image*, ColorSpace styleColorSpace, const IntRect&, CompositeOperator = CompositeSourceOver, bool useLowQualityScale = false);
        void drawImage(Image*, ColorSpace styleColorSpace, const IntPoint& destPoint, const IntRect& srcRect, CompositeOperator = CompositeSourceOver);
        void drawImage(Image*, ColorSpace styleColorSpace, const IntRect& destRect, const IntRect& srcRect, CompositeOperator = CompositeSourceOver, bool useLowQualityScale = false);
        void drawImage(Image*, ColorSpace styleColorSpace, const FloatRect& destRect, const FloatRect& srcRect = FloatRect(0, 0, -1, -1),
                       CompositeOperator = CompositeSourceOver, bool useLowQualityScale = false);
        void drawTiledImage(Image*, ColorSpace styleColorSpace, const IntRect& destRect, const IntPoint& srcPoint, const IntSize& tileSize,
                       CompositeOperator = CompositeSourceOver, bool useLowQualityScale = false);
        void drawTiledImage(Image*, ColorSpace styleColorSpace, const IntRect& destRect, const IntRect& srcRect,
                            Image::TileRule hRule = Image::StretchTile, Image::TileRule vRule = Image::StretchTile,
                            CompositeOperator = CompositeSourceOver, bool useLowQualityScale = false);

        /*void drawImageBuffer(ImageBuffer*, ColorSpace styleColorSpace, const IntPoint&, CompositeOperator = CompositeSourceOver);
        void drawImageBuffer(ImageBuffer*, ColorSpace styleColorSpace, const IntRect&, CompositeOperator = CompositeSourceOver, bool useLowQualityScale = false);
        void drawImageBuffer(ImageBuffer*, ColorSpace styleColorSpace, const IntPoint& destPoint, const IntRect& srcRect, CompositeOperator = CompositeSourceOver);
        void drawImageBuffer(ImageBuffer*, ColorSpace styleColorSpace, const IntRect& destRect, const IntRect& srcRect, CompositeOperator = CompositeSourceOver, bool useLowQualityScale = false);
        void drawImageBuffer(ImageBuffer*, ColorSpace styleColorSpace, const FloatRect& destRect, const FloatRect& srcRect = FloatRect(0, 0, -1, -1),
                             CompositeOperator = CompositeSourceOver, bool useLowQualityScale = false);
        */

        void setImageInterpolationQuality(InterpolationQuality);
        InterpolationQuality imageInterpolationQuality() const;

        void clip(const FloatRect&);
        void addRoundedRectClip(const IntRect&, const IntSize& topLeft, const IntSize& topRight, const IntSize& bottomLeft, const IntSize& bottomRight);
        void addInnerRoundedRectClip(const IntRect&, int thickness);
        void clipOut(const IntRect&);
        void clipOutEllipseInRect(const IntRect&);
        void clipOutRoundedRect(const IntRect&, const IntSize& topLeft, const IntSize& topRight, const IntSize& bottomLeft, const IntSize& bottomRight);
        void clipPath(WindRule);
        void clipConvexPolygon(size_t numPoints, const FloatPoint*, bool antialias = true);
        /*void clipToImageBuffer(ImageBuffer*, const FloatRect&);

        int textDrawingMode();
        void setTextDrawingMode(int);
        */

        /*void drawText(const Font&, const TextRun&, const IntPoint&, int from = 0, int to = -1);
        void drawBidiText(const Font&, const TextRun&, const FloatPoint&);
        void drawHighlightForText(const Font&, const TextRun&, const IntPoint&, int h, const Color& backgroundColor, ColorSpace, int from = 0, int to = -1);
        */

        FloatRect roundToDevicePixels(const FloatRect&);

        /*void drawLineForText(const IntPoint&, int width, bool printing);
        enum TextCheckingLineStyle {
            TextCheckingSpellingLineStyle,
            TextCheckingGrammarLineStyle,
            TextCheckingReplacementLineStyle
        };
        void drawLineForTextChecking(const IntPoint&, int width, TextCheckingLineStyle);*/

        bool paintingDisabled() const;
        void setPaintingDisabled(bool);

        bool updatingControlTints() const;
        void setUpdatingControlTints(bool);

        /*void beginTransparencyLayer(float opacity);
        void endTransparencyLayer();*/

        void setShadow(const FloatSize&, float blur, const Color&, ColorSpace);
        bool getShadow(FloatSize&, float&, Color&) const;
        void clearShadow();

        void drawFocusRing(const QVector<IntRect>&, int width, int offset, const Color&);
        void drawFocusRing(const QVector<Path>&, int width, int offset, const Color&);

        void setLineCap(LineCap);
        void setLineDash(const DashArray&, float dashOffset);
        void setLineJoin(LineJoin);

        void setMiterLimit(float);

        void setAlpha(float);

        void setCompositeOperation(CompositeOperator);

        void beginPath();
        void addPath(const Path&);

        void clip(const Path&);

        // This clip function is used only by <canvas> code. It allows
        // implementations to handle clipping on the canvas differently since
        // the disipline is different.
        void canvasClip(const Path&);
        void clipOut(const Path&);

        void scale(const FloatSize&);
        void rotate(float angleInRadians);
        void translate(const FloatSize& size) { translate(size.width(), size.height()); }
        void translate(float x, float y);
        IntPoint origin();

        /*void setURLForRect(const KURL&, const IntRect&);*/

        void concatCTM(const AffineTransform&);
        AffineTransform getCTM() const;

        //bool inTransparencyLayer() const;
        PlatformPath* currentPath();
        //void pushTransparencyLayerInternal(const QRect &rect, qreal opacity, QPixmap& alphaMask);
        QPen pen();

        static QPainter::CompositionMode toQtCompositionMode(CompositeOperator op);

        ContextShadow* contextShadow();

        /*void setSharedGraphicsContext3D(SharedGraphicsContext3D*, DrawingBuffer*, const IntSize&);
        */

        void syncSoftwareCanvas();
        void markDirtyRect(const IntRect&); // Hints that a portion of the backing store is dirty.

    private:
        void savePlatformState();
        void restorePlatformState();

        void setPlatformTextDrawingMode(int);
        //void setPlatformFont(const Font& font);

        void setPlatformStrokeColor(const Color&, ColorSpace);
        void setPlatformStrokeStyle(const StrokeStyle&);
        void setPlatformStrokeThickness(float);
        void setPlatformStrokeGradient(Gradient*);
        /*void setPlatformStrokePattern(Pattern*);*/

        void setPlatformFillColor(const Color&, ColorSpace);
        void setPlatformFillGradient(Gradient*);
        /*void setPlatformFillPattern(Pattern*);*/

        void setPlatformShouldAntialias(bool b);

        void setPlatformShadow(const FloatSize&, float blur, const Color&, ColorSpace);

        void clearPlatformShadow();

        static void adjustLineToPixelBoundaries(FloatPoint& p1, FloatPoint& p2, float strokeWidth, const StrokeStyle&);

        static GraphicsContextPrivate* createGraphicsContextPrivate();
        static void destroyGraphicsContextPrivate(GraphicsContextPrivate*);

        GraphicsContextPrivate* m_common;
        GraphicsContextPlatformPrivate* m_data; // Deprecated; m_commmon can just be downcasted. To be removed.
    };
</file>

<file path="qlith/image.h">
// this_file: qlith-pro/include/qlith/image.h
#pragma once

#include "qlith/color.h"
#include "qlith/common.h"
//#include "ImageSource.h"
#include "qlith/intrect.h"
//#include "PlatformString.h"
#include "qlith/imagesource.h"

/*#include "Color.h"
#include "ColorSpace.h"
#include "GraphicsTypes.h"
#include "ImageSource.h"
#include "IntRect.h"
#include "PlatformString.h"
#include <wtf/PassRefPtr.h>
#include <wtf/RefCounted.h>
#include <wtf/RefPtr.h>*/

#include <QPixmap>

class FloatPoint;
class FloatRect;
class FloatSize;
class GraphicsContext;
class SharedBuffer;
class AffineTransform;

// This class gets notified when an image creates or destroys decoded frames and when it advances animation frames.
class ImageObserver;

class Image /*: public RefCounted<Image>*/ {
    friend class GeneratedImage;
    friend class GraphicsContext;

public:
    virtual ~Image();

    static PassRefPtr<Image> create(ImageObserver* = 0);
    //static PassRefPtr<Image> loadPlatformResource(const char* name);
    static bool supportsType(const String&);

    virtual bool isBitmapImage() const { return false; }

    // Derived classes should override this if they can assure that
    // the image contains only resources from its own security origin.
    virtual bool hasSingleSecurityOrigin() const { return false; }

    static Image* nullImage();
    bool isNull() const { return size().isEmpty(); }

    // These are only used for SVGImage right now
    virtual void setContainerSize(const IntSize&) { }
    virtual bool usesContainerSize() const { return false; }
    virtual bool hasRelativeWidth() const { return false; }
    virtual bool hasRelativeHeight() const { return false; }

    virtual IntSize size() const = 0;
    IntRect rect() const { return IntRect(IntPoint(), size()); }
    int width() const { return size().width(); }
    int height() const { return size().height(); }
    virtual bool getHotSpot(IntPoint&) const { return false; }

    bool setData(PassRefPtr<SharedBuffer> data, bool allDataReceived);
    virtual bool dataChanged(bool /*allDataReceived*/) { return false; }

    virtual String filenameExtension() const { return String(); } // null string if unknown

    virtual void destroyDecodedData(bool destroyAll = true) = 0;
    virtual unsigned decodedSize() const = 0;

    SharedBuffer* data() { return m_data.get(); }

    // Animation begins whenever someone draws the image, so startAnimation() is not normally called.
    // It will automatically pause once all observers no longer want to render the image anywhere.
    virtual void startAnimation(bool /*catchUpIfNecessary*/ = true) { }
    virtual void stopAnimation() {}
    virtual void resetAnimation() {}

    // Typically the CachedImage that owns us.
    ImageObserver* imageObserver() const { return m_imageObserver; }

    enum TileRule { StretchTile, RoundTile, RepeatTile };

    virtual NativeImagePtr nativeImageForCurrentFrame() { return 0; }

    virtual void drawPattern(GraphicsContext*, const FloatRect& srcRect, const AffineTransform& patternTransform,
                             const FloatPoint& phase, ColorSpace styleColorSpace, CompositeOperator, const FloatRect& destRect);

protected:
    Image(ImageObserver* = 0);

    static void fillWithSolidColor(GraphicsContext*, const FloatRect& dstRect, const Color&, ColorSpace styleColorSpace, CompositeOperator);

    // The ColorSpace parameter will only be used for untagged images.

    virtual void draw(GraphicsContext*, const FloatRect& dstRect, const FloatRect& srcRect, ColorSpace styleColorSpace, CompositeOperator) = 0;
    void drawTiled(GraphicsContext*, const FloatRect& dstRect, const FloatPoint& srcPoint, const FloatSize& tileSize, ColorSpace styleColorSpace, CompositeOperator);
    void drawTiled(GraphicsContext*, const FloatRect& dstRect, const FloatRect& srcRect, TileRule hRule, TileRule vRule, ColorSpace styleColorSpace, CompositeOperator);

    // Supporting tiled drawing
    virtual bool mayFillWithSolidColor() { return false; }
    virtual Color solidColor() const { return Color(); }

private:
    RefPtr<SharedBuffer> m_data; // The encoded raw data for the image.
    ImageObserver* m_imageObserver;
};
</file>

<file path="qlith/imagedecoder.h">
// this_file: qlith-pro/include/qlith/imagedecoder.h
#pragma once

#include "qlith/common.h"

#include "qlith/intrect.h"
#include "qlith/imagesource.h"
//#include "PlatformString.h"
#include "qlith/sharedbuffer.h"
//#include <wtf/Assertions.h>
//#include <wtf/RefPtr.h>
//#include <wtf/Vector.h>

/*#include "IntRect.h"
#include "ImageSource.h"
#include "PlatformString.h"
#include "SharedBuffer.h"
#include <wtf/Assertions.h>
#include <wtf/RefPtr.h>
#include <wtf/Vector.h>*/

#include <QPixmap>
#include <QImage>

    // The RGBA32Buffer object represents the decoded image data in RGBA32
    // format.  This buffer is what all decoders write a single frame into.
    // Frames are then instantiated for drawing by being handed this buffer.
    class RGBA32Buffer {
    public:
        enum FrameStatus { FrameEmpty, FramePartial, FrameComplete };
        enum FrameDisposalMethod {
            // If you change the numeric values of these, make sure you audit
            // all users, as some users may cast raw values to/from these
            // constants.
            DisposeNotSpecified,      // Leave frame in framebuffer
            DisposeKeep,              // Leave frame in framebuffer
            DisposeOverwriteBgcolor,  // Clear frame to transparent
            DisposeOverwritePrevious, // Clear frame to previous framebuffer
                                      // contents
        };

        typedef uint32_t PixelData;

        RGBA32Buffer();

        RGBA32Buffer(const RGBA32Buffer& other) { operator=(other); }

        // For backends which refcount their data, this operator doesn't need to
        // create a new copy of the image data, only increase the ref count.
        RGBA32Buffer& operator=(const RGBA32Buffer& other);

        // Deletes the pixel data entirely; used by ImageDecoder to save memory
        // when we no longer need to display a frame and only need its metadata.
        void clear();

        // Zeroes the pixel data in the buffer, setting it to fully-transparent.
        void zeroFill();

        // Creates a new copy of the image data in |other|, so the two images
        // can be modified independently.  Returns whether the copy succeeded.
        bool copyBitmapData(const RGBA32Buffer& other);

        // Copies the pixel data at [(startX, startY), (endX, startY)) to the
        // same X-coordinates on each subsequent row up to but not including
        // endY.
        void copyRowNTimes(int startX, int endX, int startY, int endY)
        {
            ASSERT(startX < width());
            ASSERT(endX <= width());
            ASSERT(startY < height());
            ASSERT(endY <= height());
            const int rowBytes = (endX - startX) * sizeof(PixelData);
            const PixelData* const startAddr = getAddr(startX, startY);
            for (int destY = startY + 1; destY < endY; ++destY)
                memcpy(getAddr(startX, destY), startAddr, rowBytes);
        }

        // Allocates space for the pixel data.  Must be called before any pixels
        // are written. Will return true on success, false if the memory
        // allocation fails.  Calling this multiple times is undefined and may
        // leak memory.
        bool setSize(int newWidth, int newHeight);

        // To be used by ImageSource::createFrameAtIndex().  Returns a pointer
        // to the underlying native image data.  This pointer will be owned by
        // the BitmapImage and freed in FrameData::clear().
        NativeImagePtr asNewNativeImage() const;

        bool hasAlpha() const;
        const IntRect& rect() const { return m_rect; }
        FrameStatus status() const { return m_status; }
        unsigned duration() const { return m_duration; }
        FrameDisposalMethod disposalMethod() const { return m_disposalMethod; }
        bool premultiplyAlpha() const { return m_premultiplyAlpha; }

        void setHasAlpha(bool alpha);
        void setRect(const IntRect& r) { m_rect = r; }
        void setStatus(FrameStatus status);
        void setDuration(unsigned duration) { m_duration = duration; }
        void setDisposalMethod(FrameDisposalMethod method) { m_disposalMethod = method; }
        void setPremultiplyAlpha(bool premultiplyAlpha) { m_premultiplyAlpha = premultiplyAlpha; }

        inline void setRGBA(int x, int y, unsigned r, unsigned g, unsigned b, unsigned a)
        {
            setRGBA(getAddr(x, y), r, g, b, a);
        }

        void setPixmap(const QPixmap& pixmap);

    private:
        int width() const;
        int height() const;

        inline PixelData* getAddr(int x, int y)
        {

            m_image = m_pixmap.toImage();
            m_pixmap = QPixmap();
            return reinterpret_cast_ptr<QRgb*>(m_image.scanLine(y)) + x;

        }

        inline void setRGBA(PixelData* dest, unsigned r, unsigned g, unsigned b, unsigned a)
        {
            if (m_premultiplyAlpha && !a)
                *dest = 0;
            else {
                if (m_premultiplyAlpha && a < 255) {
                    float alphaPercent = a / 255.0f;
                    r = static_cast<unsigned>(r * alphaPercent);
                    g = static_cast<unsigned>(g * alphaPercent);
                    b = static_cast<unsigned>(b * alphaPercent);
                }
                *dest = (a << 24 | r << 16 | g << 8 | b);
            }
        }

/*#if PLATFORM(SKIA)
        NativeImageSkia m_bitmap;
#elif PLATFORM(QT)*/
        mutable QPixmap m_pixmap;
        mutable QImage m_image;
        bool m_hasAlpha;
        IntSize m_size;
/*#else
        Vector<PixelData> m_bytes;
        IntSize m_size;       // The size of the buffer.  This should be the
                              // same as ImageDecoder::m_size.
        bool m_hasAlpha;      // Whether or not any of the pixels in the buffer
                              // have transparency.
#endif*/

        IntRect m_rect;       // The rect of the original specified frame within
                              // the overall buffer.  This will always just be
                              // the entire buffer except for GIF frames whose
                              // original rect was smaller than the overall
                              // image size.
        FrameStatus m_status; // Whether or not this frame is completely
                              // finished decoding.
        unsigned m_duration;  // The animation delay.
        FrameDisposalMethod m_disposalMethod;
                              // What to do with this frame's data when
                              // initializing the next frame.
        bool m_premultiplyAlpha;
                              // Whether to premultiply alpha into R, G, B
                              // channels; by default it's true.
    };

    // The ImageDecoder class represents a base class for specific image format
    // decoders (e.g., GIF, JPG, PNG, ICO) to derive from.  All decoders decode
    // into RGBA32 format and the base class manages the RGBA32 frame cache.
    //
    // ENABLE(IMAGE_DECODER_DOWN_SAMPLING) allows image decoders to write
    // directly to scaled output buffers by down sampling. Call
    // setMaxNumPixels() to specify the biggest size that decoded images can
    // have. Image decoders will deflate those images that are bigger than
    // m_maxNumPixels. (Not supported by all image decoders yet)
    class ImageDecoder /*: public Noncopyable*/ {
    public:
        ImageDecoder(bool premultiplyAlpha)
            : m_scaled(false)
            , m_premultiplyAlpha(premultiplyAlpha)
            , m_sizeAvailable(false)
            , m_maxNumPixels(-1)
            , m_isAllDataReceived(false)
            , m_failed(false)
        {
        }

        virtual ~ImageDecoder() {}

        // Factory function to create an ImageDecoder.  Ports that subclass
        // ImageDecoder can provide their own implementation of this to avoid
        // needing to write a dedicated setData() implementation.
        static ImageDecoder* create(const SharedBuffer& data, bool premultiplyAlpha);

        // The the filename extension usually associated with an undecoded image
        // of this type.
        virtual String filenameExtension() const = 0;

        bool isAllDataReceived() const { return m_isAllDataReceived; }

        virtual void setData(SharedBuffer* data, bool allDataReceived)
        {
            if (m_failed)
                return;

            //m_data = data;
            m_data->create(data->data(),data->size());

            m_isAllDataReceived = allDataReceived;
        }

        // Whether or not the size information has been decoded yet. This
        // default implementation just returns true if the size has been set and
        // we have not seen a failure. Decoders may want to override this to
        // lazily decode enough of the image to get the size.
        virtual bool isSizeAvailable()
        {
            return !m_failed && m_sizeAvailable;
        }

        // Returns the size of the image.
        virtual IntSize size() const
        {
            return m_size;
        }

        IntSize scaledSize() const
        {
            return m_scaled ? IntSize(m_scaledColumns.size(), m_scaledRows.size()) : size();
        }

        // Returns the size of frame |index|.  This will only differ from size()
        // for formats where different frames are different sizes (namely ICO,
        // where each frame represents a different icon within the master file).
        // Notably, this does not return different sizes for different GIF
        // frames, since while these may be stored as smaller rectangles, during
        // decoding they are composited to create a full-size frame.
        virtual IntSize frameSizeAtIndex(size_t) const
        {
            return size();
        }

        // Called by the image decoders to set their decoded size, this also
        // checks the size for validity. It will return true if the size was
        // set, or false if there is an error. On error, the m_failed flag will
        // be set and the caller should immediately stop decoding.
        virtual bool setSize(unsigned width, unsigned height)
        {
            if (isOverSize(width, height))
                return setFailed();
            m_size = IntSize(width, height);
            m_sizeAvailable = true;
            return true;
        }

        // The total number of frames for the image.  Classes that support
        // multiple frames will scan the image data for the answer if they need
        // to (without necessarily decoding all of the individual frames).
        virtual size_t frameCount() { return 1; }

        // The number of repetitions to perform for an animation loop.
        virtual int repetitionCount() const { return cAnimationNone; }

        // Called to obtain the RGBA32Buffer full of decoded data for rendering.
        // The decoder plugin will decode as much of the frame as it can before
        // handing back the buffer.
        virtual RGBA32Buffer* frameBufferAtIndex(size_t) = 0;

        // Whether or not the underlying image format even supports alpha
        // transparency.
        virtual bool supportsAlpha() const { return true; }

        // Sets the "decode failure" flag.  For caller convenience (since so
        // many callers want to return false after calling this), returns false
        // to enable easy tailcalling.  Subclasses may override this to also
        // clean up any local data.
        virtual bool setFailed()
        {
            m_failed = true;
            return false;
        }

        bool failed() const { return m_failed; }

        // Wipe out frames in the frame buffer cache before |clearBeforeFrame|,
        // assuming this can be done without breaking decoding.  Different
        // decoders place different restrictions on what frames are safe to
        // destroy, so this is left to them to implement.
        // For convenience's sake, we provide a default (empty) implementation,
        // since in practice only GIFs will ever use this.
        virtual void clearFrameBufferCache(size_t clearBeforeFrame) { }

/*#if ENABLE(IMAGE_DECODER_DOWN_SAMPLING)
        void setMaxNumPixels(int m) { m_maxNumPixels = m; }
#endif*/

    protected:
        void prepareScaleDataIfNecessary();
        int upperBoundScaledX(int origX, int searchStart = 0);
        int lowerBoundScaledX(int origX, int searchStart = 0);
        int upperBoundScaledY(int origY, int searchStart = 0);
        int lowerBoundScaledY(int origY, int searchStart = 0);
        int scaledY(int origY, int searchStart = 0);

        RefPtr<SharedBuffer> m_data; // The encoded data.
        QVector<RGBA32Buffer> m_frameBufferCache;
        bool m_scaled;
        QVector<int> m_scaledColumns;
        QVector<int> m_scaledRows;
        bool m_premultiplyAlpha;

    private:
        // Some code paths compute the size of the image as "width * height * 4"
        // and return it as a (signed) int.  Avoid overflow.
        static bool isOverSize(unsigned width, unsigned height)
        {
            // width * height must not exceed (2 ^ 29) - 1, so that we don't
            // overflow when we multiply by 4.
            unsigned long long total_size = static_cast<unsigned long long>(width)
                                          * static_cast<unsigned long long>(height);
            return total_size > ((1 << 29) - 1);
        }

        IntSize m_size;
        bool m_sizeAvailable;
        int m_maxNumPixels;
        bool m_isAllDataReceived;
        bool m_failed;
    };
</file>

<file path="qlith/imagedecoderqt.h">
#pragma once

#include "qlith/common.h"

#include "qlith/imagedecoder.h"
#include <QtGui/QImageReader>
#include <QtGui/QPixmap>
#include <QtCore/QList>
#include <QtCore/QHash>
#include <QtCore/QBuffer>
//#include <wtf/OwnPtr.h>

class ImageDecoderQt : public ImageDecoder
{
public:
    ImageDecoderQt(bool premultiplyAlpha);
    ~ImageDecoderQt();

    virtual void setData(SharedBuffer* data, bool allDataReceived);
    virtual bool isSizeAvailable();
    virtual size_t frameCount();
    virtual int repetitionCount() const;
    virtual RGBA32Buffer* frameBufferAtIndex(size_t index);

    virtual String filenameExtension() const;

    virtual void clearFrameBufferCache(size_t clearBeforeFrame);

private:
    ImageDecoderQt(const ImageDecoderQt&);
    ImageDecoderQt &operator=(const ImageDecoderQt&);

private:
    void internalDecodeSize();
    void internalReadImage(size_t);
    bool internalHandleCurrentImage(size_t);
    void forceLoadEverything();
    void clearPointers();

private:
    QByteArray m_format;
    OwnPtr<QBuffer> m_buffer;
    OwnPtr<QImageReader> m_reader;
    mutable int m_repetitionCount;
};
</file>

<file path="qlith/imageobserver.h">
// this_file: qlith-pro/include/qlith/imageobserver.h
#pragma once

class Image;
class IntRect;

// Interface for notification about changes to an image, including decoding,
// drawing, and animating.
class ImageObserver {
protected:
    virtual ~ImageObserver() {}
public:
    virtual void decodedSizeChanged(const Image*, int delta) = 0;
    virtual void didDraw(const Image*) = 0;

    virtual bool shouldPauseAnimation(const Image*) = 0;
    virtual void animationAdvanced(const Image*) = 0;

    virtual void changedInRect(const Image*, const IntRect&) = 0;
};
</file>

<file path="qlith/imagesource.h">
// this_file: qlith-pro/include/qlith/imagesource.h
#pragma once

#include "qlith/common.h"

//#include <wtf/Forward.h>
//#include <wtf/Noncopyable.h>
//#include <wtf/Vector.h>


#include <qglobal.h>
QT_BEGIN_NAMESPACE
class QPixmap;
QT_END_NAMESPACE

class IntPoint;
class IntSize;
class SharedBuffer;

class ImageDecoderQt;
typedef ImageDecoderQt* NativeImageSourcePtr;
typedef QPixmap* NativeImagePtr;

// Right now GIFs are the only recognized image format that supports animation.
// The animation system and the constants below are designed with this in mind.
// GIFs have an optional 16-bit unsigned loop count that describes how an
// animated GIF should be cycled.  If the loop count is absent, the animation
// cycles once; if it is 0, the animation cycles infinitely; otherwise the
// animation plays n + 1 cycles (where n is the specified loop count).  If the
// GIF decoder defaults to cAnimationLoopOnce in the absence of any loop count
// and translates an explicit "0" loop count to cAnimationLoopInfinite, then we
// get a couple of nice side effects:
//   * By making cAnimationLoopOnce be 0, we allow the animation cycling code in
//     BitmapImage.cpp to avoid special-casing it, and simply treat all
//     non-negative loop counts identically.
//   * By making the other two constants negative, we avoid conflicts with any
//     real loop count values.
const int cAnimationLoopOnce = 0;
const int cAnimationLoopInfinite = -1;
const int cAnimationNone = -2;

class ImageSource /*: public Noncopyable*/ {
public:
    ImageSource(bool premultiplyAlpha = true);
    ~ImageSource();

    // Tells the ImageSource that the Image no longer cares about decoded frame
    // data -- at all (if |destroyAll| is true), or before frame
    // |clearBeforeFrame| (if |destroyAll| is false).  The ImageSource should
    // delete cached decoded data for these frames where possible to keep memory
    // usage low.  When |destroyAll| is true, the ImageSource should also reset
    // any local state so that decoding can begin again.
    //
    // Implementations that delete less than what's specified above waste
    // memory.  Implementations that delete more may burn CPU re-decoding frames
    // that could otherwise have been cached, or encounter errors if they're
    // asked to decode frames they can't decode due to the loss of previous
    // decoded frames.
    //
    // Callers should not call clear(false, n) and subsequently call
    // createFrameAtIndex(m) with m < n, unless they first call clear(true).
    // This ensures that stateful ImageSources/decoders will work properly.
    //
    // The |data| and |allDataReceived| parameters should be supplied by callers
    // who set |destroyAll| to true if they wish to be able to continue using
    // the ImageSource.  This way implementations which choose to destroy their
    // decoders in some cases can reconstruct them correctly.
    void clear(bool destroyAll,
               size_t clearBeforeFrame = 0,
               SharedBuffer* data = nullptr,
               bool allDataReceived = false);

    bool initialized() const;

    void setData(SharedBuffer* data, bool allDataReceived);
    String filenameExtension() const;

    bool isSizeAvailable();
    IntSize size() const;
    IntSize frameSizeAtIndex(size_t) const;
    bool getHotSpot(IntPoint&) const;

    int repetitionCount();

    size_t frameCount() const;

    // Callers should not call this after calling clear() with a higher index;
    // see comments on clear() above.
    NativeImagePtr createFrameAtIndex(size_t);

    float frameDurationAtIndex(size_t);
    bool frameHasAlphaAtIndex(size_t); // Whether or not the frame actually used any alpha.
    bool frameIsCompleteAtIndex(size_t); // Whether or not the frame is completely decoded.

/*#if ENABLE(IMAGE_DECODER_DOWN_SAMPLING)
    static unsigned maxPixelsPerDecodedImage() { return s_maxPixelsPerDecodedImage; }
    static void setMaxPixelsPerDecodedImage(unsigned maxPixels) { s_maxPixelsPerDecodedImage = maxPixels; }
#endif*/

private:
    NativeImageSourcePtr m_decoder;
    bool m_premultiplyAlpha;
/*#if ENABLE(IMAGE_DECODER_DOWN_SAMPLING)
    static unsigned s_maxPixelsPerDecodedImage;
#endif*/
};
</file>

<file path="qlith/intpoint.h">
// this_file: qlith-pro/include/qlith/intpoint.h
#pragma once

//#include "common.h"

#include "qlith/intsize.h"

#include <QDataStream>

QT_BEGIN_NAMESPACE
class QPoint;
QT_END_NAMESPACE

class IntPoint {
public:
    IntPoint() : m_x(0), m_y(0) { }
    IntPoint(int x, int y) : m_x(x), m_y(y) { }
    explicit IntPoint(const IntSize& size) : m_x(size.width()), m_y(size.height()) { }

    static IntPoint zero() { return IntPoint(); }

    int x() const { return m_x; }
    int y() const { return m_y; }

    void setX(int x) { m_x = x; }
    void setY(int y) { m_y = y; }

    void move(const IntSize& s) { move(s.width(), s.height()); }
    void move(int dx, int dy) { m_x += dx; m_y += dy; }

    IntPoint expandedTo(const IntPoint& other) const
    {
        return IntPoint(m_x > other.m_x ? m_x : other.m_x,
            m_y > other.m_y ? m_y : other.m_y);
    }

    IntPoint shrunkTo(const IntPoint& other) const
    {
        return IntPoint(m_x < other.m_x ? m_x : other.m_x,
            m_y < other.m_y ? m_y : other.m_y);
    }

    void clampNegativeToZero()
    {
        *this = expandedTo(zero());
    }

    IntPoint(const QPoint&);
    operator QPoint() const;

private:
    int m_x, m_y;
};

inline IntPoint& operator+=(IntPoint& a, const IntSize& b)
{
    a.move(b.width(), b.height());
    return a;
}

inline IntPoint& operator-=(IntPoint& a, const IntSize& b)
{
    a.move(-b.width(), -b.height());
    return a;
}

inline IntPoint operator+(const IntPoint& a, const IntSize& b)
{
    return IntPoint(a.x() + b.width(), a.y() + b.height());
}

inline IntSize operator-(const IntPoint& a, const IntPoint& b)
{
    return IntSize(a.x() - b.x(), a.y() - b.y());
}

inline IntPoint operator-(const IntPoint& a, const IntSize& b)
{
    return IntPoint(a.x() - b.width(), a.y() - b.height());
}

inline bool operator==(const IntPoint& a, const IntPoint& b)
{
    return a.x() == b.x() && a.y() == b.y();
}

inline bool operator!=(const IntPoint& a, const IntPoint& b)
{
    return a.x() != b.x() || a.y() != b.y();
}

inline IntPoint toPoint(const IntSize& size)
{
    return IntPoint(size.width(), size.height());
}


inline QDataStream& operator<<(QDataStream& stream, const IntPoint& point)
{
    stream << point.x() << point.y();
    return stream;
}

inline QDataStream& operator>>(QDataStream& stream, IntPoint& point)
{
    int x, y;
    stream >> x >> y;
    point.setX(x);
    point.setY(y);
    return stream;
}
</file>

<file path="qlith/intrect.h">
// this_file: qlith-pro/include/qlith/intrect.h
#pragma once

/*#include "IntPoint.h"
#include <wtf/Vector.h>
*/

#include "qlith/common.h"
//#include "vector.h"

//#include "floatpoint.h"
//#include "floatrect.h"
#include "qlith/intpoint.h"
#include "qlith/intsize.h"
//#include "floatsize.h"
//#include "intrect.h"

QT_BEGIN_NAMESPACE
class QRect;
QT_END_NAMESPACE


class FloatRect;

class IntRect {
public:
    IntRect() { }
    IntRect(const IntPoint& location, const IntSize& size)
        : m_location(location), m_size(size) { }
    IntRect(int x, int y, int width, int height)
        : m_location(IntPoint(x, y)), m_size(IntSize(width, height)) { }

    explicit IntRect(const FloatRect& rect); // don't do this implicitly since it's lossy

    IntPoint location() const { return m_location; }
    IntSize size() const { return m_size; }

    void setLocation(const IntPoint& location) { m_location = location; }
    void setSize(const IntSize& size) { m_size = size; }

    int x() const { return m_location.x(); }
    int y() const { return m_location.y(); }
    int width() const { return m_size.width(); }
    int height() const { return m_size.height(); }

    void setX(int x) { m_location.setX(x); }
    void setY(int y) { m_location.setY(y); }
    void setWidth(int width) { m_size.setWidth(width); }
    void setHeight(int height) { m_size.setHeight(height); }

    // Be careful with these functions.  The point is considered to be to the right and below.  These are not
    // substitutes for right() and bottom().
    IntPoint topLeft() const { return m_location; }
    IntPoint topRight() const { return IntPoint(right() - 1, y()); }
    IntPoint bottomLeft() const { return IntPoint(x(), bottom() - 1); }
    IntPoint bottomRight() const { return IntPoint(right() - 1, bottom() - 1); }

    bool isEmpty() const { return m_size.isEmpty(); }

    int right() const { return x() + width(); }
    int bottom() const { return y() + height(); }

    // NOTE: The result is rounded to integer values, and thus may be not the exact
    // center point.
    IntPoint center() const { return IntPoint(x() + width() / 2, y() + height() / 2); }

    void move(const IntSize& s) { m_location += s; }
    void move(int dx, int dy) { m_location.move(dx, dy); }

    bool intersects(const IntRect&) const;
    bool contains(const IntRect&) const;

    // This checks to see if the rect contains x,y in the traditional sense.
    // Equivalent to checking if the rect contains a 1x1 rect below and to the right of (px,py).
    bool contains(int px, int py) const
        { return px >= x() && px < right() && py >= y() && py < bottom(); }
    bool contains(const IntPoint& point) const { return contains(point.x(), point.y()); }

    void intersect(const IntRect&);
    void unite(const IntRect&);

    void inflateX(int dx)
    {
        m_location.setX(m_location.x() - dx);
        m_size.setWidth(m_size.width() + dx + dx);
    }
    void inflateY(int dy)
    {
        m_location.setY(m_location.y() - dy);
        m_size.setHeight(m_size.height() + dy + dy);
    }
    void inflate(int d) { inflateX(d); inflateY(d); }
    void scale(float s);


    IntRect(const QRect&);
    operator QRect() const;

private:
    IntPoint m_location;
    IntSize m_size;
};

inline IntRect intersection(const IntRect& a, const IntRect& b)
{
    IntRect c = a;
    c.intersect(b);
    return c;
}

inline IntRect unionRect(const IntRect& a, const IntRect& b)
{
    IntRect c = a;
    c.unite(b);
    return c;
}

IntRect unionRect(const QVector<IntRect>&);

inline bool operator==(const IntRect& a, const IntRect& b)
{
    return a.location() == b.location() && a.size() == b.size();
}

inline bool operator!=(const IntRect& a, const IntRect& b)
{
    return a.location() != b.location() || a.size() != b.size();
}
</file>

<file path="qlith/intsize.h">
// this_file: qlith-pro/include/qlith/intsize.h
#pragma once

#include <qglobal.h>
QT_BEGIN_NAMESPACE
class QSize;
QT_END_NAMESPACE

class IntSize {
public:
    IntSize() : m_width(0), m_height(0) { }
    IntSize(int width, int height) : m_width(width), m_height(height) { }

    int width() const { return m_width; }
    int height() const { return m_height; }

    void setWidth(int width) { m_width = width; }
    void setHeight(int height) { m_height = height; }

    bool isEmpty() const { return m_width <= 0 || m_height <= 0; }
    bool isZero() const { return !m_width && !m_height; }

    float aspectRatio() const { return static_cast<float>(m_width) / static_cast<float>(m_height); }

    void expand(int width, int height)
    {
        m_width += width;
        m_height += height;
    }

    void scale(float scale)
    {
        m_width = static_cast<int>(static_cast<float>(m_width) * scale);
        m_height = static_cast<int>(static_cast<float>(m_height) * scale);
    }

    IntSize expandedTo(const IntSize& other) const
    {
        return IntSize(m_width > other.m_width ? m_width : other.m_width,
            m_height > other.m_height ? m_height : other.m_height);
    }

    IntSize shrunkTo(const IntSize& other) const
    {
        return IntSize(m_width < other.m_width ? m_width : other.m_width,
            m_height < other.m_height ? m_height : other.m_height);
    }

    void clampNegativeToZero()
    {
        *this = expandedTo(IntSize());
    }

    IntSize(const QSize&);
    operator QSize() const;

private:
    int m_width, m_height;
};

inline IntSize& operator+=(IntSize& a, const IntSize& b)
{
    a.setWidth(a.width() + b.width());
    a.setHeight(a.height() + b.height());
    return a;
}

inline IntSize& operator-=(IntSize& a, const IntSize& b)
{
    a.setWidth(a.width() - b.width());
    a.setHeight(a.height() - b.height());
    return a;
}

inline IntSize operator+(const IntSize& a, const IntSize& b)
{
    return IntSize(a.width() + b.width(), a.height() + b.height());
}

inline IntSize operator-(const IntSize& a, const IntSize& b)
{
    return IntSize(a.width() - b.width(), a.height() - b.height());
}

inline IntSize operator-(const IntSize& size)
{
    return IntSize(-size.width(), -size.height());
}

inline bool operator==(const IntSize& a, const IntSize& b)
{
    return a.width() == b.width() && a.height() == b.height();
}

inline bool operator!=(const IntSize& a, const IntSize& b)
{
    return a.width() != b.width() || a.height() != b.height();
}
</file>

<file path="qlith/litehtml.h">
// this_file: qlith-pro/include/qlith/litehtml.h
#ifndef LITEHTML_H
#define LITEHTML_H

// These should be found via include path to external/litehtml/include
#include "html.h"
#include "document.h"
#include "html_tag.h"
#include "stylesheet.h"
// Duplicate stylesheet include removed
#include "element.h"
// Duplicate html_tag include removed

#endif  // LITEHTML_H
</file>

<file path="qlith/litehtmlwidget.h">
// this_file: qlith-pro/include/qlith/litehtmlwidget.h
#pragma once

#include <QWidget>
#include <QPoint>
#include <QSize>
#include <QMouseEvent>
#include <QPaintEvent>
#include <QResizeEvent>
#include <QWheelEvent>
#include <QScrollBar>
#include <QTimer>
#include <QColor>

#include "litehtml.h"
#include "qlith/container_qt5.h"

/**
 * @brief Widget for displaying HTML content using litehtml
 */
class litehtmlWidget : public QWidget
{
    Q_OBJECT

public:
    /**
     * @brief Constructor
     * @param parent Parent widget
     */
    explicit litehtmlWidget(QWidget* parent = nullptr);

    /**
     * @brief Destructor
     */
    ~litehtmlWidget();

    /**
     * @brief Get the container object
     * @return Pointer to the container_qt5 instance
     */
    container_qt5* getContainer() const;

    /**
     * @brief Load HTML content
     * @param html HTML content
     * @param baseUrl Base URL for resolving relative paths
     */
    void loadHtml(const QString& html, const QString& baseUrl = QString());

    /**
     * @brief Load URL content
     * @param url URL of the content
     */
    void loadUrl(const QString& url);

    /**
     * @brief Set the scroll position
     * @param x X position
     * @param y Y position
     */
    void setScrollPos(int x, int y);

    /**
     * @brief Set the scroll position
     * @param pos New scroll position
     */
    void setScrollPosition(const QPoint& pos);

    /**
     * @brief Get current scroll position
     * @return Current scroll position
     */
    QPoint scrollPosition() const;

    /**
     * @brief Get current scroll position
     * @return Current scroll position
     */
    QPoint scrollPos() const;

    /**
     * @brief Get document size
     * @return Size of the document
     */
    QSize documentSize() const;

signals:
    /**
     * @brief Signal emitted when the title changes
     * @param title New title
     */
    void titleChanged(const QString& title);

    /**
     * @brief Signal emitted when an anchor is clicked
     * @param url URL of the clicked anchor
     */
    void anchorClicked(const QString& url);

    /**
     * @brief Signal emitted when document is loaded
     * @param success True if loading was successful
     */
    void documentLoaded(bool success);

protected:
    /**
     * @brief Handle paint events
     * @param event The paint event
     */
    void paintEvent(QPaintEvent* event) override;

    /**
     * @brief Handle resize events
     * @param event The resize event
     */
    void resizeEvent(QResizeEvent* event) override;

    /**
     * @brief Handle mouse press events
     * @param event The mouse event
     */
    void mousePressEvent(QMouseEvent* event) override;

    /**
     * @brief Handle mouse release events
     * @param event The mouse event
     */
    void mouseReleaseEvent(QMouseEvent* event) override;

    /**
     * @brief Handle mouse move events
     * @param event The mouse event
     */
    void mouseMoveEvent(QMouseEvent* event) override;

    /**
     * @brief Handle mouse wheel events
     * @param event The wheel event
     */
    void wheelEvent(QWheelEvent* event) override;

private:
    /**
     * @brief Create scrollbars for the widget
     */
    void createScrollBars();

    /**
     * @brief Update document size from container
     */
    void updateDocumentSize(int w, int h);

    /**
     * @brief Handle document size changes
     */
    void onDocSizeChanged(int w, int h);

    /**
     * @brief Create a fallback document when the main document fails to load
     * @param errorMessage Error message to display in the fallback document
     */
    void createFallbackDocument(const QString& errorMessage);

    /**
     * @brief Render the currently loaded document
     */
    void renderDocument();

private:
    container_qt5* m_container;     ///< HTML container implementation
    litehtml::document::ptr m_htmlDocument;
    QScrollBar* m_vScrollBar;       ///< Vertical scroll bar
    QScrollBar* m_hScrollBar;       ///< Horizontal scroll bar
    int m_scrollX;                  ///< X scroll position
    int m_scrollY;                  ///< Y scroll position
    QColor m_backgroundColor;       ///< Background color
    bool m_documentSizeSet;         ///< Flag indicating if document size is set
    QSize m_documentSize;           ///< Size of the document
};
</file>

<file path="qlith/mainwindow.h">
// this_file: qlith-pro/include/qlith/mainwindow.h
// -*- coding: utf-8 -*-

#pragma once

#include <QMainWindow>
#include <QResizeEvent>
#include <QString>
#include <QTextEdit>
#include <QSize>

// Forward declarations only
// class litehtml_context; // No longer needed
class litehtmlWidget;

namespace Ui {
class MainWindow;
}

class MainWindow : public QMainWindow
{
Q_OBJECT

public:
  explicit MainWindow(bool debugMode = false, QWidget *parent = nullptr);
  ~MainWindow();

  /**
   * @brief Load HTML file
   * @param filePath Path to the HTML file
   */
  void loadFile(const QString& filePath);

  /**
   * @brief Export the current view to an SVG file
   * @param filePath Path where to save the SVG file
   * @return True if export was successful, false otherwise
   */
  bool exportToSvg(const QString& filePath);

  /**
   * @brief Export the current view to a PNG file
   * @param filePath Path where to save the PNG file
   * @return True if export was successful, false otherwise
   */
  bool exportToPng(const QString& filePath);

  /**
   * @brief Set the rendering size for export operations.
   * @param size The size to use for rendering.
   */
  void setRenderSize(const QSize& size);

signals:
  /**
   * @brief Signal emitted when a document is loaded
   * @param success True if document was loaded successfully
   */
  void documentLoaded(bool success);

protected:
  /**
   * @brief Handle window resize events
   * @param event The resize event
   */
  void resizeEvent(QResizeEvent* event) override;

private slots:
  /**
   * @brief Navigate to the URL entered in the address bar
   */
  void navigateToUrl();

  /**
   * @brief Handle URL navigation
   * @param url The URL to navigate to
   */
  void loadUrl(const QString& url);

  /**
   * @brief Handle document loaded event from litehtmlWidget
   * @param success True if loading was successful
   */
  void onDocumentLoaded(bool success);

private:
  /**
   * @brief Initialize or reinitialize the litehtmlWidget
   */
  void initializeLitehtmlWidget();

  /**
   * @brief Load example HTML content
   */
  void loadExample();

  // /**
  //  * @brief Initialize the HTML context and load master CSS - No longer needed
  //  */
  // void initializeContext();

  /**
   * @brief Set up the scrollbar for the HTML content
   */
  void setupScrollbar();

  Ui::MainWindow *ui;
  litehtmlWidget *m_litehtmlWidget; // Keep this for managing the widget instance
  QTextEdit *m_htmlEditor;          // HTML editor for debug mode
  // litehtml_context m_context; // No longer needed
  bool m_debugMode; // Debug mode flag
  QSize m_renderSize; // Rendering size for export operations
};
</file>

<file path="qlith/mimetyperegistry.h">
// this_file: qlith-pro/include/qlith/mimetyperegistry.h
#pragma once

#include "qlith/common.h"

/*#include "PlatformString.h"
#include <wtf/HashSet.h>
#include <wtf/Vector.h>
#include <wtf/text/StringHash.h>*/

class MIMETypeRegistry {
public:
    static String getMIMETypeForExtension(const String& extension);
    static QVector<String> getExtensionsForMIMEType(const String& type);
    static String getPreferredExtensionForMIMEType(const String& type);
    static String getMediaMIMETypeForExtension(const String& extension);
    static QVector<String> getMediaMIMETypesForExtension(const String& extension);

    static String getMIMETypeForPath(const String& path);

    // Check to see if a mime type is suitable for being loaded inline as an
    // image (e.g., <img> tags).
    static bool isSupportedImageMIMEType(const String& mimeType);

    // Check to see if a mime type is suitable for being loaded as an image
    // document in a frame.
    static bool isSupportedImageResourceMIMEType(const String& mimeType);

    // Check to see if a mime type is suitable for being encoded.
    static bool isSupportedImageMIMETypeForEncoding(const String& mimeType);

    // Check to see if a mime type is suitable for being loaded as a JavaScript
    // resource.
    static bool isSupportedJavaScriptMIMEType(const String& mimeType);

    // Check to see if a non-image mime type is suitable for being loaded as a
    // document in a frame.  Includes supported JavaScript MIME types.
    static bool isSupportedNonImageMIMEType(const String& mimeType);

    // Check to see if a mime type is suitable for being loaded using <video> and <audio>
    static bool isSupportedMediaMIMEType(const String& mimeType);

    // Check to see if a mime type is a valid Java applet mime type
    static bool isJavaAppletMIMEType(const String& mimeType);

    // Check to see if a mime type is a plugin implemented by the
    // browser (e.g. a Qt Plugin).
    static bool isApplicationPluginMIMEType(const String& mimeType);

    static HashSet<String>& getSupportedImageMIMETypes();
    static HashSet<String>& getSupportedImageResourceMIMETypes();
    static HashSet<String>& getSupportedImageMIMETypesForEncoding();
    static HashSet<String>& getSupportedNonImageMIMETypes();
    static HashSet<String>& getSupportedMediaMIMETypes();
};

const String& defaultMIMEType();
</file>

<file path="qlith/mimetyperegistryqt.h">
// this_file: qlith-pro/include/qlith/mimetyperegistryqt.h
#ifndef MIMETYPEREGISTRYQT_H
#define MIMETYPEREGISTRYQT_H


class MIMETypeRegistryQt
{
public:
MIMETypeRegistryQt();
};

#endif // MIMETYPEREGISTRYQT_H
</file>

<file path="qlith/pathqt.h">
// this_file: qlith-pro/include/qlith/pathqt.h
#pragma once

//#include "types.h"
#include <QDebug>
#include <QFont>
#include <QFontMetrics>
#include <QPainter>
#include <QMouseEvent>
#include <QDesktopServices>

#include "qlith/fontcache.h"
#include <cmath>

#include "qlith/common.h"

#include "qlith/affinetransform.h"

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/Path.h#L44
#include <qpainterpath.h>
typedef QPainterPath PlatformPath;
typedef PlatformPath PlatformPathPtr;

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/transforms/AffineTransform.h#L169
//typedef QTransform AffineTransform;

enum WindRule {
    RULE_NONZERO = 0,
    RULE_EVENODD = 1
};

enum PathElementType {
    PathElementMoveToPoint,
    PathElementAddLineToPoint,
    PathElementAddQuadCurveToPoint,
    PathElementAddCurveToPoint,
    PathElementCloseSubpath
};

struct PathElement {
    PathElementType type;
    FloatPoint* points;
};

typedef void (*PathApplierFunction)(void* info, const PathElement*);

class Path
{
    public:
        Path();
        ~Path();

        Path(const Path&);
        Path& operator=(const Path&);

        void swap(Path& other) { std::swap(m_path, other.m_path); }

        bool contains(const FloatPoint&, WindRule rule = RULE_NONZERO) const;
        //bool strokeContains(StrokeStyleApplier*, const FloatPoint&) const;
        FloatRect boundingRect() const;
        //FloatRect strokeBoundingRect(StrokeStyleApplier* = 0);

        float length();
        FloatPoint pointAtLength(float length, bool& ok);
        float normalAngleAtLength(float length, bool& ok);

        void clear();
        bool isEmpty() const;
        // Gets the current point of the current path, which is conceptually the final point reached by the path so far.
        // Note the Path can be empty (isEmpty() == true) and still have a current point.
        bool hasCurrentPoint() const;
        FloatPoint currentPoint() const;

        void moveTo(const FloatPoint&);
        void addLineTo(const FloatPoint&);
        void addQuadCurveTo(const FloatPoint& controlPoint, const FloatPoint& endPoint);
        void addBezierCurveTo(const FloatPoint& controlPoint1, const FloatPoint& controlPoint2, const FloatPoint& endPoint);
        void addArcTo(const FloatPoint&, const FloatPoint&, float radius);
        void closeSubpath();

        void addArc(const FloatPoint&, float radius, float startAngle, float endAngle, bool anticlockwise);
        void addRect(const FloatRect&);
        void addEllipse(const FloatRect&);
        void addRoundedRect(const FloatRect&, const FloatSize& roundingRadii);
        void addRoundedRect(const FloatRect&, const FloatSize& topLeftRadius, const FloatSize& topRightRadius, const FloatSize& bottomLeftRadius, const FloatSize& bottomRightRadius);

        void translate(const FloatSize&);

        PlatformPathPtr platformPath() const { return m_path; }

        void apply(void* info, PathApplierFunction) const;
        void transform(const AffineTransform&);

    private:
        PlatformPathPtr m_path;
};
</file>

<file path="qlith/pngimagedecoder.h">
// this_file: qlith-pro/include/qlith/pngimagedecoder.h
#include "qlith/common.h"
#include "qlith/imagedecoder.h"
//#include <wtf/OwnPtr.h>


    class PNGImageReader;

    // This class decodes the PNG image format.
    class PNGImageDecoder : public ImageDecoder {
    public:
        PNGImageDecoder(bool premultiplyAlpha);
        virtual ~PNGImageDecoder();

        // ImageDecoder
        virtual String filenameExtension() const { return "png"; }
        virtual bool isSizeAvailable();
        virtual bool setSize(unsigned width, unsigned height);
        virtual RGBA32Buffer* frameBufferAtIndex(size_t index);
        // CAUTION: setFailed() deletes |m_reader|.  Be careful to avoid
        // accessing deleted memory, especially when calling this from inside
        // PNGImageReader!
        virtual bool setFailed();

        // Callbacks from libpng
        void headerAvailable();
        void rowAvailable(unsigned char* rowBuffer, unsigned rowIndex, int interlacePass);
        void pngComplete();

        bool isComplete() const
        {
            return !m_frameBufferCache.isEmpty() && (m_frameBufferCache.first().status() == RGBA32Buffer::FrameComplete);
        }

    private:
        // Decodes the image.  If |onlySize| is true, stops decoding after
        // calculating the image size.  If decoding fails but there is no more
        // data coming, sets the "decode failure" flag.
        void decode(bool onlySize);

        OwnPtr<PNGImageReader> m_reader;
        bool m_doNothingOnFailure;
    };
</file>

<file path="qlith/purgeablebuffer.h">
// this_file: qlith-pro/include/qlith/purgeablebuffer.h
#pragma once

#include "qlith/common.h"

/*#include <wtf/Noncopyable.h>
#include <wtf/PassOwnPtr.h>
#include <wtf/Vector.h>*/

    class PurgeableBuffer /*: public Noncopyable*/ {
    public:
        static PassOwnPtr<PurgeableBuffer> create(const char* data, size_t);
        static PassOwnPtr<PurgeableBuffer> create(const QVector<char>& vector) { return create(vector.data(), vector.size()); }

        ~PurgeableBuffer();

        // Call makePurgeable(false) and check the return value before accessing the data.
        const char* data() const;
        size_t size() const { return m_size; }

        enum PurgePriority { PurgeLast, PurgeMiddle, PurgeFirst, PurgeDefault = PurgeMiddle };
        PurgePriority purgePriority() const { return m_purgePriority; }
        void setPurgePriority(PurgePriority);

        bool isPurgeable() const { return m_state != NonVolatile; }
        bool wasPurged() const;

        bool makePurgeable(bool purgeable);

    private:
        PurgeableBuffer(char* data, size_t);

        char* m_data;
        size_t m_size;
        PurgePriority m_purgePriority;

        enum State { NonVolatile, Volatile, Purged };
        mutable State m_state;
    };

//#if !ENABLE(PURGEABLE_MEMORY)
    inline PassOwnPtr<PurgeableBuffer> PurgeableBuffer::create(const char*, size_t) { return PassOwnPtr<PurgeableBuffer>(); }
    inline PurgeableBuffer::~PurgeableBuffer() { }
    inline const char* PurgeableBuffer::data() const { return 0; }
    inline void PurgeableBuffer::setPurgePriority(PurgePriority) { }
    inline bool PurgeableBuffer::wasPurged() const { return false; }
    inline bool PurgeableBuffer::makePurgeable(bool) { return false; }
//#endif
</file>

<file path="qlith/rgba32bufferqt.h">
// this_file: qlith-pro/include/qlith/rgba32bufferqt.h
#pragma once
</file>

<file path="qlith/shadowdata.h">
// this_file: qlith-pro/include/qlith/shadowdata.h
#pragma once

#include "qlith/color.h"
//#include <wtf/FastAllocBase.h>

class FloatRect;
class IntRect;

enum ShadowStyle { Normal, Inset };

// This struct holds information about shadows for the text-shadow and box-shadow properties.

class ShadowData /*: public FastAllocBase*/ {
public:
    ShadowData()
        : m_x(0)
        , m_y(0)
        , m_blur(0)
        , m_spread(0)
        , m_style(Normal)
        , m_next(0)
    {
    }

    ShadowData(int x, int y, int blur, int spread, ShadowStyle style, const Color& color)
        : m_x(x)
        , m_y(y)
        , m_blur(blur)
        , m_spread(spread)
        , m_style(style)
        , m_color(color)
        , m_next(0)
    {
    }

    ShadowData(const ShadowData& o);
    ~ShadowData() { delete m_next; }

    bool operator==(const ShadowData& o) const;
    bool operator!=(const ShadowData& o) const
    {
        return !(*this == o);
    }

    int x() const { return m_x; }
    int y() const { return m_y; }
    int blur() const { return m_blur; }
    int spread() const { return m_spread; }
    ShadowStyle style() const { return m_style; }
    const Color& color() const { return m_color; }

    const ShadowData* next() const { return m_next; }
    void setNext(ShadowData* shadow) { m_next = shadow; }

    void adjustRectForShadow(IntRect&, int additionalOutlineSize = 0) const;
    void adjustRectForShadow(FloatRect&, int additionalOutlineSize = 0) const;

private:
    int m_x;
    int m_y;
    int m_blur;
    int m_spread;
    ShadowStyle m_style;
    Color m_color;
    ShadowData* m_next;
};
</file>

<file path="qlith/sharedbuffer.h">
// this_file: qlith-pro/include/qlith/sharedbuffer.h
#pragma once

#include "qlith/common.h"
/*
#include "PlatformString.h"
#include <wtf/Forward.h>
#include <wtf/OwnPtr.h>
#include <wtf/RefCounted.h>
#include <wtf/Vector.h>*/

/*#if PLATFORM(CF)
#include <wtf/RetainPtr.h>
#endif

#if PLATFORM(MAC)
#ifdef __OBJC__
@class NSData;
#else
class NSData;
#endif

#endif*/

class PurgeableBuffer;

class SharedBuffer /*: public RefCounted<SharedBuffer>*/ {
public:
    static PassRefPtr<SharedBuffer> create() { return adoptRef<SharedBuffer>( ); }
    static PassRefPtr<SharedBuffer> create(const char* c, int i) { return adoptRef<SharedBuffer>(c, i); }
    static PassRefPtr<SharedBuffer> create(const unsigned char* c, int i) { return adoptRef<SharedBuffer>(c, i); }

    static PassRefPtr<SharedBuffer> createWithContentsOfFile(const String& filePath);

    static PassRefPtr<SharedBuffer> adoptVector(QVector<char>& vector);

    // The buffer must be in non-purgeable state before adopted to a SharedBuffer.
    // It will stay that way until released.
    static PassRefPtr<SharedBuffer> adoptPurgeableBuffer(PassOwnPtr<PurgeableBuffer>);

    ~SharedBuffer();

/*#if PLATFORM(MAC)
    NSData *createNSData();
    static PassRefPtr<SharedBuffer> wrapNSData(NSData *data);
#endif
#if PLATFORM(CF)
    CFDataRef createCFData();
    static PassRefPtr<SharedBuffer> wrapCFData(CFDataRef);
#endif*/

    // Calling this function will force internal segmented buffers
    // to be merged into a flat buffer. Use getSomeData() whenever possible
    // for better performance.
    const char* data() const;

    unsigned size() const;

    // Calling this function will force internal segmented buffers
    // to be merged into a flat buffer. Use getSomeData() whenever possible
    // for better performance.
    const QVector<char>& buffer() const;

    bool isEmpty() const { return !size(); }

    void append(const char*, unsigned);
    void clear();
    const char* platformData() const;
    unsigned platformDataSize() const;

    PassRefPtr<SharedBuffer> copy() const;

    bool hasPurgeableBuffer() const { return m_purgeableBuffer.get(); }

    // Ensure this buffer has no other clients before calling this.
    PassOwnPtr<PurgeableBuffer> releasePurgeableBuffer();

    // Return the number of consecutive bytes after "position". "data"
    // points to the first byte.
    // Return 0 when no more data left.
    // When extracting all data with getSomeData(), the caller should
    // repeat calling it until it returns 0.
    // Usage:
    //      const char* segment;
    //      unsigned pos = 0;
    //      while (unsigned length = sharedBuffer->getSomeData(segment, pos)) {
    //          // Use the data. for example: decoder->decode(segment, length);
    //          pos += length;
    //      }
    unsigned getSomeData(const char*& data, unsigned position = 0) const;

//private:
public:
    SharedBuffer();
    SharedBuffer(const char*, int);
    SharedBuffer(const unsigned char*, int);

private:
    void clearPlatformData();
    void maybeTransferPlatformData();
    bool hasPlatformData() const;

    unsigned m_size;
    mutable QVector<char> m_buffer;
    mutable QVector<char*> m_segments;
    OwnPtr<PurgeableBuffer> m_purgeableBuffer;
/*#if PLATFORM(CF)
    SharedBuffer(CFDataRef);
    RetainPtr<CFDataRef> m_cfData;
#endif*/
};
</file>

<file path="qlith/stillimageqt.h">
// this_file: qlith-pro/include/qlith/stillimageqt.h
#pragma once

#include "qlith/common.h"
#include "qlith/image.h"
#include "qlith/imagesource.h"

    class StillImage : public Image {
    public:
        static PassRefPtr<StillImage> create(const QPixmap& pixmap)
        {
            return adoptRef<StillImage>(pixmap);
        }

        static PassRefPtr<StillImage> createForRendering(const QPixmap* pixmap)
        {
            return adoptRef<StillImage>(pixmap);
        }

        // FIXME: StillImages are underreporting decoded sizes and will be unable
        // to prune because these functions are not implemented yet.
        virtual void destroyDecodedData(bool destroyAll = true) { Q_UNUSED(destroyAll); }
        virtual unsigned decodedSize() const { return 0; }

        virtual IntSize size() const;
        virtual NativeImagePtr nativeImageForCurrentFrame();
        virtual void draw(GraphicsContext*, const FloatRect& dstRect, const FloatRect& srcRect, ColorSpace styleColorSpace, CompositeOperator);

    //private:
    public:
        StillImage(const QPixmap& pixmap);
        StillImage(const QPixmap* pixmap);
        ~StillImage();

    private:
        const QPixmap* m_pixmap;
        bool m_ownsPixmap;
    };
</file>

<file path="qlith/styleimage.h">
// this_file: qlith-pro/include/qlith/styleimage.h
#pragma once

#include "qlith/common.h"
#include "qlith/intsize.h"

/*#include "CSSValue.h"
#include "IntSize.h"
#include <wtf/PassRefPtr.h>
#include <wtf/RefCounted.h>
#include <wtf/RefPtr.h>*/

// TODO
//class CSSValue;

class Image;
class RenderObject;

typedef void* WrappedImagePtr;

class StyleImage /*: public RefCounted<StyleImage>*/ {
public:
    virtual ~StyleImage() { }

    bool operator==(const StyleImage& other) const
    {
        return data() == other.data();
    }

    //virtual PassRefPtr<CSSValue> cssValue() const = 0;

    virtual bool canRender(float /*multiplier*/) const { return true; }
    virtual bool isLoaded() const { return true; }
    virtual bool errorOccurred() const { return false; }
    virtual IntSize imageSize(const RenderObject*, float multiplier) const = 0;
    virtual bool imageHasRelativeWidth() const = 0;
    virtual bool imageHasRelativeHeight() const = 0;
    virtual bool usesImageContainerSize() const = 0;
    virtual void setImageContainerSize(const IntSize&) = 0;
    virtual void addClient(RenderObject*) = 0;
    virtual void removeClient(RenderObject*) = 0;
    virtual Image* image(RenderObject*, const IntSize&) const = 0;
    virtual WrappedImagePtr data() const = 0;

    virtual bool isCachedImage() const { return false; }
    virtual bool isPendingImage() const { return false; }
    virtual bool isGeneratedImage() const { return false; }

    static  bool imagesEquivalent(StyleImage* image1, StyleImage* image2)
    {
        if (image1 != image2) {
            if (!image1 || !image2)
                return false;
            return *image1 == *image2;
        }
        return true;
    }

protected:
    StyleImage() { }
};
</file>

<file path="qlith/transformationmatrix.h">
// this_file: qlith-pro/include/qlith/transformationmatrix.h
#pragma once

#include "qlith/common.h"

#include "qlith/affinetransform.h"
#include "qlith/floatpoint.h"
#include "qlith/intpoint.h"
#include <string.h> //for memcpy
//#include <wtf/FastAllocBase.h>

#include <QTransform>

class AffineTransform;
class IntRect;
class FloatPoint3D;
class FloatRect;
class FloatQuad;

class TransformationMatrix /*: public FastAllocBase*/ {
public:
    typedef double Matrix4[4][4];

    TransformationMatrix() { makeIdentity(); }
    TransformationMatrix(const TransformationMatrix& t) { *this = t; }
    TransformationMatrix(double a, double b, double c, double d, double e, double f) { setMatrix(a, b, c, d, e, f); }
    TransformationMatrix(double m11, double m12, double m13, double m14,
                         double m21, double m22, double m23, double m24,
                         double m31, double m32, double m33, double m34,
                         double m41, double m42, double m43, double m44)
    {
        setMatrix(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44);
    }

    void setMatrix(double a, double b, double c, double d, double e, double f)
    {
        m_matrix[0][0] = a; m_matrix[0][1] = b; m_matrix[0][2] = 0; m_matrix[0][3] = 0;
        m_matrix[1][0] = c; m_matrix[1][1] = d; m_matrix[1][2] = 0; m_matrix[1][3] = 0;
        m_matrix[2][0] = 0; m_matrix[2][1] = 0; m_matrix[2][2] = 1; m_matrix[2][3] = 0;
        m_matrix[3][0] = e; m_matrix[3][1] = f; m_matrix[3][2] = 0; m_matrix[3][3] = 1;
    }

    void setMatrix(double m11, double m12, double m13, double m14,
                   double m21, double m22, double m23, double m24,
                   double m31, double m32, double m33, double m34,
                   double m41, double m42, double m43, double m44)
    {
        m_matrix[0][0] = m11; m_matrix[0][1] = m12; m_matrix[0][2] = m13; m_matrix[0][3] = m14;
        m_matrix[1][0] = m21; m_matrix[1][1] = m22; m_matrix[1][2] = m23; m_matrix[1][3] = m24;
        m_matrix[2][0] = m31; m_matrix[2][1] = m32; m_matrix[2][2] = m33; m_matrix[2][3] = m34;
        m_matrix[3][0] = m41; m_matrix[3][1] = m42; m_matrix[3][2] = m43; m_matrix[3][3] = m44;
    }

    TransformationMatrix& operator =(const TransformationMatrix &t)
    {
        setMatrix(t.m_matrix);
        return *this;
    }

    TransformationMatrix& makeIdentity()
    {
        setMatrix(1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, 0, 1);
        return *this;
    }

    bool isIdentity() const
    {
        return m_matrix[0][0] == 1 && m_matrix[0][1] == 0 && m_matrix[0][2] == 0 && m_matrix[0][3] == 0 &&
               m_matrix[1][0] == 0 && m_matrix[1][1] == 1 && m_matrix[1][2] == 0 && m_matrix[1][3] == 0 &&
               m_matrix[2][0] == 0 && m_matrix[2][1] == 0 && m_matrix[2][2] == 1 && m_matrix[2][3] == 0 &&
               m_matrix[3][0] == 0 && m_matrix[3][1] == 0 && m_matrix[3][2] == 0 && m_matrix[3][3] == 1;
    }

    // This form preserves the double math from input to output
    void map(double x, double y, double& x2, double& y2) const { multVecMatrix(x, y, x2, y2); }

    // Map a 3D point through the transform, returning a 3D point.
    FloatPoint3D mapPoint(const FloatPoint3D&) const;

    // Map a 2D point through the transform, returning a 2D point.
    // Note that this ignores the z component, effectively projecting the point into the z=0 plane.
    FloatPoint mapPoint(const FloatPoint&) const;

    // Like the version above, except that it rounds the mapped point to the nearest integer value.
    IntPoint mapPoint(const IntPoint& p) const
    {
        return roundedIntPoint(mapPoint(FloatPoint(p)));
    }

    // If the matrix has 3D components, the z component of the result is
    // dropped, effectively projecting the rect into the z=0 plane
    FloatRect mapRect(const FloatRect&) const;

    // Rounds the resulting mapped rectangle out. This is helpful for bounding
    // box computations but may not be what is wanted in other contexts.
    IntRect mapRect(const IntRect&) const;

    // If the matrix has 3D components, the z component of the result is
    // dropped, effectively projecting the quad into the z=0 plane
    FloatQuad mapQuad(const FloatQuad&) const;

    // Map a point on the z=0 plane into a point on
    // the plane with with the transform applied, by extending
    // a ray perpendicular to the source plane and computing
    // the local x,y position of the point where that ray intersects
    // with the destination plane.
    FloatPoint projectPoint(const FloatPoint&) const;
    // Projects the four corners of the quad
    FloatQuad projectQuad(const FloatQuad&) const;

    double m11() const { return m_matrix[0][0]; }
    void setM11(double f) { m_matrix[0][0] = f; }
    double m12() const { return m_matrix[0][1]; }
    void setM12(double f) { m_matrix[0][1] = f; }
    double m13() const { return m_matrix[0][2]; }
    void setM13(double f) { m_matrix[0][2] = f; }
    double m14() const { return m_matrix[0][3]; }
    void setM14(double f) { m_matrix[0][3] = f; }
    double m21() const { return m_matrix[1][0]; }
    void setM21(double f) { m_matrix[1][0] = f; }
    double m22() const { return m_matrix[1][1]; }
    void setM22(double f) { m_matrix[1][1] = f; }
    double m23() const { return m_matrix[1][2]; }
    void setM23(double f) { m_matrix[1][2] = f; }
    double m24() const { return m_matrix[1][3]; }
    void setM24(double f) { m_matrix[1][3] = f; }
    double m31() const { return m_matrix[2][0]; }
    void setM31(double f) { m_matrix[2][0] = f; }
    double m32() const { return m_matrix[2][1]; }
    void setM32(double f) { m_matrix[2][1] = f; }
    double m33() const { return m_matrix[2][2]; }
    void setM33(double f) { m_matrix[2][2] = f; }
    double m34() const { return m_matrix[2][3]; }
    void setM34(double f) { m_matrix[2][3] = f; }
    double m41() const { return m_matrix[3][0]; }
    void setM41(double f) { m_matrix[3][0] = f; }
    double m42() const { return m_matrix[3][1]; }
    void setM42(double f) { m_matrix[3][1] = f; }
    double m43() const { return m_matrix[3][2]; }
    void setM43(double f) { m_matrix[3][2] = f; }
    double m44() const { return m_matrix[3][3]; }
    void setM44(double f) { m_matrix[3][3] = f; }

    double a() const { return m_matrix[0][0]; }
    void setA(double a) { m_matrix[0][0] = a; }

    double b() const { return m_matrix[0][1]; }
    void setB(double b) { m_matrix[0][1] = b; }

    double c() const { return m_matrix[1][0]; }
    void setC(double c) { m_matrix[1][0] = c; }

    double d() const { return m_matrix[1][1]; }
    void setD(double d) { m_matrix[1][1] = d; }

    double e() const { return m_matrix[3][0]; }
    void setE(double e) { m_matrix[3][0] = e; }

    double f() const { return m_matrix[3][1]; }
    void setF(double f) { m_matrix[3][1] = f; }

    // this = this * mat
    TransformationMatrix& multiply(const TransformationMatrix& t) { return *this *= t; }

    // this = mat * this
    TransformationMatrix& multLeft(const TransformationMatrix& mat);

    TransformationMatrix& scale(double);
    TransformationMatrix& scaleNonUniform(double sx, double sy);
    TransformationMatrix& scale3d(double sx, double sy, double sz);

    TransformationMatrix& rotate(double d) { return rotate3d(0, 0, d); }
    TransformationMatrix& rotateFromVector(double x, double y);
    TransformationMatrix& rotate3d(double rx, double ry, double rz);

    // The vector (x,y,z) is normalized if it's not already. A vector of
    // (0,0,0) uses a vector of (0,0,1).
    TransformationMatrix& rotate3d(double x, double y, double z, double angle);

    TransformationMatrix& translate(double tx, double ty);
    TransformationMatrix& translate3d(double tx, double ty, double tz);

    // translation added with a post-multiply
    TransformationMatrix& translateRight(double tx, double ty);
    TransformationMatrix& translateRight3d(double tx, double ty, double tz);

    TransformationMatrix& flipX();
    TransformationMatrix& flipY();
    TransformationMatrix& skew(double angleX, double angleY);
    TransformationMatrix& skewX(double angle) { return skew(angle, 0); }
    TransformationMatrix& skewY(double angle) { return skew(0, angle); }

    TransformationMatrix& applyPerspective(double p);
    bool hasPerspective() const { return m_matrix[2][3] != 0.0f; }

    // returns a transformation that maps a rect to a rect
    static TransformationMatrix rectToRect(const FloatRect&, const FloatRect&);

    bool isInvertible() const;

    // This method returns the identity matrix if it is not invertible.
    // Use isInvertible() before calling this if you need to know.
    TransformationMatrix inverse() const;

    // decompose the matrix into its component parts
    typedef struct {
        double scaleX, scaleY, scaleZ;
        double skewXY, skewXZ, skewYZ;
        double quaternionX, quaternionY, quaternionZ, quaternionW;
        double translateX, translateY, translateZ;
        double perspectiveX, perspectiveY, perspectiveZ, perspectiveW;
    } DecomposedType;

    bool decompose(DecomposedType& decomp) const;
    void recompose(const DecomposedType& decomp);

    void blend(const TransformationMatrix& from, double progress);

    bool isAffine() const
    {
        return (m13() == 0 && m14() == 0 && m23() == 0 && m24() == 0 &&
                m31() == 0 && m32() == 0 && m33() == 1 && m34() == 0 && m43() == 0 && m44() == 1);
    }

    // Throw away the non-affine parts of the matrix (lossy!)
    void makeAffine();

    AffineTransform toAffineTransform() const;

    bool operator==(const TransformationMatrix& m2) const
    {
        return (m_matrix[0][0] == m2.m_matrix[0][0] &&
                m_matrix[0][1] == m2.m_matrix[0][1] &&
                m_matrix[0][2] == m2.m_matrix[0][2] &&
                m_matrix[0][3] == m2.m_matrix[0][3] &&
                m_matrix[1][0] == m2.m_matrix[1][0] &&
                m_matrix[1][1] == m2.m_matrix[1][1] &&
                m_matrix[1][2] == m2.m_matrix[1][2] &&
                m_matrix[1][3] == m2.m_matrix[1][3] &&
                m_matrix[2][0] == m2.m_matrix[2][0] &&
                m_matrix[2][1] == m2.m_matrix[2][1] &&
                m_matrix[2][2] == m2.m_matrix[2][2] &&
                m_matrix[2][3] == m2.m_matrix[2][3] &&
                m_matrix[3][0] == m2.m_matrix[3][0] &&
                m_matrix[3][1] == m2.m_matrix[3][1] &&
                m_matrix[3][2] == m2.m_matrix[3][2] &&
                m_matrix[3][3] == m2.m_matrix[3][3]);
    }

    bool operator!=(const TransformationMatrix& other) const { return !(*this == other); }

    // *this = *this * t (i.e., a multRight)
    TransformationMatrix& operator*=(const TransformationMatrix& t)
    {
        *this = *this * t;
        return *this;
    }

    // result = *this * t (i.e., a multRight)
    TransformationMatrix operator*(const TransformationMatrix& t) const
    {
        TransformationMatrix result = t;
        result.multLeft(*this);
        return result;
    }

    operator QTransform() const;

    bool isIdentityOrTranslation() const
    {
        return m_matrix[0][0] == 1 && m_matrix[0][1] == 0 && m_matrix[0][2] == 0 && m_matrix[0][3] == 0
            && m_matrix[1][0] == 0 && m_matrix[1][1] == 1 && m_matrix[1][2] == 0 && m_matrix[1][3] == 0
            && m_matrix[2][0] == 0 && m_matrix[2][1] == 0 && m_matrix[2][2] == 1 && m_matrix[2][3] == 0
            && m_matrix[3][3] == 1;
    }

private:
    // multiply passed 2D point by matrix (assume z=0)
    void multVecMatrix(double x, double y, double& dstX, double& dstY) const;

    // multiply passed 3D point by matrix
    void multVecMatrix(double x, double y, double z, double& dstX, double& dstY, double& dstZ) const;

    void setMatrix(const Matrix4 m)
    {
        if (m && m != m_matrix)
            memcpy(m_matrix, m, sizeof(Matrix4));
    }

    Matrix4 m_matrix;
};
</file>

<file path="qlith/vectortraits.h">
// this_file: qlith-pro/include/qlith/vectortraits.h
#pragma once


/*#include "OwnPtr.h"
#include "RefPtr.h"
#include "TypeTraits.h"*/

#include <utility>
#include <memory>

using std::pair;

    template<bool isPod, typename T>
    struct VectorTraitsBase;

    template<typename T>
    struct VectorTraitsBase<false, T>
    {
        static const bool needsDestruction = true;
        static const bool needsInitialization = true;
        static const bool canInitializeWithMemset = false;
        static const bool canMoveWithMemcpy = false;
        static const bool canCopyWithMemcpy = false;
        static const bool canFillWithMemset = false;
        static const bool canCompareWithMemcmp = false;
    };

    template<typename T>
    struct VectorTraitsBase<true, T>
    {
        static const bool needsDestruction = false;
        static const bool needsInitialization = false;
        static const bool canInitializeWithMemset = false;
        static const bool canMoveWithMemcpy = true;
        static const bool canCopyWithMemcpy = true;
        static const bool canFillWithMemset = sizeof(T) == sizeof(char);
        static const bool canCompareWithMemcmp = true;
    };

    template<typename T>
    struct VectorTraits /*: VectorTraitsBase<IsPod<T>::value, T>*/ { };

    struct SimpleClassVectorTraits
    {
        static const bool needsDestruction = true;
        static const bool needsInitialization = true;
        static const bool canInitializeWithMemset = true;
        static const bool canMoveWithMemcpy = true;
        static const bool canCopyWithMemcpy = false;
        static const bool canFillWithMemset = false;
        static const bool canCompareWithMemcmp = true;
    };

    // we know OwnPtr and RefPtr are simple enough that initializing to 0 and moving with memcpy
    // (and then not destructing the original) will totally work
    /*template<typename P>
    struct VectorTraits<RefPtr<P> > : SimpleClassVectorTraits { };

    template<typename P>
    struct VectorTraits<OwnPtr<P> > : SimpleClassVectorTraits { };*/

    template<typename First, typename Second>
    struct VectorTraits<pair<First, Second> >
    {
        typedef VectorTraits<First> FirstTraits;
        typedef VectorTraits<Second> SecondTraits;

        static const bool needsDestruction = FirstTraits::needsDestruction || SecondTraits::needsDestruction;
        static const bool needsInitialization = FirstTraits::needsInitialization || SecondTraits::needsInitialization;
        static const bool canInitializeWithMemset = FirstTraits::canInitializeWithMemset && SecondTraits::canInitializeWithMemset;
        static const bool canMoveWithMemcpy = FirstTraits::canMoveWithMemcpy && SecondTraits::canMoveWithMemcpy;
        static const bool canCopyWithMemcpy = FirstTraits::canCopyWithMemcpy && SecondTraits::canCopyWithMemcpy;
        static const bool canFillWithMemset = false;
        static const bool canCompareWithMemcmp = FirstTraits::canCompareWithMemcmp && SecondTraits::canCompareWithMemcmp;
    };
</file>

<file path="gui/container_qt5.cpp">
#include "qlith/container_qt5.h"
#include <QDebug>
#include <QFont>
#include <QFontMetrics>
#include <QPainter>
#include <QPainterPath>
#include <QMouseEvent>
#include <QDesktopServices>
#include <QGuiApplication>
#include <QScreen>
#include <QImage>
#include <QFile>
#include <QDir>
#include <QUrl>
#include <cmath>
#include <QFontDatabase>
#include <QWindow>
#include <set>

// Default font settings - no longer needed as members are used
// static const int DEFAULT_FONT_SIZE = 16;
// static const QString DEFAULT_FONT_FAMILY = "Arial";

// Convert litehtml position to QRect
static QRect positionToRect(const litehtml::position& pos) {
    return QRect(pos.x, pos.y, pos.width, pos.height);
}

// Convert litehtml web_color to QColor
static QColor webColorToQColor(const litehtml::web_color& color) {
    return QColor(color.red, color.green, color.blue, color.alpha);
}

// Global clip stack
static litehtml::position::vector g_clips;

// Initialize static members
// int container_qt5::m_defaultFontSize = DEFAULT_FONT_SIZE; // Now a non-static member

// Constructor
container_qt5::container_qt5(QWidget* parent)
    : QObject(parent)
    , litehtml::document_container()
    , _doc(nullptr)
    , m_owner(parent)
    , m_painter(nullptr)
    , m_nextFontId(1)
// m_defaultFontName and m_defaultFontSize are initialized below
{
    Q_ASSERT(m_owner != nullptr);

    QFontDatabase fontDb;

    // First, try to find common system fonts in this specific order
    QStringList preferredFonts = {"Arial", "Helvetica", "Liberation Sans", "DejaVu Sans", "Roboto", "Verdana", "SansSerif"};

    bool fontFound = false;
    for (const QString &fontName : preferredFonts)
    {
        if (fontDb.families().contains(fontName, Qt::CaseInsensitive))
        {
            m_defaultFontName = fontName;
            fontFound = true;
            qDebug() << "container_qt5: Using preferred font:" << m_defaultFontName;
            break;
        }
    }

    // If none of the preferred fonts were found, fall back to the first available system font
    if (!fontFound)
    {
        if (!fontDb.families().isEmpty())
        {
            m_defaultFontName = fontDb.families().first();
            qDebug() << "container_qt5: Default font family set to the first available:" << m_defaultFontName;
        }
        else
        {
            m_defaultFontName = "Arial"; // Ultimate fallback
            qWarning() << "container_qt5: No system fonts found, falling back to Arial for defaultFontName.";
        }
    }

    m_defaultFontSize = 16; // Default size in pixels
    qDebug() << "container_qt5: Initialized with default font:" << m_defaultFontName << "size:" << m_defaultFontSize;
}

container_qt5::~container_qt5()
{
    m_images.clear();
    m_fonts.clear();
}

// Set the document to render
void container_qt5::set_document(std::shared_ptr<litehtml::document> doc)
{
    _doc = doc;
}

// Set the scroll position
void container_qt5::setScroll(const QPoint& val) {
    m_Scroll = val;

    // Update the document for the new scroll position
    if (_doc) {
        _doc->media_changed();
    }
}

void container_qt5::setScrollX(const int& val) {
    m_Scroll.setX(val);

    if (_doc) {
        _doc->media_changed();
    }
}

void container_qt5::setScrollY(const int& val) {
    m_Scroll.setY(val);

    if (_doc) {
        _doc->media_changed();
    }
}

// Get the current scroll position
QPoint container_qt5::getScroll() const {
    return m_Scroll;
}

// Track mouse coordinates
void container_qt5::setLastMouseCoords(int x, int y, int xClient, int yClient) {
    lastCursorX = x;
    lastCursorY = y;
    lastCursorClientX = xClient;
    lastCursorClientY = yClient;
}

// Set the painter to use for rendering
void container_qt5::setPainter(QPainter* painter) {
    m_painter = painter;
}

// Render the document
void container_qt5::repaint(QPainter& painter)
{
    if (!_doc) {
        qWarning() << "container_qt5::repaint called with null document";
        return;
    }

    // Set up painter
    setPainter(&painter);
    painter.setRenderHint(QPainter::Antialiasing);

    try
    {
        // Get widget size
        QRect rc = m_owner ? m_owner->rect() : QRect(0, 0, 800, 600);

        // Ensure positive dimensions
        int docWidth = std::max(rc.width(), 1);

        // Render document at appropriate width
        _doc->render(docWidth);

        // Set up clipping rectangle
        litehtml::position clipPos;
        clipPos.width = rc.width();
        clipPos.height = rc.height();
        clipPos.x = rc.x();
        clipPos.y = rc.y();

        // Draw the document - painter is guaranteed to be valid here
        _doc->draw(reinterpret_cast<litehtml::uint_ptr>(&painter), getScroll().x(), getScroll().y(), &clipPos);
    }
    catch (const std::exception &e)
    {
        qWarning() << "Exception in container_qt5::repaint:" << e.what();
    }
    catch (...) {
        qWarning() << "Unknown exception in container_qt5::repaint";
    }

    // Clean up
    setPainter(nullptr);

    // Notify if document size has changed
    if (_doc)
    {
        int newWidth = _doc->width();
        int newHeight = _doc->height();

        if (newWidth != m_lastDocWidth || newHeight != m_lastDocHeight)
        {
            emit docSizeChanged(newWidth, newHeight);
            emit documentSizeChanged(newWidth, newHeight);
            m_lastDocWidth = newWidth;
            m_lastDocHeight = newHeight;
        }
    }
}

// litehtml::document_container implementation

// Font creation
litehtml::uint_ptr container_qt5::create_font(const litehtml::font_description &descr, const litehtml::document * /*doc*/, litehtml::font_metrics *fm)
{
    QFont font;
    QString fontFamily = QString::fromUtf8(descr.family.c_str());
    QFontDatabase fontDb; // Keep QFontDatabase for checking

    // Simplified font family handling, closer to qlith-mini
    // If a specific font family is requested, try to use it.
    // Otherwise, or if not found, fall back to the container's default.
    if (!fontFamily.isEmpty() && fontDb.families().contains(fontFamily, Qt::CaseInsensitive)) {
        font.setFamily(fontFamily);
    } else {
        // Fallback to a generic family based on style hint if family is a generic one
        // This is a simplified version of the previous complex logic.
        bool genericSet = false;
        if (fontFamily.compare("serif", Qt::CaseInsensitive) == 0) {
            font.setStyleHint(QFont::Serif);
            genericSet = true;
        } else if (fontFamily.compare("sans-serif", Qt::CaseInsensitive) == 0) {
            font.setStyleHint(QFont::SansSerif);
            genericSet = true;
        } else if (fontFamily.compare("monospace", Qt::CaseInsensitive) == 0) {
            font.setStyleHint(QFont::Monospace);
            genericSet = true;
        }
        // If not a recognized generic or not found, use container's default.
        if (!genericSet) {
             qWarning() << "Font family not found or not a recognized generic:" << fontFamily << "- using default font:" << m_defaultFontName;
            font.setFamily(m_defaultFontName);
        }
    }

    // Set font size, ensuring it's positive or default.
    int fontSize = descr.size > 0 ? descr.size : m_defaultFontSize;
    font.setPixelSize(fontSize);

    // Apply weight, style, and decorations directly as in qlith-mini.
    font.setWeight(descr.weight);
    font.setItalic(descr.style == litehtml::font_style_italic);
    font.setUnderline(descr.decoration_line & litehtml::text_decoration_line_underline);
    font.setStrikeOut(descr.decoration_line & litehtml::text_decoration_line_line_through);

    // Create and store font metrics.
    font_metrics_t metrics(font);

    if (fm) {
        QFontMetrics qfm(font);
        fm->height = qfm.height();
        fm->ascent = qfm.ascent();
        fm->descent = qfm.descent();
        fm->x_height = qfm.boundingRect('x').height(); // Consistent with qlith-mini
    }

    int fontId = m_nextFontId++;
    m_fonts[fontId] = metrics;

    return static_cast<litehtml::uint_ptr>(fontId);
}

// Font deletion
void container_qt5::delete_font(litehtml::uint_ptr hFont)
{
    qDebug() << "container_qt5::delete_font - NO-OP (Diagnostic)";
}

// Measure text width
int container_qt5::text_width(const char* text, litehtml::uint_ptr hFont)
{
    qDebug() << "container_qt5::text_width - Returning default (Diagnostic)";
    if (!text) return 0;
    int fontId = static_cast<int>(hFont);
    if (m_fonts.contains(fontId)) {
        const font_metrics_t& metrics = m_fonts[fontId];
        return metrics.metrics.horizontalAdvance(QString::fromUtf8(text));
    }
    return 10 * strlen(text); // Fallback if font not found
}

// Draw text
void container_qt5::draw_text(litehtml::uint_ptr hdc, const char* text, litehtml::uint_ptr hFont, litehtml::web_color color, const litehtml::position& pos)
{
    if (!m_painter || !text) return;

    int fontId = static_cast<int>(hFont);
    if (!m_fonts.contains(fontId)) {
        return;
    }

    // Set up painter
    m_painter->save();
    m_painter->setPen(QColor(color.red, color.green, color.blue, color.alpha));
    m_painter->setFont(m_fonts[fontId].font);

    // Draw the text
    const QFontMetrics& metrics = m_fonts[fontId].metrics;
    m_painter->drawText(pos.x, pos.y + metrics.ascent(), QString::fromUtf8(text));

    m_painter->restore();

    qDebug() << "container_qt5::draw_text - Drawing text:" << text;
}

// Convert points to pixels
int container_qt5::pt_to_px(int pt) const
{
    qreal dpr = 1.0;
    if (m_owner && m_owner->window() && m_owner->window()->windowHandle()) {
      dpr = m_owner->window()->windowHandle()->devicePixelRatio();
    } else if (QGuiApplication::primaryScreen()) {
        dpr = QGuiApplication::primaryScreen()->devicePixelRatio();
    }
    // A more robust way to convert pt to px considering DPI.
    // Standard CSS definition: 1pt = 1/72 inch. Standard DPI: 96dpi.
    // So, px = pt * (DPI / 72). We use 96 as a common screen DPI.
    return static_cast<int>(round((pt * 96.0 / 72.0) * dpr));
}

// Get default font size
int container_qt5::get_default_font_size() const
{
    return this->m_defaultFontSize;
}

// Get default font name
const char* container_qt5::get_default_font_name() const
{
    // CRITICAL FIX: Use a static QByteArray to ensure the pointer remains valid,
    // similar to the working qlith-mini implementation.
    static QByteArray fontNameHolder;
    fontNameHolder = this->m_defaultFontName.toUtf8();
    return fontNameHolder.constData();
}

// Draw a list marker (bullet, number, etc.)
void container_qt5::draw_list_marker(litehtml::uint_ptr hdc, const litehtml::list_marker& marker)
{
    if (!m_painter) return;

    m_painter->save();

    // Draw based on marker type
    QColor markerColor(marker.color.red, marker.color.green, marker.color.blue, marker.color.alpha);
    m_painter->setPen(markerColor);
    m_painter->setBrush(markerColor);

    if (marker.image.empty()) {
        // Draw the marker based on type
        QRect rect(marker.pos.x, marker.pos.y, marker.pos.width, marker.pos.height);

        switch (marker.marker_type) {
            case litehtml::list_style_type_circle:
                m_painter->setBrush(Qt::NoBrush);
                m_painter->drawEllipse(rect);
                break;

            case litehtml::list_style_type_disc:
                m_painter->setBrush(markerColor);
                m_painter->drawEllipse(rect);
                break;

            case litehtml::list_style_type_square:
                m_painter->drawRect(rect);
                break;

            default:
                // For other types (decimal, alpha, roman, etc.), draw the text
                if (marker.index >= 0) {
                    QString indexStr = QString::number(marker.index);
                    m_painter->drawText(rect, Qt::AlignCenter, indexStr);
                }
                break;
        }
    } else {
        // Draw an image marker if available
        QString imgUrl = QString::fromUtf8(marker.image.c_str());
        if (m_images.contains(imgUrl)) {
            QRect rect(marker.pos.x, marker.pos.y, marker.pos.width, marker.pos.height);
            m_painter->drawImage(rect, m_images[imgUrl]);
        }
    }

    m_painter->restore();

    qDebug() << "container_qt5::draw_list_marker - Drawing list marker of type:" << (int)marker.marker_type;
}

// Draw image background
void container_qt5::draw_image(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const std::string& url, const std::string& base_url)
{
    if (!m_painter) return;

    m_painter->save();

    QString imgUrl = QString::fromStdString(url);
    if (m_images.contains(imgUrl)) {
        const QImage& img = m_images[imgUrl];

        QRect clipRect(layer.clip_box.x, layer.clip_box.y, layer.clip_box.width, layer.clip_box.height);
        m_painter->setClipRect(clipRect);

        // Calculate image position and size based on background-position and background-size
        // In this simplified implementation, we just place it at the origin_box position
        QRect imgRect(layer.origin_box.x, layer.origin_box.y, img.width(), img.height());

        // Handle different background-repeat values
        if (layer.repeat == litehtml::background_repeat_no_repeat) {
            m_painter->drawImage(imgRect, img);
            qDebug() << "container_qt5::draw_image - Drawing image (no-repeat):" << imgUrl;
        } else if (layer.repeat == litehtml::background_repeat_repeat_x) {
            for (int x = layer.origin_box.x; x < clipRect.right(); x += img.width()) {
                m_painter->drawImage(QRect(x, layer.origin_box.y, img.width(), img.height()), img);
            }
            qDebug() << "container_qt5::draw_image - Drawing image (repeat-x):" << imgUrl;
        } else if (layer.repeat == litehtml::background_repeat_repeat_y) {
            for (int y = layer.origin_box.y; y < clipRect.bottom(); y += img.height()) {
                m_painter->drawImage(QRect(layer.origin_box.x, y, img.width(), img.height()), img);
            }
            qDebug() << "container_qt5::draw_image - Drawing image (repeat-y):" << imgUrl;
        } else if (layer.repeat == litehtml::background_repeat_repeat) {
            for (int y = layer.origin_box.y; y < clipRect.bottom(); y += img.height()) {
                for (int x = layer.origin_box.x; x < clipRect.right(); x += img.width()) {
                    m_painter->drawImage(QRect(x, y, img.width(), img.height()), img);
                }
            }
            qDebug() << "container_qt5::draw_image - Drawing image (repeat):" << imgUrl;
        }
    } else {
        qDebug() << "container_qt5::draw_image - Image not found:" << imgUrl;
    }

    m_painter->restore();
}

// Load an image from a URL
void container_qt5::load_image(const char* src, const char* baseurl, bool redraw_on_ready)
{
    if (!src) {
        qWarning() << "container_qt5::load_image - Null source";
        return;
    }

    QString url = QString::fromUtf8(src);
    QString base = baseurl ? QString::fromUtf8(baseurl) : m_baseUrl;

    // Resolve relative URLs
    QUrl resolvedUrl;
    if (QUrl(url).isRelative() && !base.isEmpty()) {
        resolvedUrl = QUrl(base).resolved(QUrl(url));
    } else {
        resolvedUrl = QUrl(url);
    }

    QString urlString = resolvedUrl.toString();

    // Skip if already loaded
    if (m_images.contains(urlString)) {
        return;
    }

    // For local files, load directly
    if (resolvedUrl.isLocalFile()) {
        QImage img(resolvedUrl.toLocalFile());
        if (!img.isNull()) {
            m_images[urlString] = img;
            qDebug() << "container_qt5::load_image - Loaded local image:" << urlString;

            if (redraw_on_ready && m_owner) {
                m_owner->update();
            }
        } else {
            qWarning() << "container_qt5::load_image - Failed to load local image:" << urlString;
        }
    } else {
        // For remote URLs, just log that we need to implement this
        // In a full implementation, we would use QNetworkAccessManager to fetch the image
        qDebug() << "container_qt5::load_image - Remote image loading not implemented for:" << urlString;
    }
}

// Get image dimensions
void container_qt5::get_image_size(const char* src, const char* baseurl, litehtml::size& sz)
{
    if (!src) {
        sz.width = 0;
        sz.height = 0;
        return;
    }

    QString url = QString::fromUtf8(src);
    QString base = baseurl ? QString::fromUtf8(baseurl) : m_baseUrl;

    // Resolve URL
    QUrl resolvedUrl;
    if (QUrl(url).isRelative() && !base.isEmpty()) {
        resolvedUrl = QUrl(base).resolved(QUrl(url));
    } else {
        resolvedUrl = QUrl(url);
    }

    QString urlString = resolvedUrl.toString();

    // If image is loaded, get its size
    if (m_images.contains(urlString)) {
        const QImage& img = m_images[urlString];
        sz.width = img.width();
        sz.height = img.height();
        qDebug() << "container_qt5::get_image_size - Image size for" << urlString
                 << "is" << sz.width << "x" << sz.height;
    } else {
        // Default size if image not loaded yet
        sz.width = 0;
        sz.height = 0;
        qDebug() << "container_qt5::get_image_size - Image not loaded:" << urlString;
    }
}

// Draw solid color background
void container_qt5::draw_solid_fill(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::web_color& color)
{
    if (!m_painter) return;

    m_painter->save();

    QColor bgColor(color.red, color.green, color.blue, color.alpha);
    m_painter->fillRect(layer.clip_box.x, layer.clip_box.y, layer.clip_box.width, layer.clip_box.height, bgColor);

    m_painter->restore();

    qDebug() << "container_qt5::draw_solid_fill - Drawing solid fill with color:"
             << bgColor.name() << "(alpha:" << bgColor.alpha() << ")";
}

// Draw linear gradient
void container_qt5::draw_linear_gradient(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::background_layer::linear_gradient& gradient)
{
    if (!m_painter) return;

    m_painter->save();

    QRect clipRect(layer.clip_box.x, layer.clip_box.y, layer.clip_box.width, layer.clip_box.height);
    m_painter->setClipRect(clipRect);

    // Create a linear gradient
    QLinearGradient qgradient;
    qgradient.setStart(gradient.start.x, gradient.start.y);
    qgradient.setFinalStop(gradient.end.x, gradient.end.y);

    // Add color stops
    for (const auto& stop : gradient.color_points) {
        QColor stopColor(stop.color.red, stop.color.green, stop.color.blue, stop.color.alpha);
        qgradient.setColorAt(stop.offset, stopColor);
    }

    // Draw the gradient
    m_painter->fillRect(clipRect, qgradient);

    m_painter->restore();

    qDebug() << "container_qt5::draw_linear_gradient - Drawing gradient from"
             << gradient.start.x << "," << gradient.start.y << " to "
             << gradient.end.x << "," << gradient.end.y;
}

// Draw radial gradient
void container_qt5::draw_radial_gradient(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::background_layer::radial_gradient& gradient)
{
    if (!m_painter) return;

    m_painter->save();

    QRect clipRect(layer.clip_box.x, layer.clip_box.y, layer.clip_box.width, layer.clip_box.height);
    m_painter->setClipRect(clipRect);

    // Create a radial gradient
    // Use the maximum of x and y radius for simplicity (Qt doesn't support elliptical gradients directly)
    qreal radius = std::max(gradient.radius.x, gradient.radius.y);
    QRadialGradient qgradient(gradient.position.x, gradient.position.y, radius);

    // Add color stops
    for (const auto& stop : gradient.color_points) {
        QColor stopColor(stop.color.red, stop.color.green, stop.color.blue, stop.color.alpha);
        qgradient.setColorAt(stop.offset, stopColor);
    }

    // Draw the gradient
    m_painter->fillRect(clipRect, qgradient);

    m_painter->restore();

    qDebug() << "container_qt5::draw_radial_gradient - Drawing gradient at"
             << gradient.position.x << "," << gradient.position.y
             << " with radius " << radius;
}

// Draw conic gradient
void container_qt5::draw_conic_gradient(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::background_layer::conic_gradient& gradient)
{
    if (!m_painter) return;

    m_painter->save();

    QRect clipRect(layer.clip_box.x, layer.clip_box.y, layer.clip_box.width, layer.clip_box.height);
    m_painter->setClipRect(clipRect);

    // Qt doesn't have direct support for conic gradients in older versions
    // Use QConicalGradient which is similar
    QConicalGradient qgradient(gradient.position.x, gradient.position.y, gradient.angle);

    // Add color stops
    for (const auto& stop : gradient.color_points) {
        QColor stopColor(stop.color.red, stop.color.green, stop.color.blue, stop.color.alpha);
        qgradient.setColorAt(stop.offset, stopColor);
    }

    // Draw the gradient
    m_painter->fillRect(clipRect, qgradient);

    m_painter->restore();

    qDebug() << "container_qt5::draw_conic_gradient - Drawing gradient at"
             << gradient.position.x << "," << gradient.position.y
             << " with angle " << gradient.angle;
}

// Draw borders
void container_qt5::draw_borders(litehtml::uint_ptr hdc, const litehtml::borders& borders, const litehtml::position& draw_pos, bool root)
{
    if (!m_painter || root) return;

    m_painter->save();

    QRect borderRect(draw_pos.x, draw_pos.y, draw_pos.width, draw_pos.height);

    // Draw top border
    if (borders.top.width > 0 && borders.top.style != litehtml::border_style_none) {
        QPen pen(QColor(borders.top.color.red, borders.top.color.green, borders.top.color.blue, borders.top.color.alpha));
        pen.setWidth(borders.top.width);

        switch (borders.top.style) {
            case litehtml::border_style_dotted:
                pen.setStyle(Qt::DotLine);
                break;
            case litehtml::border_style_dashed:
                pen.setStyle(Qt::DashLine);
                break;
            default:
                pen.setStyle(Qt::SolidLine);
                break;
        }

        m_painter->setPen(pen);
        m_painter->drawLine(borderRect.left(), borderRect.top() + borders.top.width/2,
                            borderRect.right(), borderRect.top() + borders.top.width/2);
    }

    // Draw right border
    if (borders.right.width > 0 && borders.right.style != litehtml::border_style_none) {
        QPen pen(QColor(borders.right.color.red, borders.right.color.green, borders.right.color.blue, borders.right.color.alpha));
        pen.setWidth(borders.right.width);

        switch (borders.right.style) {
            case litehtml::border_style_dotted:
                pen.setStyle(Qt::DotLine);
                break;
            case litehtml::border_style_dashed:
                pen.setStyle(Qt::DashLine);
                break;
            default:
                pen.setStyle(Qt::SolidLine);
                break;
        }

        m_painter->setPen(pen);
        m_painter->drawLine(borderRect.right() - borders.right.width/2, borderRect.top(),
                            borderRect.right() - borders.right.width/2, borderRect.bottom());
    }

    // Draw bottom border
    if (borders.bottom.width > 0 && borders.bottom.style != litehtml::border_style_none) {
        QPen pen(QColor(borders.bottom.color.red, borders.bottom.color.green, borders.bottom.color.blue, borders.bottom.color.alpha));
        pen.setWidth(borders.bottom.width);

        switch (borders.bottom.style) {
            case litehtml::border_style_dotted:
                pen.setStyle(Qt::DotLine);
                break;
            case litehtml::border_style_dashed:
                pen.setStyle(Qt::DashLine);
                break;
            default:
                pen.setStyle(Qt::SolidLine);
                break;
        }

        m_painter->setPen(pen);
        m_painter->drawLine(borderRect.left(), borderRect.bottom() - borders.bottom.width/2,
                            borderRect.right(), borderRect.bottom() - borders.bottom.width/2);
    }

    // Draw left border
    if (borders.left.width > 0 && borders.left.style != litehtml::border_style_none) {
        QPen pen(QColor(borders.left.color.red, borders.left.color.green, borders.left.color.blue, borders.left.color.alpha));
        pen.setWidth(borders.left.width);

        switch (borders.left.style) {
            case litehtml::border_style_dotted:
                pen.setStyle(Qt::DotLine);
                break;
            case litehtml::border_style_dashed:
                pen.setStyle(Qt::DashLine);
                break;
            default:
                pen.setStyle(Qt::SolidLine);
                break;
        }

        m_painter->setPen(pen);
        m_painter->drawLine(borderRect.left() + borders.left.width/2, borderRect.top(),
                            borderRect.left() + borders.left.width/2, borderRect.bottom());
    }

    m_painter->restore();

    qDebug() << "container_qt5::draw_borders - Drawing borders for rectangle:"
             << borderRect.x() << "," << borderRect.y() << "," << borderRect.width() << "," << borderRect.height();
}

// Set caption (title)
void container_qt5::set_caption(const char* caption)
{
    qDebug() << "container_qt5::set_caption - Emitting titleChanged (Diagnostic)";
    emit titleChanged(QString::fromUtf8(caption));
}

// Set base URL
void container_qt5::set_base_url(const char* base_url)
{
    if (base_url && *base_url)
    {
        m_baseUrl = QString::fromUtf8(base_url);
        qDebug() << "container_qt5::set_base_url - Setting base URL to:" << m_baseUrl;
    }
}

// Link handling
void container_qt5::link(const std::shared_ptr<litehtml::document>& doc, const litehtml::element::ptr& el)
{
    qDebug() << "container_qt5::link - NO-OP (Diagnostic)";
}

// Anchor click handling
void container_qt5::on_anchor_click(const char* url, const litehtml::element::ptr& el)
{
    qDebug() << "container_qt5::on_anchor_click - Emitting anchorClicked (Diagnostic)";
    QString linkUrl = QString::fromUtf8(url);
    emit anchorClicked(linkUrl);
}

// Mouse event handling
void container_qt5::on_mouse_event(const litehtml::element::ptr& el, litehtml::mouse_event event)
{
    qDebug() << "container_qt5::on_mouse_event - NO-OP (Diagnostic)";
}

// Set cursor
void container_qt5::set_cursor(const char* cursor)
{
    qDebug() << "container_qt5::set_cursor - Emitting cursorChanged (Diagnostic)";
    QString cursorName = QString::fromUtf8(cursor);
    emit cursorChanged(cursorName);
}

// Transform text based on the specified transformation
void container_qt5::transform_text(litehtml::string& text, litehtml::text_transform tt)
{
    if (text.empty() || tt == litehtml::text_transform_none) {
        return;
    }
    std::string& str = text;
    switch (tt) {
        case litehtml::text_transform_capitalize:
            if (!str.empty()) {
                str[0] = std::toupper(str[0]);
            }
            break;
        case litehtml::text_transform_uppercase:
            for (char &c : str) {
                c = std::toupper(c);
            }
            break;
        case litehtml::text_transform_lowercase:
            for (char &c : str) {
                c = std::tolower(c);
            }
            break;
        default:
            break;
    }
}

// Import CSS from external resources
void container_qt5::import_css(litehtml::string& text, const litehtml::string& url, litehtml::string& baseurl)
{
    // CRITICAL DIAGNOSTIC STEP: Make this a no-op, similar to qlith-mini.
    // LiteHTML will use its internal master CSS if this doesn't provide one.
    // The 'text' parameter should not be modified if we provide no CSS.
    qDebug() << "container_qt5::import_css called for URL:" << QString::fromStdString(url)
             << "Base URL:" << QString::fromStdString(baseurl) << "- NO-OP (using LiteHTML internal master CSS)";
    // text = "body { font-family: Cousine; font-size: 16px; } "; // Example of providing minimal CSS
}

// Set clipping rectangle
void container_qt5::set_clip(const litehtml::position& pos, const litehtml::border_radiuses& bdr_radius)
{
    if (!m_painter) return;

    // Create clipping region
    QRect clipRect(pos.x, pos.y, pos.width, pos.height);

    // If all radii are 0, use rectangular clip
    if (bdr_radius.top_left_x == 0 && bdr_radius.top_left_y == 0 &&
        bdr_radius.top_right_x == 0 && bdr_radius.top_right_y == 0 &&
        bdr_radius.bottom_right_x == 0 && bdr_radius.bottom_right_y == 0 &&
        bdr_radius.bottom_left_x == 0 && bdr_radius.bottom_left_y == 0) {
        m_painter->setClipRect(clipRect, Qt::IntersectClip);
    } else {
        // Use rounded rectangle clip
        QPainterPath path;

        // Create rounded rect path with different corner radii
        qreal tl_radius_x = bdr_radius.top_left_x;
        qreal tl_radius_y = bdr_radius.top_left_y;
        qreal tr_radius_x = bdr_radius.top_right_x;
        qreal tr_radius_y = bdr_radius.top_right_y;
        qreal br_radius_x = bdr_radius.bottom_right_x;
        qreal br_radius_y = bdr_radius.bottom_right_y;
        qreal bl_radius_x = bdr_radius.bottom_left_x;
        qreal bl_radius_y = bdr_radius.bottom_left_y;

        path.moveTo(clipRect.left() + tl_radius_x, clipRect.top());

        // Top edge and top-right corner
        path.lineTo(clipRect.right() - tr_radius_x, clipRect.top());
        if (tr_radius_x > 0 || tr_radius_y > 0) {
            path.arcTo(
                clipRect.right() - tr_radius_x * 2, clipRect.top(),
                tr_radius_x * 2, tr_radius_y * 2,
                90, -90
            );
        }

        // Right edge and bottom-right corner
        path.lineTo(clipRect.right(), clipRect.bottom() - br_radius_y);
        if (br_radius_x > 0 || br_radius_y > 0) {
            path.arcTo(
                clipRect.right() - br_radius_x * 2, clipRect.bottom() - br_radius_y * 2,
                br_radius_x * 2, br_radius_y * 2,
                0, -90
            );
        }

        // Bottom edge and bottom-left corner
        path.lineTo(clipRect.left() + bl_radius_x, clipRect.bottom());
        if (bl_radius_x > 0 || bl_radius_y > 0) {
            path.arcTo(
                clipRect.left(), clipRect.bottom() - bl_radius_y * 2,
                bl_radius_x * 2, bl_radius_y * 2,
                -90, -90
            );
        }

        // Left edge and top-left corner
        path.lineTo(clipRect.left(), clipRect.top() + tl_radius_y);
        if (tl_radius_x > 0 || tl_radius_y > 0) {
            path.arcTo(
                clipRect.left(), clipRect.top(),
                tl_radius_x * 2, tl_radius_y * 2,
                180, -90
            );
        }

        path.closeSubpath();
        m_painter->setClipPath(path, Qt::IntersectClip);
    }

    qDebug() << "container_qt5::set_clip - Setting clip to"
             << clipRect.x() << "," << clipRect.y() << "," << clipRect.width() << "," << clipRect.height();
}

// Remove clipping
void container_qt5::del_clip()
{
    // QPainter handles clipping stack via save/restore, so just restore to previous state
    if (m_painter) {
        m_painter->restore();
        m_painter->save();
        qDebug() << "container_qt5::del_clip - Removing clip";
    }
}

// Get viewport position and dimensions
void container_qt5::get_viewport(litehtml::position& viewport) const
{
    qDebug() << "container_qt5::get_viewport - Using default/owner (Diagnostic)";
    if (m_owner) {
        QRect rc = m_owner->rect();
        viewport.x = rc.x();
        viewport.y = rc.y();
        viewport.width = rc.width();
        viewport.height = rc.height();
    } else {
        viewport.x = 0; viewport.y = 0; viewport.width = 800; viewport.height = 600; // Fallback
    }
}

// Get media features for responsive design
void container_qt5::get_media_features(litehtml::media_features& media) const
{
    qDebug() << "container_qt5::get_media_features - Using default/owner (Diagnostic)";
    if (m_owner && QGuiApplication::primaryScreen()) {
        QRect rc = m_owner->rect();
        media.type = litehtml::media_type_screen;
        media.width = rc.width();
        media.height = rc.height();
        media.device_width = QGuiApplication::primaryScreen()->size().width();
        media.device_height = QGuiApplication::primaryScreen()->size().height();
        media.color = QGuiApplication::primaryScreen()->depth(); // More accurate color depth
        media.monochrome = (media.color == 1); // Basic monochrome check
        media.color_index = 256;
        media.resolution = QGuiApplication::primaryScreen()->logicalDotsPerInch();
    } else {
        // Minimal defaults
        media.type = litehtml::media_type_screen;
        media.width = 800; media.height = 600;
        media.device_width = 800; media.device_height = 600;
        media.color = 24; // Common default
        media.monochrome = 0;
        media.color_index = 256;
        media.resolution = 96;
    }
}

// Get language information for the document
void container_qt5::get_language(litehtml::string& language, litehtml::string& culture) const
{
    qDebug() << "container_qt5::get_language - Using default en/US (Diagnostic)";
    language = "en";
    culture = "US";
}

// Create custom elements (not used in basic implementation)
litehtml::element::ptr container_qt5::create_element(const char* tag_name,
                                                    const litehtml::string_map& attributes,
                                                    const std::shared_ptr<litehtml::document>& doc)
{
    // Instead of just logging and returning nullptr, we should let litehtml handle element creation
    // by returning nullptr only when we don't need custom elements

    // Add detailed debugging to understand which tags are being requested
    qDebug() << "container_qt5::create_element - Called for tag:" << (tag_name ? tag_name : "nullptr");

    // Ensure tag_name is valid
    if (!tag_name) {
        qWarning() << "container_qt5::create_element - Received null tag_name";
        // Let litehtml handle this case by returning nullptr
        return nullptr;
    }

    // Print attributes for debugging
    if (!attributes.empty()) {
        qDebug() << "Attributes:";
        for (const auto& attr : attributes) {
            qDebug() << "  " << attr.first.c_str() << " = " << attr.second.c_str();
        }
    }

    // Unlike in the old code, we don't return nullptr for all elements
    // Instead, we let litehtml create standard elements by returning nullptr
    // This is how it's implemented in the working qlith-mini version
    return nullptr;
}

// Resolve color names to actual colors
litehtml::string container_qt5::resolve_color(const litehtml::string& color) const
{
    // Enhance color resolution with better logging and safety checks
    qDebug() << "container_qt5::resolve_color - Called with color:" << color.c_str();

    // Check for invalid input
    if (color.empty()) {
        qWarning() << "container_qt5::resolve_color - Empty color value provided";
        return color;
    }

    // Skip CSS properties that aren't colors
    // These are decoration properties like underline, line-through, initial, etc.
    static const std::set<std::string> non_colors = {
        "underline", "line-through", "initial", "inherit", "none",
        "normal", "bold", "italic", "oblique"
    };

    if (non_colors.find(color) != non_colors.end()) {
        qDebug() << "container_qt5::resolve_color - Ignoring non-color CSS value:" << color.c_str();
        return color;
    }

    // If it's already in #RRGGBB format, just return it
    if (color.length() > 0 && color[0] == '#') {
        return color;
    }

    // Use custom resolver if available (for testing)
    if (m_customColorResolver) {
        std::string resolved = m_customColorResolver(color);
        qDebug() << "container_qt5::resolve_color - Using custom resolver for" << color.c_str()
                 << "got" << resolved.c_str();
        return resolved;
    }

    // Try to resolve using QColor's named colors
    QString colorName = QString::fromUtf8(color.c_str());
    QColor qcolor(colorName);

    if (qcolor.isValid()) {
        QString hexColor = qcolor.name();
        qDebug() << "container_qt5::resolve_color - Resolved" << colorName << "to" << hexColor;
        return hexColor.toStdString();
    }

    // If we can't resolve, return the original to avoid creating error cycles
    qDebug() << "container_qt5::resolve_color - Could not resolve color:" << color.c_str();
    return color;
}

// Drawing method
void container_qt5::draw(std::shared_ptr<litehtml::document>& doc, QPainter* painter, int x, int y, const litehtml::position* clip)
{
    // Validate parameters
    if (!doc) {
        qCritical() << "container_qt5::draw called with null document";
        return;
    }

    if (!painter)
    {
        qCritical() << "container_qt5::draw called with null painter";
        return;
    }

    // Store painter to use for drawing operations
    m_painter = painter;

    try
    {
        // Validate clip rectangle or use a safe default
        litehtml::position safeClip;
        if (clip)
        {
            safeClip = *clip;

            // Ensure clip dimensions are positive
            if (safeClip.width <= 0 || safeClip.height <= 0)
            {
                qWarning() << "container_qt5::draw called with invalid clip dimensions. Using safe defaults.";
                // Use a safe default clip size
                safeClip.width = painter->device() ? painter->device()->width() : 800;
                safeClip.height = painter->device() ? painter->device()->height() : 600;
            }
        }
        else
        {
            // Create a default clip based on painter's device
            safeClip.x = 0;
            safeClip.y = 0;
            safeClip.width = painter->device() ? painter->device()->width() : 800;
            safeClip.height = painter->device() ? painter->device()->height() : 600;
        }

        // Set up the painter for document rendering
        painter->save();
        painter->translate(x, y);

        // Draw the document with the safe clip
        try
        {
            // This is the critical call that may be causing the segfault
            // We're adding additional error checking around it
            if (doc.get() == nullptr)
            {
                qCritical() << "container_qt5::draw document pointer is null after validation";
                return;
            }

            doc->draw(reinterpret_cast<litehtml::uint_ptr>(painter), 0, 0, &safeClip);
            qDebug() << "container_qt5::draw completed successfully";
        }
        catch (const std::exception &e)
        {
            qCritical() << "Exception in document->draw:" << e.what();
        }
        catch (...)
        {
            qCritical() << "Unknown exception in document->draw";
        }

        // Clean up
        painter->restore();
    }
    catch (const std::exception &e)
    {
        qCritical() << "Exception in container_qt5::draw:" << e.what();
    }
    catch (...)
    {
        qCritical() << "Unknown exception in container_qt5::draw";
    }

    // Clear the painter reference
    m_painter = nullptr;
}

// Mouse button down handler
void container_qt5::on_lbutton_down(std::shared_ptr<litehtml::document>& doc, int x, int y, int client_x)
{
    if (!doc) {
        return;
    }

    setLastMouseCoords(x, y, client_x, y);

    litehtml::position::vector redraw_boxes;
    if (doc->on_lbutton_down(x, y, x, y, redraw_boxes)) {
        // TODO: Implement redraw of specific boxes if needed
    }
}

// Mouse button up handler
void container_qt5::on_lbutton_up(std::shared_ptr<litehtml::document>& doc, int x, int y, int client_x)
{
    if (!doc) {
        return;
    }

    setLastMouseCoords(x, y, client_x, y);

    litehtml::position::vector redraw_boxes;
    if (doc->on_lbutton_up(x, y, x, y, redraw_boxes)) {
        // TODO: Implement redraw of specific boxes if needed
    }
}

// Mouse move handler
void container_qt5::on_mouse_over(std::shared_ptr<litehtml::document>& doc, int x, int y, int client_x)
{
    if (!doc) {
        return;
    }

    setLastMouseCoords(x, y, client_x, y);

    litehtml::position::vector redraw_boxes;
    if (doc->on_mouse_over(x, y, x, y, redraw_boxes)) {
        // TODO: Implement redraw of specific boxes if needed
    }
}

// Handle image loading callback
void container_qt5::onImageLoaded(const QString& url, const QImage& image)
{
    m_images[url] = image;

    if (_doc && m_owner) {
        m_owner->update();
    }
}
</file>

<file path="gui/fontcache.cpp">
// -*- coding: utf-8 -*-

#include "qlith/fontcache.h"

#include <QFontInfo>

/* Null, because instance will be initialized on demand. */
FontCache *FontCache::instance = nullptr;

QString FontCache::defaultFontName = R"raw("Cousine Regular")raw";

FontCache *FontCache::getInstance()
{
  if (instance == 0)
  {
    instance = new FontCache();
  }

  return instance;
}

QString FontCache::getDefaultFontName()
{
  return defaultFontName;
}

FontCache::FontCache()
{
}

FontCache::~FontCache()
{
  for (QFont *font : cache)
  {
    delete font;
  }
}

QFont *FontCache::getFont(const QString &name) const
{
  if (!cache.contains(name) || cache[name] == nullptr)
  {
    qWarning() << "Font " << name << " cannot be found! Using system default.";
    // Return a default font if the requested one is not available
    static QFont *defaultFont = nullptr;
    if (!defaultFont)
    {
      defaultFont = new QFont();
      defaultFont->setFamily("Arial");
      defaultFont->setPixelSize(16);
    }
    return defaultFont;
  }
  return cache[name];
}

QFont *FontCache::addFont(const QString &path, const QString &name, int pixelSize)
{
  QFile fontFile(path);
  if (!fontFile.open(QIODevice::ReadOnly))
  {
    qCritical() << "failed to open font file, path = " << path;

    // Try with alternative paths if the direct path fails
    // This provides a fallback mechanism for different resource path formats
    QString altPath = path;
    if (path.startsWith(":/res/"))
    {
      // Already has the correct format
    }
    else if (path.startsWith(":/"))
    {
      // Try adding 'res/' after the colon
      altPath = QString(":/res") + path.mid(1);
      fontFile.setFileName(altPath);
      if (!fontFile.open(QIODevice::ReadOnly))
      {
        qWarning() << "Also failed with alternative path: " << altPath;
        return nullptr;
      }
    }
  }

  QByteArray fontData = fontFile.readAll();
  if (fontData.isEmpty())
  {
    qCritical() << "empty font file, path = " << path;
    return nullptr;
  }

  int id = QFontDatabase::addApplicationFontFromData(fontData);
  if (id < 0)
  {
    qCritical() << "font " << path << " cannot be loaded !";
    return nullptr;
  }

  QStringList families = QFontDatabase::applicationFontFamilies(id);
  if (families.isEmpty())
  {
    qCritical() << "No font families found for " << path;
    return nullptr;
  }

  QString family = families.at(0);
  qDebug() << "Adding font family " << family << " for font " << name;

  QFont *font = new QFont;
  font->setFamily(family);
  font->setPixelSize(pixelSize);
  font->setWeight(QFont::Weight::Normal);
  font->setStyle(QFont::Style::StyleNormal);
  cache[name] = font;

  QFontInfo fontInfo(*font);
  qDebug() << "Adding font:" << font->family() << " font family:" << fontInfo.family();

  return font;
}
</file>

<file path="gui/litehtmlwidget.cpp">
#include "qlith/litehtmlwidget.h"
#include "qlith/container_qt5.h"
#include "qlith/context.h"
#include <QPainter>
#include <QMouseEvent>
#include <QResizeEvent>
#include <QWheelEvent>
#include <QApplication>
#include <QDebug>
#include <QNetworkAccessManager>
#include <QNetworkRequest>
#include <QNetworkReply>
#include <QUrl>
#include <QFileInfo>
#include <QScrollBar>
#include <QTimer>
#include <QDesktopServices>
#include <QScrollArea>
#include <QLabel>

/**
 * Constructor
 * @param parent Parent widget
 */
litehtmlWidget::litehtmlWidget(QWidget *parent)
    : QWidget(parent),
      m_container(nullptr),
      m_htmlDocument(nullptr),
      m_vScrollBar(nullptr),
      m_hScrollBar(nullptr),
      m_scrollX(0),
      m_scrollY(0),
      m_backgroundColor(Qt::white),
      m_documentSizeSet(false)
{
    // Set widget attributes for proper display
    setAttribute(Qt::WA_OpaquePaintEvent);

    // Set widget to receive keyboard focus
    setFocusPolicy(Qt::StrongFocus);

    // Set minimum size
    setMinimumSize(200, 150);

    try
    {
        // Use direct allocation like in qlith-mini, ensuring proper construction
        m_container = new container_qt5(this);

        if (!m_container)
        {
            qWarning() << "Failed to create container_qt5 instance";
            return;
        }

        qDebug() << "container_qt5: Initialized with default font:" << m_container->get_default_font_name()
                 << "size:" << m_container->get_default_font_size();

        // Connect container signals to widget slots properly
        connect(m_container, &container_qt5::docSizeChanged, this, &litehtmlWidget::onDocSizeChanged);
        connect(m_container, &container_qt5::documentSizeChanged, this, &litehtmlWidget::updateDocumentSize);
        connect(m_container, &container_qt5::titleChanged, this, &litehtmlWidget::titleChanged);
        connect(m_container, &container_qt5::anchorClicked, this, &litehtmlWidget::anchorClicked);

        // Set up scrollbars
        createScrollBars();
    }
    catch (const std::exception &e)
    {
        qCritical() << "Exception in litehtmlWidget constructor:" << e.what();
    }
    catch (...)
    {
        qCritical() << "Unknown exception in litehtmlWidget constructor";
    }
}

/**
 * Destructor
 */
litehtmlWidget::~litehtmlWidget()
{
    delete m_vScrollBar;
    delete m_hScrollBar;
    delete m_container;
}

/**
 * Get the container object
 * @return Pointer to the container_qt5 instance
 */
container_qt5 *litehtmlWidget::getContainer() const
{
    return m_container;
}

/**
 * Load HTML content
 * @param html The HTML content to load
 * @param baseUrl Base URL for relative paths
 */
void litehtmlWidget::loadHtml(const QString &html, const QString &baseUrl)
{
    qDebug() << "loadHtml: Loading HTML with base URL:" << baseUrl;
    qDebug() << "loadHtml: First 100 chars of HTML:" << html.left(100).replace("\n", "\\n");
    qDebug() << "loadHtml: HTML length:" << html.length();
    qDebug() << "loadHtml: Current widget size:" << size();

    if (html.isEmpty())
    {
        qWarning() << "loadHtml: Empty HTML content provided";
        emit documentLoaded(false);
        return;
    }

    if (!m_container)
    {
        qWarning() << "loadHtml: m_container is null. Cannot proceed.";
        try {
            // Attempt to recreate the container as a last resort
            m_container = new container_qt5(this);
            if (!m_container) {
                emit documentLoaded(false);
                return;
            }
            qDebug() << "loadHtml: Successfully recreated container";

            // Reconnect signals
            connect(m_container, &container_qt5::docSizeChanged, this, &litehtmlWidget::onDocSizeChanged);
            connect(m_container, &container_qt5::documentSizeChanged, this, &litehtmlWidget::updateDocumentSize);
            connect(m_container, &container_qt5::titleChanged, this, &litehtmlWidget::titleChanged);
            connect(m_container, &container_qt5::anchorClicked, this, &litehtmlWidget::anchorClicked);
        } catch (const std::exception &e) {
            qCritical() << "loadHtml: Failed to recover from null container:" << e.what();
            emit documentLoaded(false);
            return;
        } catch (...) {
            qCritical() << "loadHtml: Failed to recover from null container (unknown error)";
            emit documentLoaded(false);
            return;
        }
    }

    try
    {
        // Clear existing document first
        if (m_htmlDocument)
        {
            qDebug() << "loadHtml: Releasing existing document";
            m_htmlDocument.reset();
        }

        // Set base URL if provided
        if (!baseUrl.isEmpty())
        {
            qDebug() << "loadHtml: Setting base URL:" << baseUrl;
            // Make sure it's properly terminated with a slash for relative paths
            QString baseUrlWithSlash = baseUrl;
            if (!baseUrlWithSlash.endsWith('/')) {
                baseUrlWithSlash += '/';
            }
            qDebug() << "loadHtml: Normalized base URL:" << baseUrlWithSlash;
            m_container->set_base_url(baseUrlWithSlash.toStdString().c_str());
        }

        // Make a local copy to ensure the string stays in scope
        QString localHtml = html;

        // Prepare HTML for parsing - ensure it's properly structured
        if (!localHtml.contains("<!DOCTYPE", Qt::CaseInsensitive)) {
            qDebug() << "loadHtml: Adding DOCTYPE declaration";
            localHtml = "<!DOCTYPE html>\n" + localHtml;
        }

        // Convert to UTF-8
        QByteArray utf8Data = localHtml.toUtf8();
        std::string htmlData(utf8Data.constData(), utf8Data.size());

        qDebug() << "loadHtml: Creating litehtml document from string, size:" << htmlData.size();

        // Create the document
        try {
            m_htmlDocument = litehtml::document::createFromString(htmlData.c_str(), m_container);

            if (!m_htmlDocument) {
                qCritical() << "loadHtml: Failed to create litehtml document. Creating a simple fallback.";
                // Create a super simple document as a last resort
                QString simpleHtml = "<!DOCTYPE html><html><body>Failed to load document</body></html>";
                QByteArray simpleUtf8 = simpleHtml.toUtf8();
                m_htmlDocument = litehtml::document::createFromString(simpleUtf8.constData(), m_container);

                if (!m_htmlDocument) {
                    qCritical() << "loadHtml: Even failed to create a simple fallback document";
                    emit documentLoaded(false);
                    return;
                }
            }

            qDebug() << "loadHtml: Document created successfully";

            // Render the document
            int renderWidth = width() > 0 ? width() : 800;
            qDebug() << "loadHtml: Rendering with width:" << renderWidth;

            m_htmlDocument->render(renderWidth);

            int docWidth = m_htmlDocument->width();
            int docHeight = m_htmlDocument->height();

            qDebug() << "loadHtml: Document dimensions after render:" << docWidth << "x" << docHeight;

            if (docWidth <= 0 || docHeight <= 0) {
                qWarning() << "loadHtml: Document has invalid dimensions, using defaults";
                m_documentSize = QSize(renderWidth, 600);
            } else {
                m_documentSize = QSize(docWidth, docHeight);
            }

            m_documentSizeSet = true;

            // Update scrollbars
            onDocSizeChanged(m_documentSize.width(), m_documentSize.height());

            // Force a repaint
            update();
            QApplication::processEvents();

            qDebug() << "loadHtml: Document loaded successfully";
            emit documentLoaded(true);
        }
        catch (const std::exception &e) {
            qCritical() << "loadHtml: Exception creating document:" << e.what();
            createFallbackDocument(QString("Exception creating document: %1").arg(e.what()));
        }
    }
    catch (const std::exception &e)
    {
        qCritical() << "loadHtml: Exception during HTML document processing:" << e.what();
        createFallbackDocument(QString("Exception: %1").arg(e.what()));
        emit documentLoaded(false);
    }
    catch (...)
    {
        qCritical() << "loadHtml: Unknown C++ exception during HTML document processing.";
        createFallbackDocument("Unknown C++ exception occurred");
        emit documentLoaded(false);
    }
}

// Helper method to create a fallback document
void litehtmlWidget::createFallbackDocument(const QString& errorMessage)
{
    try {
        qDebug() << "createFallbackDocument: Creating fallback document with error message:" << errorMessage;

        QString fallbackHtml = QString("<!DOCTYPE html><html><body><h1>Error</h1><p>%1</p></body></html>")
            .arg(errorMessage);
        std::string fallbackStdString = fallbackHtml.toUtf8().toStdString();

        if (!m_container) {
            qCritical() << "createFallbackDocument: m_container is null";
            return;
        }

        m_htmlDocument = litehtml::document::createFromString(fallbackStdString.c_str(), m_container);

        if (m_htmlDocument) {
            qDebug() << "createFallbackDocument: Fallback document created successfully";
            renderDocument();
        } else {
            qCritical() << "createFallbackDocument: Failed to create fallback document";
        }
    } catch (const std::exception& e) {
        qCritical() << "createFallbackDocument: Exception creating fallback document:" << e.what();
    } catch (...) {
        qCritical() << "createFallbackDocument: Unknown exception creating fallback document";
    }
}

// Helper method to render the loaded document
void litehtmlWidget::renderDocument()
{
    // Calculate render width
    int renderWidth = width();
    if (renderWidth <= 0 || renderWidth > 10000) {
        renderWidth = 800;
    }
    if (renderWidth < 200) renderWidth = 800;

    qDebug() << "renderDocument: Rendering document with width:" << renderWidth;

    try {
        if (!m_htmlDocument) {
            qCritical() << "renderDocument: m_htmlDocument is null";
            return;
        }

        m_htmlDocument->render(renderWidth);
        qDebug() << "renderDocument: Document rendered with dimensions:" << m_htmlDocument->width() << "x" << m_htmlDocument->height();

        // Get document size
        m_documentSize = QSize(m_htmlDocument->width(), m_htmlDocument->height());
        if (m_documentSize.width() <= 0 || m_documentSize.height() <= 0) {
            qWarning() << "renderDocument: Document has invalid dimensions - using defaults";
            m_documentSize = QSize(renderWidth, 600);
        }

        m_documentSizeSet = true;
        qDebug() << "renderDocument: Document size set to:" << m_documentSize;

        // Update scrollbars
        onDocSizeChanged(m_documentSize.width(), m_documentSize.height());

        // Force a repaint
        update();
        QApplication::processEvents();

        qDebug() << "renderDocument: Document rendered successfully";
        emit documentLoaded(true);
    } catch (const std::exception& e) {
        qCritical() << "renderDocument: Exception rendering document:" << e.what();
        m_documentSize = QSize(renderWidth, 600);
        m_documentSizeSet = true;
        update();
        emit documentLoaded(false);
    } catch (...) {
        qCritical() << "renderDocument: Unknown exception rendering document";
        m_documentSize = QSize(renderWidth, 600);
        m_documentSizeSet = true;
        update();
        emit documentLoaded(false);
    }
}

/**
 * Load HTML content from a URL
 * @param url The URL to load the HTML content from
 */
void litehtmlWidget::loadUrl(const QString &url)
{
    qDebug() << "Loading URL:" << url;

    // Handle file:// URLs directly
    if (url.startsWith("file://", Qt::CaseInsensitive))
    {
        QString localPath = QUrl(url).toLocalFile();
        QFile file(localPath);
        if (file.open(QIODevice::ReadOnly))
        {
            QString content = QString::fromUtf8(file.readAll());
            loadHtml(content, url);
            file.close();
        }
        else
        {
            QString errorHtml = QString("<html><body><h1>Error</h1><p>Failed to open file: %1</p><p>Error: %2</p></body></html>")
                                    .arg(localPath)
                                    .arg(file.errorString());
            loadHtml(errorHtml);
        }
        return;
    }

    // For HTTP/HTTPS URLs, use QNetworkAccessManager
    QNetworkAccessManager *manager = new QNetworkAccessManager(this);
    QNetworkRequest request(url);

    QNetworkReply *reply = manager->get(request);

    connect(reply, &QNetworkReply::finished, this, [=]()
            {
        if (reply->error() == QNetworkReply::NoError) {
            QString content = QString::fromUtf8(reply->readAll());
            loadHtml(content, url);
        } else {
            QString errorHtml = QString("<html><body><h1>Error</h1><p>Failed to load URL: %1</p><p>Error: %2</p></body></html>")
                                    .arg(url)
                                    .arg(reply->errorString());
            loadHtml(errorHtml);
        }

        reply->deleteLater();
        manager->deleteLater(); });
}

/**
 * Set the scroll position
 * @param x New horizontal scroll position
 * @param y New vertical scroll position
 */
void litehtmlWidget::setScrollPos(int x, int y)
{
    m_scrollX = x;
    m_scrollY = y;

    m_hScrollBar->setValue(x);
    m_vScrollBar->setValue(y);

    update();
}

/**
 * Set the scroll position
 * @param pos New scroll position
 */
void litehtmlWidget::setScrollPosition(const QPoint &pos)
{
    setScrollPos(pos.x(), pos.y());
}

/**
 * Get the current scroll position
 * @return Current scroll position
 */
QPoint litehtmlWidget::scrollPosition() const
{
    return QPoint(m_scrollX, m_scrollY);
}

/**
 * Get the current scroll position
 * @return Current scroll position
 */
QPoint litehtmlWidget::scrollPos() const
{
    return QPoint(m_scrollX, m_scrollY);
}

/**
 * Get the size of the HTML document
 * @return Document size
 */
QSize litehtmlWidget::documentSize() const
{
    return m_documentSize;
}

/**
 * Paint event handler
 * @param event Paint event
 */
void litehtmlWidget::paintEvent(QPaintEvent *event)
{
    Q_UNUSED(event);

    qDebug() << "litehtmlWidget::paintEvent - Widget size:" << size() << ", Document size:" << documentSize();

    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing, true);
    painter.setRenderHint(QPainter::TextAntialiasing, true);
    painter.setRenderHint(QPainter::SmoothPixmapTransform, true);

    painter.fillRect(rect(), Qt::white); // Always fill background

    if (!m_htmlDocument)
    {
        painter.setPen(Qt::darkGray);
        painter.drawText(rect(), Qt::AlignCenter, "No HTML document loaded or document is null.");
        qDebug() << "paintEvent: No HTML document to draw.";
        return;
    }

    if (!m_container)
    {
        painter.setPen(Qt::red);
        painter.drawText(rect(), Qt::AlignCenter, "Error: Document container is null.");
        qCritical() << "paintEvent: m_container is null. Cannot draw document.";
        return;
    }

    try
    {
        // Safety check for document dimensions before drawing
        if (m_htmlDocument->width() <= 0 || m_htmlDocument->height() <= 0)
        {
            painter.setPen(Qt::red);
            painter.drawText(rect(), Qt::AlignCenter, "Error: Document has invalid dimensions.");
            qWarning() << "paintEvent: Document has invalid dimensions:"
                       << m_htmlDocument->width() << "x" << m_htmlDocument->height();
            return;
        }

        // Translate by the scroll position and set up clipping
        painter.translate(-m_scrollX, -m_scrollY);

        // Create a clipping rectangle
        litehtml::position clip(0, 0, width() + m_scrollX, height() + m_scrollY);

        // Check if the clip rect is valid
        if (clip.width <= 0 || clip.height <= 0)
        {
            // Reset the painter and show error
            painter.resetTransform();
            painter.setPen(Qt::red);
            painter.drawText(rect(), Qt::AlignCenter, "Error: Invalid clip rectangle.");
            qWarning() << "paintEvent: Invalid clip rect:" << clip.x << clip.y << clip.width << clip.height;
            return;
        }

        qDebug() << "paintEvent: Drawing document with clip:" << clip.x << clip.y << clip.width << clip.height;

        // Draw the document with the validated clip rect - this is the core functionality
        m_container->draw(m_htmlDocument, &painter, 0, 0, &clip);

        qDebug() << "paintEvent: Document drawing completed successfully";
    }
    catch (const std::exception &e)
    {
        qCritical() << "paintEvent: Exception while drawing document:" << e.what();
        painter.resetTransform(); // Reset transform before drawing error text
        painter.setPen(Qt::red);
        painter.drawText(rect(), Qt::AlignCenter, QString("Error rendering HTML: %1").arg(e.what()));
    }
    catch (...)
    {
        qCritical() << "paintEvent: Unknown exception while drawing document.";
        painter.resetTransform();
        painter.setPen(Qt::red);
        painter.drawText(rect(), Qt::AlignCenter, "Unknown error rendering HTML.");
    }
}

/**
 * Resize event handler
 * @param event Resize event
 */
void litehtmlWidget::resizeEvent(QResizeEvent *event)
{
    QSize oldSize = event->oldSize();
    QSize newSize = event->size();

    qDebug() << "litehtmlWidget::resizeEvent - Old size:" << oldSize << ", New size:" << newSize;

    // Only rerender if width has changed significantly (helps avoid expensive re-renders)
    int widthDelta = qAbs(oldSize.width() - newSize.width());
    if (m_htmlDocument && (oldSize.width() <= 1 || widthDelta > 5))
    {
        qDebug() << "litehtmlWidget::resizeEvent - Re-rendering document with new width:" << newSize.width();
        try {
            m_htmlDocument->render(newSize.width());
        }
        catch (const std::exception &e) {
            qCritical() << "resizeEvent: Exception during document re-render:" << e.what();
        }
        catch (...) {
            qCritical() << "resizeEvent: Unknown exception during document re-render";
        }
    }

    // Update scrollbar positions
    if (m_documentSizeSet)
    {
        m_vScrollBar->setRange(0, std::max(0, m_documentSize.height() - height()));
        m_vScrollBar->setPageStep(height());

        m_hScrollBar->setRange(0, std::max(0, m_documentSize.width() - width()));
        m_hScrollBar->setPageStep(width());

        // Show scrollbars if needed
        m_vScrollBar->setVisible(m_documentSize.height() > height());
        m_hScrollBar->setVisible(m_documentSize.width() > width());

        // Position scrollbars
        m_vScrollBar->setGeometry(width() - m_vScrollBar->sizeHint().width(),
                               0,
                               m_vScrollBar->sizeHint().width(),
                               height() - (m_hScrollBar->isVisible() ? m_hScrollBar->sizeHint().height() : 0));

        m_hScrollBar->setGeometry(0,
                               height() - m_hScrollBar->sizeHint().height(),
                               width() - (m_vScrollBar->isVisible() ? m_vScrollBar->sizeHint().width() : 0),
                               m_hScrollBar->sizeHint().height());
    }

    QWidget::resizeEvent(event);
}

/**
 * Mouse press event handler
 * @param event Mouse event
 */
void litehtmlWidget::mousePressEvent(QMouseEvent *event)
{
    if (m_htmlDocument)
    {
        int x = event->pos().x() + m_scrollX;
        int y = event->pos().y() + m_scrollY;

        m_container->on_lbutton_down(m_htmlDocument, x, y, 0);
    }

    QWidget::mousePressEvent(event);
}

/**
 * Mouse release event handler
 * @param event Mouse event
 */
void litehtmlWidget::mouseReleaseEvent(QMouseEvent *event)
{
    if (m_htmlDocument)
    {
        int x = event->pos().x() + m_scrollX;
        int y = event->pos().y() + m_scrollY;

        m_container->on_lbutton_up(m_htmlDocument, x, y, 0);
    }

    QWidget::mouseReleaseEvent(event);
}

/**
 * Mouse move event handler
 * @param event Mouse event
 */
void litehtmlWidget::mouseMoveEvent(QMouseEvent *event)
{
    if (m_htmlDocument)
    {
        int x = event->pos().x() + m_scrollX;
        int y = event->pos().y() + m_scrollY;

        m_container->on_mouse_over(m_htmlDocument, x, y, 0);
    }

    QWidget::mouseMoveEvent(event);
}

/**
 * Wheel event handler for scrolling
 * @param event Wheel event
 */
void litehtmlWidget::wheelEvent(QWheelEvent *event)
{
    if (m_vScrollBar->isVisible())
    {
        // Calculate scroll amount (adjust the divisor for sensitivity)
        int delta = event->angleDelta().y() / 8;

        // Update vertical scrollbar
        m_vScrollBar->setValue(m_vScrollBar->value() - delta);
    }

    event->accept();
}

/**
 * Handler for document size changes
 * @param w New width
 * @param h New height
 */
void litehtmlWidget::onDocSizeChanged(int w, int h)
{
    m_documentSize = QSize(w, h);
    m_documentSizeSet = true;

    // Update scrollbar ranges
    m_vScrollBar->setRange(0, std::max(0, h - this->height()));
    m_vScrollBar->setPageStep(this->height());

    m_hScrollBar->setRange(0, std::max(0, w - this->width()));
    m_hScrollBar->setPageStep(this->width());

    // Show scrollbars if needed
    m_vScrollBar->setVisible(h > this->height());
    m_hScrollBar->setVisible(w > this->width());

    // Position scrollbars
    m_vScrollBar->setGeometry(this->width() - m_vScrollBar->sizeHint().width(),
                              0,
                              m_vScrollBar->sizeHint().width(),
                              this->height() - (m_hScrollBar->isVisible() ? m_hScrollBar->sizeHint().height() : 0));

    m_hScrollBar->setGeometry(0,
                              this->height() - m_hScrollBar->sizeHint().height(),
                              this->width() - (m_vScrollBar->isVisible() ? m_vScrollBar->sizeHint().width() : 0),
                              m_hScrollBar->sizeHint().height());

    update();
}

void litehtmlWidget::updateDocumentSize(int w, int h)
{
    // Delegates to the existing onDocSizeChanged method
    onDocSizeChanged(w, h);
}

/**
 * Create scrollbars for the widget
 */
void litehtmlWidget::createScrollBars()
{
    // Create vertical scrollbar
    m_vScrollBar = new QScrollBar(Qt::Vertical, this);
    m_vScrollBar->setRange(0, 0);
    m_vScrollBar->hide();
    connect(m_vScrollBar, &QScrollBar::valueChanged, [this](int value)
            {
        m_scrollY = value;
        update(); });

    // Create horizontal scrollbar
    m_hScrollBar = new QScrollBar(Qt::Horizontal, this);
    m_hScrollBar->setRange(0, 0);
    m_hScrollBar->hide();
    connect(m_hScrollBar, &QScrollBar::valueChanged, [this](int value)
            {
        m_scrollX = value;
        update(); });
}

// Removed linkClicked and titleChanged implementations - they are signals and shouldn't be implemented
</file>

<file path="gui/main.cpp">
// -*- coding: utf-8 -*-

#include <QApplication>
#include <QFile>
#include <QDir>
#include <QStandardPaths>
#include <QProcessEnvironment>
#include <QCommandLineParser>
#include <QUrl>
#include <QFileInfo>
#include <QTimer>
#include <QThread>
#include "qlith/container_qt5.h"
#include "qlith/context.h"
#include "qlith/mainwindow.h"
#include <QDebug>
#include <QWidget>

#include "qlith/fontcache.h"

// Function to safely load a font, returning true if successful
bool tryLoadFont(const QString &path, const QString &name, int size)
{
  QFont *font = FontCache::getInstance()->addFont(path, name, size);
  return (font != nullptr);
}

int main(int argc, char **argv)
{
  QApplication app(argc, argv);

  // Set application information
  QCoreApplication::setApplicationName("Qlith Pro");
  QCoreApplication::setApplicationVersion("1.0");
  QCoreApplication::setOrganizationName("Qlith");

  // Parse command line arguments
  QCommandLineParser parser;
  parser.setApplicationDescription("Qlith Pro - Advanced HTML renderer");
  parser.addHelpOption();
  parser.addVersionOption();
  parser.addPositionalArgument("url", "The HTML file to open, optional.", "[url]");

  // Add export options
  QCommandLineOption svgOption(QStringList() << "svg", "Render to SVG file and quit.", "path");
  parser.addOption(svgOption);

  QCommandLineOption pngOption(QStringList() << "png", "Render to PNG file and quit.", "path");
  parser.addOption(pngOption);

  // Add width and height options
  QCommandLineOption widthOption(QStringList() << "width", "Set rendering width in pixels.", "pixels", "2048");
  parser.addOption(widthOption);

  QCommandLineOption heightOption(QStringList() << "height", "Set rendering height in pixels.", "pixels", "2048");
  parser.addOption(heightOption);

  parser.process(app);

  // Get export paths
  QString svgPath = parser.value(svgOption);
  QString pngPath = parser.value(pngOption);

  // Get width and height
  int renderWidth = parser.value(widthOption).toInt();
  int renderHeight = parser.value(heightOption).toInt();

  qDebug() << "Render size:" << renderWidth << "x" << renderHeight;

  // Get input file
  QString inputFile;
  const QStringList args = parser.positionalArguments();
  if (!args.isEmpty()) {
    inputFile = args.first();
  }

  // Check for debug mode
  bool debugMode = QProcessEnvironment::systemEnvironment().contains("QLITH_DEBUG");
  if (debugMode)
  {
    qDebug() << "Running in debug mode";
  }

  // Register metatype for proper signal/slot connections
  qRegisterMetaType<container_qt5 *>("container_qt5*");

  // Initialize fonts - try multiple path formats for better reliability
  qDebug() << "Current directory:" << QDir::currentPath();
  qDebug() << "Application directory:" << QCoreApplication::applicationDirPath();

  const int defaultStaticFontSize = 16; // Define a local default font size

  // Try different resource paths for font loading
  bool fontLoaded = false;

  // Try to load Cousine Regular font with different paths
  fontLoaded = tryLoadFont(":/font/Cousine-Regular.ttf", "Cousine", defaultStaticFontSize);
  if (!fontLoaded)
  {
    fontLoaded = tryLoadFont(":/res/font/Cousine-Regular.ttf", "Cousine", defaultStaticFontSize);
  }

  // Don't worry too much about other fonts - they're optional
  // and we don't want to clutter the debug output with failures

  // Handle export mode
  bool exportMode = !svgPath.isEmpty() || !pngPath.isEmpty();

  qDebug() << "Export mode:" << (exportMode ? "true" : "false");
  if (exportMode) {
    qDebug() << "PNG export path:" << pngPath;
    qDebug() << "SVG export path:" << svgPath;
  }

  // Create main window with debug flag
  MainWindow w(debugMode);

  // Set the render size for export
  w.setRenderSize(QSize(renderWidth, renderHeight));

  // Always show the window, even in export mode for proper rendering
  w.show();

  // Load file if specified
  if (!inputFile.isEmpty()) {
    qDebug() << "Loading file:" << inputFile;
    w.loadFile(inputFile);

    // If in export mode, perform export after page load
    if (exportMode) {
      // Wait for document to load and then export
      QEventLoop waitLoop;

      // Track loading success
      bool loadingSuccess = false;

      // Connect documentLoaded signal to exit the wait loop
      QObject::connect(&w, &MainWindow::documentLoaded, [&waitLoop, &loadingSuccess](bool success) {
        qDebug() << "Document loaded signal received, success:" << success;
        loadingSuccess = success;
        // Continue whether or not loading was successful
        waitLoop.quit();
      });

      // Set a longer timeout for the waitLoop to ensure rendering completes (increased from 5000 to 10000)
      QTimer::singleShot(10000, &waitLoop, &QEventLoop::quit);

      // Wait for document to load or timeout
      qDebug() << "Waiting for document to load...";
      waitLoop.exec();

      if (!loadingSuccess) {
        qWarning() << "Document loading may have failed, but proceeding with export attempt";
      }

      // Add additional delay to ensure rendering happens (increased from 500 to 1000)
      QThread::msleep(1000);

      // Process events multiple times to ensure rendering happens (increased loops from 3 to 5)
      for (int i = 0; i < 5; i++) {
        QApplication::processEvents();
        QThread::msleep(200); // Increased from 100 to 200
      }

      // Force the window to repaint
      w.repaint();
      QApplication::processEvents();

      // Verify widget exists but don't access its methods directly
      QWidget* htmlWidget = w.findChild<QWidget*>();
      if (htmlWidget) {
        qDebug() << "Widget found, current size:" << htmlWidget->size();

        // Force a render update on the widget
        htmlWidget->update();
        QApplication::processEvents();
      } else {
        qWarning() << "Could not find widget in MainWindow";
      }

      // Perform export operations
      bool exportSuccess = false;

      if (!svgPath.isEmpty()) {
        qDebug() << "Exporting to SVG:" << svgPath;
        exportSuccess = w.exportToSvg(svgPath);
        qDebug() << "SVG export result:" << (exportSuccess ? "Success" : "Failed");
      }

      if (!pngPath.isEmpty()) {
        qDebug() << "Exporting to PNG:" << pngPath;
        exportSuccess = w.exportToPng(pngPath);
        qDebug() << "PNG export result:" << (exportSuccess ? "Success" : "Failed");
      }

      // Quit immediately after export without waiting for user to close window
      if (exportSuccess) {
        qDebug() << "Export completed successfully. Exiting application.";
        QTimer::singleShot(100, &app, QApplication::quit);
        return app.exec();
      } else {
        qCritical() << "Export failed! Exiting application.";
        QTimer::singleShot(100, &app, QApplication::quit);
        return 1;  // Return non-zero exit code on failure
      }
    }
  }

  return app.exec();
}
</file>

<file path="gui/mainwindow.cpp">
// -*- coding: utf-8 -*-

# include "qlith/mainwindow.h"
#include "ui_mainwindow.h"
#include "qlith/litehtmlwidget.h"
#include "qlith/container_qt5.h"

#include <QDebug>
#include <QFile>
#include <QScrollArea>
#include <QScrollBar>
#include <QSlider>
#include <QDesktopServices>
#include <QUrl>
#include <QLineEdit>
#include <QPushButton>
#include <QHBoxLayout>
#include <QDir>
#include <QCoreApplication>
#include <QFileInfo>
#include <QLabel>
#include <QTextEdit>
#include <QVBoxLayout>
#include <QMenuBar>
#include <QStatusBar>
#include <QComboBox>
#include <QCheckBox>
#include <QMessageBox>
#include <QPainter>
#include <QSvgGenerator>
#include <QPlainTextEdit>
#include <QApplication>
#include <QEventLoop>
#include <QTimer>
#include <QThread>

MainWindow::MainWindow(bool debugMode, QWidget *parent) : QMainWindow(parent),
                                                          ui(new Ui::MainWindow),
                                                          m_litehtmlWidget(nullptr),
                                                          m_htmlEditor(nullptr),
                                                          m_debugMode(debugMode),
                                                          m_renderSize(800, 600) // Default render size
{
  ui->setupUi(this);

  if (m_debugMode)
  {
    // Minimal UI for debug mode - This part was already designed to be simple
    // and to isolate litehtml initialization, so we keep its structure.
    QWidget *centralWidget = new QWidget(this);
    QVBoxLayout *layout = new QVBoxLayout(centralWidget);
    QHBoxLayout *controlLayout = new QHBoxLayout();
    QTextEdit *htmlEditor = new QTextEdit(centralWidget);
    htmlEditor->setPlainText("<html><head><title>Test</title></head><body><h1>Test Page</h1><p>This is a simple test page.</p></body></html>");
    QPushButton *renderButtonLiteHTML = new QPushButton("Render with LiteHTML", centralWidget);
    QLabel *statusLabel = new QLabel("Status: Ready for LiteHTML test", centralWidget);

    controlLayout->addWidget(renderButtonLiteHTML);
    controlLayout->addWidget(statusLabel);
    layout->addLayout(controlLayout);
    layout->addWidget(htmlEditor, 1);

    // Placeholder for where litehtmlWidget would go, or just use a simple label for now
    QLabel *contentPlaceholder = new QLabel("LiteHTML content will appear here or in a new window.", centralWidget);
    contentPlaceholder->setAlignment(Qt::AlignCenter);
    contentPlaceholder->setFrameStyle(QFrame::Box | QFrame::Sunken);
    layout->addWidget(contentPlaceholder, 2);

    centralWidget->setLayout(layout);
    setCentralWidget(centralWidget);

    connect(renderButtonLiteHTML, &QPushButton::clicked, [this, htmlEditor, statusLabel]()
            {
      try
      {
        statusLabel->setText("Status: Creating LiteHTML widget...");
        if (this->m_litehtmlWidget)
        {
          delete this->m_litehtmlWidget;
          this->m_litehtmlWidget = nullptr;
        }
        this->m_litehtmlWidget = new litehtmlWidget();

        statusLabel->setText("Status: Loading HTML into LiteHTML widget...");
        this->m_litehtmlWidget->loadHtml(htmlEditor->toPlainText());

        statusLabel->setText("Status: Displaying LiteHTML widget...");
        QScrollArea *scrollArea = new QScrollArea(this);
        scrollArea->setWidget(this->m_litehtmlWidget);
        scrollArea->setWidgetResizable(true);
        scrollArea->resize(600, 400);
        scrollArea->setWindowTitle("LiteHTML Render Test");
        scrollArea->show();

        statusLabel->setText("Status: LiteHTML rendering attempted.");
      }
      catch (const std::exception &e)
      {
        statusLabel->setText(QString("LiteHTML Error: %1").arg(e.what()));
        qCritical() << "LiteHTML rendering exception:" << e.what();
      }
      catch (...)
      {
        statusLabel->setText("LiteHTML Error: Unknown exception.");
        qCritical() << "LiteHTML rendering unknown exception.";
      } });

    setWindowTitle("qlith-pro - Debug Mode");
    return; // Important: Return to not execute normal mode UI setup
  }

  // == Normal Mode UI Setup (Not Debug) ==
  qDebug() << "MainWindow: Setting up normal mode UI.";

  // Create address bar components
  QLineEdit* urlEdit = new QLineEdit(this);
  urlEdit->setPlaceholderText("Enter URL (file:// or https://)");
  QPushButton *goButton = new QPushButton("Go", this);
  QHBoxLayout* addressBarLayout = new QHBoxLayout();
  addressBarLayout->addWidget(urlEdit);
  addressBarLayout->addWidget(goButton);
  ui->verticalLayout_6->insertLayout(0, addressBarLayout);

  connect(goButton, &QPushButton::clicked, this, &MainWindow::navigateToUrl);
  connect(urlEdit, &QLineEdit::returnPressed, this, &MainWindow::navigateToUrl);
  connect(ui->pushButton, &QPushButton::clicked, this, &MainWindow::loadExample);
  ui->pushButton->setText("Load Example");

  // Create a new litehtmlWidget for normal mode - ALWAYS initialize
  initializeLitehtmlWidget();

  // Initial content loading (if not in debug mode)
  QStringList args = QCoreApplication::arguments();
  if (args.size() > 1 && !args.at(1).isEmpty() && !args.at(1).startsWith("--"))
  {
    QString filePath = args.at(1);
    qDebug() << "MainWindow: Loading file from command line:" << filePath;

    // Handle relative paths more robustly
    QFileInfo fileInfo(filePath);
    if (fileInfo.exists() && fileInfo.isReadable()) {
      loadFile(filePath);
    } else if (fileInfo.isRelative()) {
      // Try to resolve relative path
      QString absPath = QDir::current().absoluteFilePath(filePath);
      if (QFileInfo(absPath).exists() && QFileInfo(absPath).isReadable()) {
        qDebug() << "MainWindow: Resolved relative path to:" << absPath;
        loadFile(absPath);
      } else {
        qWarning() << "MainWindow: File not found:" << filePath;
        loadExample(); // Fallback to example
      }
    } else {
      qWarning() << "MainWindow: Invalid or nonexistent file:" << filePath;
      loadExample(); // Fallback to example
    }

    // Update URL field if it exists
    QLineEdit* urlEdit = findChild<QLineEdit*>();
    if (urlEdit) {
      urlEdit->setText(filePath);
    }
  }
  else
  {
    qDebug() << "MainWindow: No file from command line, loading example.";
    loadExample();
  }

  setWindowTitle("qlith-pro");

  // Start with a maximized window
  showMaximized();
}

void MainWindow::initializeLitehtmlWidget()
{
  // Clean up existing widget if it exists
  if (m_litehtmlWidget)
  {
    delete m_litehtmlWidget;
    m_litehtmlWidget = nullptr;
  }

  // Create a new litehtmlWidget
  m_litehtmlWidget = new litehtmlWidget();
  if (!m_litehtmlWidget) {
    qCritical() << "Failed to create litehtmlWidget instance!";
    return;
  }

  // Set specific size for the widget to match our render size
  if (m_renderSize.isValid()) {
    m_litehtmlWidget->setMinimumSize(m_renderSize.width(), m_renderSize.height());
    m_litehtmlWidget->resize(m_renderSize);
  }

  // Create a scroll area and set the litehtmlWidget as its child
  QScrollArea* scrollArea = new QScrollArea();
  scrollArea->setWidget(m_litehtmlWidget);
  scrollArea->setWidgetResizable(true);
  scrollArea->setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
  scrollArea->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);

  // Set the scroll area as the central widget
  setCentralWidget(scrollArea);

  // Connect to the correct signal for link clicks and document loading
  connect(m_litehtmlWidget, &litehtmlWidget::anchorClicked, this, &MainWindow::loadUrl);
  connect(m_litehtmlWidget, &litehtmlWidget::documentLoaded, this, &MainWindow::onDocumentLoaded);

  qDebug() << "litehtmlWidget initialized successfully";
}

void MainWindow::setupScrollbar()
{
  // Disabled in this version
  // This method would need significant rework if used outside debug mode
  // given the changes to central widget management.
  // For normal mode, the QScrollArea now handles scrollbars for m_litehtmlWidget.
}

MainWindow::~MainWindow()
{
  delete ui;
}

void MainWindow::resizeEvent(QResizeEvent *event)
{
  QMainWindow::resizeEvent(event);

  // Update litehtmlWidget size if needed
  if (m_litehtmlWidget)
  {
    m_litehtmlWidget->setMinimumWidth(width() - 30);
  }
}

void MainWindow::navigateToUrl()
{
  QLineEdit* urlEdit = findChild<QLineEdit*>();
  if (urlEdit && !urlEdit->text().isEmpty())
  {
    loadUrl(urlEdit->text());
  }
}

void MainWindow::loadUrl(const QString &url)
{
  // Ensure widget is initialized
  if (!m_litehtmlWidget) {
    qWarning() << "loadUrl: litehtmlWidget is null, initializing...";
    initializeLitehtmlWidget();
    if (!m_litehtmlWidget) {
      qCritical() << "loadUrl: Failed to initialize litehtmlWidget";
      return;
    }
  }

  qDebug() << "loadUrl: Loading URL:" << url;

  // Try to convert to a QUrl with proper handling of relative paths
  QUrl qUrl;
  if (QFileInfo(url).isRelative() && !url.startsWith("http://") && !url.startsWith("https://")) {
    // Handle relative file paths
    QString absolutePath = QDir::current().absoluteFilePath(url);
    qUrl = QUrl::fromLocalFile(absolutePath);
    qDebug() << "loadUrl: Converted relative path to absolute URL:" << qUrl.toString();
  } else {
    qUrl = QUrl::fromUserInput(url);
  }

  // If it's a valid file URL, load directly with the file method
  if (qUrl.isValid() && qUrl.isLocalFile()) {
    loadFile(qUrl.toLocalFile());
    return;
  }

  // Otherwise use the standard URL loading
  m_litehtmlWidget->loadUrl(qUrl.toString());
}

void MainWindow::loadExample()
{
  // Ensure widget is initialized
  if (!m_litehtmlWidget) {
    qWarning() << "loadExample: litehtmlWidget is null, initializing...";
    initializeLitehtmlWidget();
    if (!m_litehtmlWidget) {
      qCritical() << "loadExample: Failed to initialize litehtmlWidget";
      return;
    }
  }

  // Simple example HTML content
  QString exampleHtml = R"(
  <!DOCTYPE html>
  <html>
  <head>
    <title>Example Page</title>
    <style>
      body { font-family: Arial, sans-serif; margin: 20px; }
      h1 { color: #333; }
      p { line-height: 1.5; }
    </style>
  </head>
  <body>
    <h1>Welcome to qlith-pro</h1>
    <p>This is a simple HTML example page rendered with litehtml.</p>
    <p>The rendering engine supports basic HTML, CSS, and images.</p>
  </body>
  </html>
  )";

  m_litehtmlWidget->loadHtml(exampleHtml);
}

void MainWindow::loadFile(const QString& filePath)
{
  qDebug() << "Loading file:" << filePath;

  // Ensure widget is initialized first
  if (!m_litehtmlWidget) {
    qWarning() << "loadFile: litehtmlWidget is null, initializing...";
    initializeLitehtmlWidget();
    if (!m_litehtmlWidget) {
      qCritical() << "loadFile: Failed to initialize litehtmlWidget";
      emit documentLoaded(false);
      return;
    }
  }

  // Convert path to absolute if it's relative
  QString absoluteFilePath = filePath;
  QFileInfo fileInfo(filePath);
  if (!fileInfo.isAbsolute()) {
    absoluteFilePath = QDir::current().absoluteFilePath(filePath);
    fileInfo = QFileInfo(absoluteFilePath);
    qDebug() << "Converted relative path to absolute:" << absoluteFilePath;
  }

  // Check if the file exists and is readable
  if (!fileInfo.exists()) {
    qWarning() << "File does not exist:" << absoluteFilePath;
    QString errorHtml = QString("<!DOCTYPE html><html><body><h1>Error</h1><p>File does not exist: %1</p></body></html>")
      .arg(absoluteFilePath);
    m_litehtmlWidget->loadHtml(errorHtml);
    emit documentLoaded(false);
    return;
  }

  if (!fileInfo.isReadable()) {
    qWarning() << "File is not readable:" << absoluteFilePath;
    QString errorHtml = QString("<!DOCTYPE html><html><body><h1>Error</h1><p>File is not readable: %1</p></body></html>")
      .arg(absoluteFilePath);
    m_litehtmlWidget->loadHtml(errorHtml);
    emit documentLoaded(false);
    return;
  }

  // Read the file content
  QFile file(absoluteFilePath);
  if (!file.open(QIODevice::ReadOnly)) {
    qWarning() << "Failed to open file:" << absoluteFilePath << "Error:" << file.errorString();
    QString errorHtml = QString("<!DOCTYPE html><html><body><h1>Error</h1><p>Failed to open file: %1</p><p>Error: %2</p></body></html>")
      .arg(absoluteFilePath)
      .arg(file.errorString());
    m_litehtmlWidget->loadHtml(errorHtml);
    emit documentLoaded(false);
    return;
  }

  // Read the content - use binary mode to avoid text conversion issues
  QByteArray fileData = file.readAll();
  file.close();

  if (fileData.isEmpty()) {
    qWarning() << "File is empty:" << absoluteFilePath;
    QString errorHtml = QString("<!DOCTYPE html><html><body><h1>Error</h1><p>File is empty: %1</p></body></html>")
      .arg(absoluteFilePath);
    m_litehtmlWidget->loadHtml(errorHtml);
    emit documentLoaded(false);
    return;
  }

  // Convert to string with proper UTF-8 handling
  QString htmlContent = QString::fromUtf8(fileData);

  // Log the content for debugging
  qDebug() << "HTML content size:" << htmlContent.size() << "bytes";
  qDebug() << "First 100 chars of content:" << htmlContent.left(100).replace('\n', "\\n");

  // Get the base URL for relative paths (the directory containing the HTML file)
  QString baseUrl = QUrl::fromLocalFile(fileInfo.absolutePath()).toString();
  qDebug() << "Base URL for relative paths:" << baseUrl;

  // In debug mode, update the text editor
  if (m_debugMode) {
    QPlainTextEdit* htmlEditor = findChild<QPlainTextEdit*>();
    if (htmlEditor) {
      htmlEditor->setPlainText(htmlContent);
    }
  }

  // Load the HTML content with base URL for proper relative path resolution
  m_litehtmlWidget->loadHtml(htmlContent, baseUrl);
}

void MainWindow::setRenderSize(const QSize& size)
{
  qDebug() << "Setting render size to:" << size;
  m_renderSize = size;

  // Update the widget size if it exists
  if (m_litehtmlWidget) {
    m_litehtmlWidget->setMinimumSize(size.width() / 2, size.height() / 2);
    m_litehtmlWidget->resize(size);
  }
}

bool MainWindow::exportToSvg(const QString& filePath)
{
  if (!m_litehtmlWidget) {
    qWarning() << "Cannot export to SVG: litehtmlWidget is null";
    return false;
  }

  // Ensure the target directory exists
  QFileInfo fileInfo(filePath);
  QDir dir = fileInfo.dir();
  if (!dir.exists()) {
    if (!dir.mkpath(".")) {
      qWarning() << "Failed to create directory for SVG export:" << dir.path();
      return false;
    }
  }

  // Create SVG generator
  QSvgGenerator generator;
  generator.setFileName(filePath);

  // Get actual document size from the widget
  QSize documentSize = m_litehtmlWidget->documentSize();
  QSize widgetSize = m_litehtmlWidget->size();

  // Use custom render size if set, or document size, or widget size as fallback
  QSize exportSize;
  if (m_renderSize.isValid()) {
    exportSize = m_renderSize;
  } else if (documentSize.isValid() && documentSize.width() > 0 && documentSize.height() > 0) {
    exportSize = documentSize;
  } else {
    exportSize = widgetSize;
  }

  qDebug() << "SVG Export - Document size:" << documentSize << "Widget size:" << widgetSize << "Export size:" << exportSize;

  generator.setSize(exportSize);
  generator.setViewBox(QRect(0, 0, exportSize.width(), exportSize.height()));
  generator.setTitle(windowTitle());
  generator.setDescription("Generated by Qlith Pro");

  // Render to SVG
  QPainter painter;
  if (!painter.begin(&generator)) {
    qWarning() << "Failed to start painting to SVG file:" << filePath;
    return false;
  }

  // Apply appropriate scaling
  if (m_renderSize.isValid() && documentSize.isValid() && documentSize.width() > 0 && documentSize.height() > 0) {
    // Scale based on document size while maintaining aspect ratio
    double scaleX = (double)exportSize.width() / documentSize.width();
    double scaleY = (double)exportSize.height() / documentSize.height();

    // Option 1: Use the minimum scale factor to fit while preserving aspect ratio
    double scale = qMin(scaleX, scaleY);
    painter.scale(scale, scale);

    // Center the content
    if (scaleX > scaleY) {
      double offsetX = (exportSize.width() - documentSize.width() * scale) / (2 * scale);
      painter.translate(offsetX, 0);
    } else {
      double offsetY = (exportSize.height() - documentSize.height() * scale) / (2 * scale);
      painter.translate(0, offsetY);
    }
  }

  // Let the widget render into the painter
  m_litehtmlWidget->render(&painter);

  painter.end();

  qInfo() << "Exported SVG to:" << filePath;
  return true;
}

bool MainWindow::exportToPng(const QString& filePath)
{
  if (!m_litehtmlWidget) {
    qWarning() << "Cannot export to PNG: litehtmlWidget is null";
    return false;
  }

  qDebug() << "exportToPng: Starting PNG export to" << filePath;

  // Get sizes
  QSize documentSize = m_litehtmlWidget->documentSize();
  QSize widgetSize = m_litehtmlWidget->size();

  qDebug() << "Widget size:" << widgetSize;
  qDebug() << "Document size:" << documentSize;
  qDebug() << "Requested render size:" << m_renderSize;

  // Ensure the target directory exists
  QFileInfo fileInfo(filePath);
  QDir dir = fileInfo.dir();
  if (!dir.exists()) {
    if (!dir.mkpath(".")) {
      qWarning() << "Failed to create directory for PNG export:" << dir.path();
      return false;
    }
  }

  // Determine the export size
  QSize exportSize;
  if (m_renderSize.isValid()) {
    exportSize = m_renderSize;
  } else if (documentSize.isValid() && documentSize.width() > 0 && documentSize.height() > 0) {
    exportSize = documentSize;
  } else if (widgetSize.isValid() && widgetSize.width() > 0 && widgetSize.height() > 0) {
    exportSize = widgetSize;
  } else {
    exportSize = QSize(800, 600); // Default size if all else fails
  }

  qDebug() << "Using export size:" << exportSize;

  // Create a pixmap with the export size
  QPixmap pixmap(exportSize);
  pixmap.fill(Qt::white);

  // Create a painter for the pixmap
  QPainter painter(&pixmap);

  // Apply appropriate scaling
  if (documentSize.isValid() && documentSize.width() > 0 && documentSize.height() > 0) {
    // Scale based on document size while maintaining aspect ratio
    double scaleX = (double)exportSize.width() / documentSize.width();
    double scaleY = (double)exportSize.height() / documentSize.height();

    // Option 1: Use the minimum scale factor to fit while preserving aspect ratio
    double scale = qMin(scaleX, scaleY);
    painter.scale(scale, scale);

    // Center the content
    if (scaleX > scaleY) {
      double offsetX = (exportSize.width() - documentSize.width() * scale) / (2 * scale);
      painter.translate(offsetX, 0);
    } else {
      double offsetY = (exportSize.height() - documentSize.height() * scale) / (2 * scale);
      painter.translate(0, offsetY);
    }

    qDebug() << "Applied scale:" << scale << "with centering";
  }

  // Let the widget render into the painter
  qDebug() << "Rendering widget to pixmap";
  m_litehtmlWidget->render(&painter);
  painter.end();

  // Save to PNG
  qDebug() << "Saving pixmap to PNG file:" << filePath;
  bool result = pixmap.save(filePath, "PNG");
  if (result) {
    qInfo() << "Successfully exported PNG to:" << filePath;
  } else {
    qWarning() << "Failed to save PNG to:" << filePath;
  }

  return result;
}

void MainWindow::onDocumentLoaded(bool success)
{
  qDebug() << "MainWindow::onDocumentLoaded - Success:" << success;

  // Additional document loading logic could go here

  // Forward the signal
  emit documentLoaded(success);
}
</file>

<file path="affinetransform.cpp">
#include "affinetransform.h"

#define    _USE_MATH_DEFINES
#include <iostream>
#include <cmath>
#include <string>

#include <cstdio>

  //#include <cmath>
  #include <iostream>

/*#include "config.h"
#include "AffineTransform.h"

#include "FloatConversion.h"
#include "FloatQuad.h"
#include "FloatRect.h"
#include "IntRect.h"

#include <wtf/MathExtras.h>*/

#include "floatquad.h"


#include "common.h"

using namespace std;

static void affineTransformDecompose(const AffineTransform& matrix, double sr[9])
{
    AffineTransform m(matrix);

    // Compute scaling factors
    double sx = matrix.xScale();
    double sy = matrix.yScale();

    // Compute cross product of transformed unit vectors. If negative,
    // one axis was flipped.
    if (m.a() * m.d() - m.c() * m.b() < 0.0) {
        // Flip axis with minimum unit vector dot product
        if (m.a() < m.d())
            sx = -sx;
        else
            sy = -sy;
    }

    // Remove scale from matrix
    m.scale(1.0 / sx, 1.0 / sy);

    // Compute rotation
    double angle = atan2(m.b(), m.a());

    // Remove rotation from matrix
    m.rotate(rad2deg(-angle));

    // Return results
    sr[0] = sx;
    sr[1] = sy;
    sr[2] = angle;
    sr[3] = m.a();
    sr[4] = m.b();
    sr[5] = m.c();
    sr[6] = m.d();
    sr[7] = m.e();
    sr[8] = m.f();
}

static void affineTransformCompose(AffineTransform& m, const double sr[9])
{
    m.setA(sr[3]);
    m.setB(sr[4]);
    m.setC(sr[5]);
    m.setD(sr[6]);
    m.setE(sr[7]);
    m.setF(sr[8]);
    m.rotate(rad2deg(sr[2]));
    m.scale(sr[0], sr[1]);
}

AffineTransform::AffineTransform()
{
    setMatrix(1, 0, 0, 1, 0, 0);
}

AffineTransform::AffineTransform(double a, double b, double c, double d, double e, double f)
{
    setMatrix(a, b, c, d, e, f);
}

void AffineTransform::makeIdentity()
{
    setMatrix(1, 0, 0, 1, 0, 0);
}

void AffineTransform::setMatrix(double a, double b, double c, double d, double e, double f)
{
    m_transform[0] = a;
    m_transform[1] = b;
    m_transform[2] = c;
    m_transform[3] = d;
    m_transform[4] = e;
    m_transform[5] = f;
}

bool AffineTransform::isIdentity() const
{
    return (m_transform[0] == 1 && m_transform[1] == 0
         && m_transform[2] == 0 && m_transform[3] == 1
         && m_transform[4] == 0 && m_transform[5] == 0);
}

double AffineTransform::xScale() const
{
    return sqrt(m_transform[0] * m_transform[0] + m_transform[1] * m_transform[1]);
}

double AffineTransform::yScale() const
{
    return sqrt(m_transform[2] * m_transform[2] + m_transform[3] * m_transform[3]);
}

double AffineTransform::det() const
{
    return m_transform[0] * m_transform[3] - m_transform[1] * m_transform[2];
}

bool AffineTransform::isInvertible() const
{
    return det() != 0.0;
}

AffineTransform AffineTransform::inverse() const
{
    double determinant = det();
    if (determinant == 0.0)
        return AffineTransform();

    AffineTransform result;
    if (isIdentityOrTranslation()) {
        result.m_transform[4] = -m_transform[4];
        result.m_transform[5] = -m_transform[5];
        return result;
    }

    result.m_transform[0] = m_transform[3] / determinant;
    result.m_transform[1] = -m_transform[1] / determinant;
    result.m_transform[2] = -m_transform[2] / determinant;
    result.m_transform[3] = m_transform[0] / determinant;
    result.m_transform[4] = (m_transform[2] * m_transform[5]
                           - m_transform[3] * m_transform[4]) / determinant;
    result.m_transform[5] = (m_transform[1] * m_transform[4]
                           - m_transform[0] * m_transform[5]) / determinant;

    return result;
}

AffineTransform& AffineTransform::multiply(const AffineTransform& other)
{
    return (*this) *= other;
}

AffineTransform& AffineTransform::multLeft(const AffineTransform& other)
{
    AffineTransform trans;

    trans.m_transform[0] = other.m_transform[0] * m_transform[0] + other.m_transform[1] * m_transform[2];
    trans.m_transform[1] = other.m_transform[0] * m_transform[1] + other.m_transform[1] * m_transform[3];
    trans.m_transform[2] = other.m_transform[2] * m_transform[0] + other.m_transform[3] * m_transform[2];
    trans.m_transform[3] = other.m_transform[2] * m_transform[1] + other.m_transform[3] * m_transform[3];
    trans.m_transform[4] = other.m_transform[4] * m_transform[0] + other.m_transform[5] * m_transform[2] + m_transform[4];
    trans.m_transform[5] = other.m_transform[4] * m_transform[1] + other.m_transform[5] * m_transform[3] + m_transform[5];

    setMatrix(trans.m_transform);
    return *this;
}

AffineTransform& AffineTransform::rotate(double a)
{
    // angle is in degree. Switch to radian
    a = deg2rad(a);
    double cosAngle = cos(a);
    double sinAngle = sin(a);
    AffineTransform rot(cosAngle, sinAngle, -sinAngle, cosAngle, 0, 0);

    multLeft(rot);
    return *this;
}

AffineTransform& AffineTransform::scale(double s)
{
    return scale(s, s);
}

AffineTransform& AffineTransform::scale(double sx, double sy)
{
    m_transform[0] *= sx;
    m_transform[1] *= sx;
    m_transform[2] *= sy;
    m_transform[3] *= sy;
    return *this;
}

// *this = *this * translation
AffineTransform& AffineTransform::translate(double tx, double ty)
{
    if (isIdentityOrTranslation()) {
        m_transform[4] += tx;
        m_transform[5] += ty;
        return *this;
    }

    m_transform[4] += tx * m_transform[0] + ty * m_transform[2];
    m_transform[5] += tx * m_transform[1] + ty * m_transform[3];
    return *this;
}

// *this = translation * *this
AffineTransform& AffineTransform::translateRight(double tx, double ty)
{
    m_transform[4] += tx;
    m_transform[5] += ty;
    return *this;
}

AffineTransform& AffineTransform::scaleNonUniform(double sx, double sy)
{
    return scale(sx, sy);
}

AffineTransform& AffineTransform::rotateFromVector(double x, double y)
{
    return rotate(rad2deg(atan2(y, x)));
}

AffineTransform& AffineTransform::flipX()
{
    return scale(-1, 1);
}

AffineTransform& AffineTransform::flipY()
{
    return scale(1, -1);
}

AffineTransform& AffineTransform::shear(double sx, double sy)
{
    double a = m_transform[0];
    double b = m_transform[1];

    m_transform[0] += sy * m_transform[2];
    m_transform[1] += sy * m_transform[3];
    m_transform[2] += sx * a;
    m_transform[3] += sx * b;

    return *this;
}

AffineTransform& AffineTransform::skew(double angleX, double angleY)
{
    return shear(tan(deg2rad(angleX)), tan(deg2rad(angleY)));
}

AffineTransform& AffineTransform::skewX(double angle)
{
    return shear(tan(deg2rad(angle)), 0);
}

AffineTransform& AffineTransform::skewY(double angle)
{
    return shear(0, tan(deg2rad(angle)));
}

AffineTransform makeMapBetweenRects(const FloatRect& source, const FloatRect& dest)
{
    AffineTransform transform;
    transform.translate(dest.x() - source.x(), dest.y() - source.y());
    transform.scale(dest.width() / source.width(), dest.height() / source.height());
    return transform;
}

void AffineTransform::map(double x, double y, double& x2, double& y2) const
{
    x2 = (m_transform[0] * x + m_transform[2] * y + m_transform[4]);
    y2 = (m_transform[1] * x + m_transform[3] * y + m_transform[5]);
}

IntPoint AffineTransform::mapPoint(const IntPoint& point) const
{
    double x2, y2;
    map(point.x(), point.y(), x2, y2);

    // Round the point.
    return IntPoint(lround(x2), lround(y2));
}

FloatPoint AffineTransform::mapPoint(const FloatPoint& point) const
{
    double x2, y2;
    map(point.x(), point.y(), x2, y2);

    return FloatPoint(narrowPrecisionToFloat(x2), narrowPrecisionToFloat(y2));
}

IntRect AffineTransform::mapRect(const IntRect &rect) const
{
    return enclosingIntRect(mapRect(FloatRect(rect)));
}

FloatRect AffineTransform::mapRect(const FloatRect& rect) const
{
    if (isIdentityOrTranslation()) {
        FloatRect mappedRect(rect);
        mappedRect.move(narrowPrecisionToFloat(m_transform[4]), narrowPrecisionToFloat(m_transform[5]));
        return mappedRect;
    }

    FloatQuad result;
    result.setP1(mapPoint(rect.location()));
    result.setP2(mapPoint(FloatPoint(rect.right(), rect.y())));
    result.setP3(mapPoint(FloatPoint(rect.right(), rect.bottom())));
    result.setP4(mapPoint(FloatPoint(rect.x(), rect.bottom())));
    return result.boundingBox();
}

FloatQuad AffineTransform::mapQuad(const FloatQuad& q) const
{
    if (isIdentityOrTranslation()) {
        FloatQuad mappedQuad(q);
        mappedQuad.move(narrowPrecisionToFloat(m_transform[4]), narrowPrecisionToFloat(m_transform[5]));
        return mappedQuad;
    }

    FloatQuad result;
    result.setP1(mapPoint(q.p1()));
    result.setP2(mapPoint(q.p2()));
    result.setP3(mapPoint(q.p3()));
    result.setP4(mapPoint(q.p4()));
    return result;
}

void AffineTransform::blend(const AffineTransform& from, double progress)
{
    double srA[9], srB[9];

    affineTransformDecompose(from, srA);
    affineTransformDecompose(*this, srB);

    // If x-axis of one is flipped, and y-axis of the other, convert to an unflipped rotation.
    if ((srA[0] < 0 && srB[1] < 0) || (srA[1] < 0 &&  srB[0] < 0)) {
        srA[0] = -srA[0];
        srA[1] = -srA[1];
        srA[2] += srA[2] < 0 ? piDouble : -piDouble;
    }

    // Don't rotate the long way around.
    srA[2] = fmod(srA[2], 2.0 * piDouble);
    srB[2] = fmod(srB[2], 2.0 * piDouble);

    if (fabs(srA[2] - srB[2]) > piDouble) {
        if (srA[2] > srB[2])
            srA[2] -= piDouble * 2.0;
        else
            srB[2] -= piDouble * 2.0;
    }

    for (int i = 0; i < 9; i++)
        srA[i] = srA[i] + progress * (srB[i] - srA[i]);

    affineTransformCompose(*this, srA);
}

TransformationMatrix AffineTransform::toTransformationMatrix() const
{
    return TransformationMatrix(m_transform[0], m_transform[1], m_transform[2],
                                m_transform[3], m_transform[4], m_transform[5]);
}
</file>

<file path="bitmapimage.cpp">
#include "bitmapimage.h"

#include "common.h"

#include "floatrect.h"
#include "imageobserver.h"
#include "intrect.h"
#include "mimetyperegistry.h"
//#include "PlatformString.h"
//#include "Timer.h"
//#include "CurrentTime.h"
//#include <wtf/CurrentTime.h>
//#include <wtf/Vector.h>

static int frameBytes(const IntSize& frameSize)
{
    return frameSize.width() * frameSize.height() * 4;
}

BitmapImage::BitmapImage(ImageObserver* observer)
    : Image(observer)
    , m_currentFrame(0)
    , m_frames(0)

    // TODO
    //, m_frameTimer(0)

    , m_repetitionCount(cAnimationNone)
    , m_repetitionCountStatus(Unknown)
    , m_repetitionsComplete(0)
    , m_desiredFrameStartTime(0)
    , m_isSolidColor(false)
    , m_checkedForSolidColor(false)
    , m_animationFinished(false)
    , m_allDataReceived(false)
    , m_haveSize(false)
    , m_sizeAvailable(false)
    , m_hasUniformFrameSize(true)
    , m_decodedSize(0)
    , m_haveFrameCount(false)
    , m_frameCount(0)
{
    initPlatformData();
}

BitmapImage::~BitmapImage()
{
    invalidatePlatformData();
    stopAnimation();
}

void BitmapImage::destroyDecodedData(bool destroyAll)
{
    int framesCleared = 0;
    const size_t clearBeforeFrame = destroyAll ? m_frames.size() : m_currentFrame;
    for (size_t i = 0; i < clearBeforeFrame; ++i) {
        // The underlying frame isn't actually changing (we're just trying to
        // save the memory for the framebuffer data), so we don't need to clear
        // the metadata.
        if (m_frames[i].clear(false))
          ++framesCleared;
    }

    destroyMetadataAndNotify(framesCleared);

    m_source.clear(destroyAll, clearBeforeFrame, data(), m_allDataReceived);
    return;
}

void BitmapImage::destroyDecodedDataIfNecessary(bool destroyAll)
{
    // Animated images >5MB are considered large enough that we'll only hang on
    // to one frame at a time.
    static const unsigned cLargeAnimationCutoff = 5242880;
    if (m_frames.size() * frameBytes(m_size) > cLargeAnimationCutoff)
        destroyDecodedData(destroyAll);
}

void BitmapImage::destroyMetadataAndNotify(int framesCleared)
{
    m_isSolidColor = false;
    invalidatePlatformData();

    const int deltaBytes = framesCleared * -frameBytes(m_size);
    m_decodedSize += deltaBytes;
    if (deltaBytes && imageObserver())
        imageObserver()->decodedSizeChanged(this, deltaBytes);
}

void BitmapImage::cacheFrame(size_t index)
{
    size_t numFrames = frameCount();
    ASSERT(m_decodedSize == 0 || numFrames > 1);

    if (m_frames.size() < numFrames)
        //m_frames.grow(numFrames);
        m_frames.reserve(numFrames);

    m_frames[index].m_frame = m_source.createFrameAtIndex(index);
    if (numFrames == 1 && m_frames[index].m_frame)
        checkForSolidColor();

    m_frames[index].m_haveMetadata = true;
    m_frames[index].m_isComplete = m_source.frameIsCompleteAtIndex(index);
    if (repetitionCount(false) != cAnimationNone)
        m_frames[index].m_duration = m_source.frameDurationAtIndex(index);
    m_frames[index].m_hasAlpha = m_source.frameHasAlphaAtIndex(index);

    const IntSize frameSize(index ? m_source.frameSizeAtIndex(index) : m_size);
    if (frameSize != m_size)
        m_hasUniformFrameSize = false;
    if (m_frames[index].m_frame) {
        const int deltaBytes = frameBytes(frameSize);
        m_decodedSize += deltaBytes;
        if (imageObserver())
            imageObserver()->decodedSizeChanged(this, deltaBytes);
    }
}

IntSize BitmapImage::size() const
{
    if (m_sizeAvailable && !m_haveSize) {
        m_size = m_source.size();
        m_haveSize = true;
    }
    return m_size;
}

IntSize BitmapImage::currentFrameSize() const
{
    if (!m_currentFrame || m_hasUniformFrameSize)
        return size();
    return m_source.frameSizeAtIndex(m_currentFrame);
}

bool BitmapImage::getHotSpot(IntPoint& hotSpot) const
{
    return m_source.getHotSpot(hotSpot);
}

bool BitmapImage::dataChanged(bool allDataReceived)
{
    // Because we're modifying the current frame, clear its (now possibly
    // inaccurate) metadata as well.
    destroyMetadataAndNotify((!m_frames.isEmpty() && m_frames[m_frames.size() - 1].clear(true)) ? 1 : 0);

    // Feed all the data we've seen so far to the image decoder.
    m_allDataReceived = allDataReceived;
    m_source.setData(data(), allDataReceived);

    // Clear the frame count.
    m_haveFrameCount = false;

    m_hasUniformFrameSize = true;

    // Image properties will not be available until the first frame of the file
    // reaches kCGImageStatusIncomplete.
    return isSizeAvailable();
}

String BitmapImage::filenameExtension() const
{
    return m_source.filenameExtension();
}

size_t BitmapImage::frameCount()
{
    if (!m_haveFrameCount) {
        m_haveFrameCount = true;
        m_frameCount = m_source.frameCount();
    }
    return m_frameCount;
}

bool BitmapImage::isSizeAvailable()
{
    if (m_sizeAvailable)
        return true;

    m_sizeAvailable = m_source.isSizeAvailable();

    return m_sizeAvailable;
}

NativeImagePtr BitmapImage::frameAtIndex(size_t index)
{
    if (index >= frameCount())
        return 0;

    if (index >= m_frames.size() || !m_frames[index].m_frame)
        cacheFrame(index);

    return m_frames[index].m_frame;
}

bool BitmapImage::frameIsCompleteAtIndex(size_t index)
{
    if (index >= frameCount())
        return true;

    if (index >= m_frames.size() || !m_frames[index].m_haveMetadata)
        cacheFrame(index);

    return m_frames[index].m_isComplete;
}

float BitmapImage::frameDurationAtIndex(size_t index)
{
    if (index >= frameCount())
        return 0;

    if (index >= m_frames.size() || !m_frames[index].m_haveMetadata)
        cacheFrame(index);

    return m_frames[index].m_duration;
}

bool BitmapImage::frameHasAlphaAtIndex(size_t index)
{
    if (index >= frameCount())
        return true;

    if (index >= m_frames.size() || !m_frames[index].m_haveMetadata)
        cacheFrame(index);

    return m_frames[index].m_hasAlpha;
}

int BitmapImage::repetitionCount(bool imageKnownToBeComplete)
{
    if ((m_repetitionCountStatus == Unknown) || ((m_repetitionCountStatus == Uncertain) && imageKnownToBeComplete)) {
        // Snag the repetition count.  If |imageKnownToBeComplete| is false, the
        // repetition count may not be accurate yet for GIFs; in this case the
        // decoder will default to cAnimationLoopOnce, and we'll try and read
        // the count again once the whole image is decoded.
        m_repetitionCount = m_source.repetitionCount();
        m_repetitionCountStatus = (imageKnownToBeComplete || m_repetitionCount == cAnimationNone) ? Certain : Uncertain;
    }
    return m_repetitionCount;
}

bool BitmapImage::shouldAnimate()
{
    return (repetitionCount(false) != cAnimationNone && !m_animationFinished && imageObserver());
}

void BitmapImage::startAnimation(bool catchUpIfNecessary)
{
    // TODO
    return;
    /*
    if (m_frameTimer || !shouldAnimate() || frameCount() <= 1)
        return;

    // If we aren't already animating, set now as the animation start time.
    const double time = currentTime();
    if (!m_desiredFrameStartTime)
        m_desiredFrameStartTime = time;

    // Don't advance the animation to an incomplete frame.
    size_t nextFrame = (m_currentFrame + 1) % frameCount();
    if (!m_allDataReceived && !frameIsCompleteAtIndex(nextFrame))
        return;

    // Don't advance past the last frame if we haven't decoded the whole image
    // yet and our repetition count is potentially unset.  The repetition count
    // in a GIF can potentially come after all the rest of the image data, so
    // wait on it.
    if (!m_allDataReceived && repetitionCount(false) == cAnimationLoopOnce && m_currentFrame >= (frameCount() - 1))
        return;

    // Determine time for next frame to start.  By ignoring paint and timer lag
    // in this calculation, we make the animation appear to run at its desired
    // rate regardless of how fast it's being repainted.
    const double currentDuration = frameDurationAtIndex(m_currentFrame);
    m_desiredFrameStartTime += currentDuration;

    // When an animated image is more than five minutes out of date, the
    // user probably doesn't care about resyncing and we could burn a lot of
    // time looping through frames below.  Just reset the timings.
    const double cAnimationResyncCutoff = 5 * 60;
    if ((time - m_desiredFrameStartTime) > cAnimationResyncCutoff)
        m_desiredFrameStartTime = time + currentDuration;

    // The image may load more slowly than it's supposed to animate, so that by
    // the time we reach the end of the first repetition, we're well behind.
    // Clamp the desired frame start time in this case, so that we don't skip
    // frames (or whole iterations) trying to "catch up".  This is a tradeoff:
    // It guarantees users see the whole animation the second time through and
    // don't miss any repetitions, and is closer to what other browsers do; on
    // the other hand, it makes animations "less accurate" for pages that try to
    // sync an image and some other resource (e.g. audio), especially if users
    // switch tabs (and thus stop drawing the animation, which will pause it)
    // during that initial loop, then switch back later.
    if (nextFrame == 0 && m_repetitionsComplete == 0 && m_desiredFrameStartTime < time)
        m_desiredFrameStartTime = time;

    if (!catchUpIfNecessary || time < m_desiredFrameStartTime) {
    // TODO
        // Haven't yet reached time for next frame to start; delay until then.
        //m_frameTimer = new Timer<BitmapImage>(this, &BitmapImage::advanceAnimation);
       // m_frameTimer->startOneShot(std::max(m_desiredFrameStartTime - time, 0.));
    } else {
        // We've already reached or passed the time for the next frame to start.
        // See if we've also passed the time for frames after that to start, in
        // case we need to skip some frames entirely.  Remember not to advance
        // to an incomplete frame.
        for (size_t frameAfterNext = (nextFrame + 1) % frameCount(); frameIsCompleteAtIndex(frameAfterNext); frameAfterNext = (nextFrame + 1) % frameCount()) {
            // Should we skip the next frame?
            double frameAfterNextStartTime = m_desiredFrameStartTime + frameDurationAtIndex(nextFrame);
            if (time < frameAfterNextStartTime)
                break;

            // Yes; skip over it without notifying our observers.
            if (!internalAdvanceAnimation(true))
                return;
            m_desiredFrameStartTime = frameAfterNextStartTime;
            nextFrame = frameAfterNext;
        }

        // Draw the next frame immediately.  Note that m_desiredFrameStartTime
        // may be in the past, meaning the next time through this function we'll
        // kick off the next advancement sooner than this frame's duration would
        // suggest.
        if (internalAdvanceAnimation(false)) {
            // The image region has been marked dirty, but once we return to our
            // caller, draw() will clear it, and nothing will cause the
            // animation to advance again.  We need to start the timer for the
            // next frame running, or the animation can hang.  (Compare this
            // with when advanceAnimation() is called, and the region is dirtied
            // while draw() is not in the callstack, meaning draw() gets called
            // to update the region and thus startAnimation() is reached again.)
            // NOTE: For large images with slow or heavily-loaded systems,
            // throwing away data as we go (see destroyDecodedData()) means we
            // can spend so much time re-decoding data above that by the time we
            // reach here we're behind again.  If we let startAnimation() run
            // the catch-up code again, we can get long delays without painting
            // as we race the timer, or even infinite recursion.  In this
            // situation the best we can do is to simply change frames as fast
            // as possible, so force startAnimation() to set a zero-delay timer
            // and bail out if we're not caught up.
            startAnimation(false);
        }
    }*/
}

void BitmapImage::stopAnimation()
{
    // TODO

    // This timer is used to animate all occurrences of this image.  Don't invalidate
    // the timer unless all renderers have stopped drawing.
    /*delete m_frameTimer;
    m_frameTimer = 0;*/
}

void BitmapImage::resetAnimation()
{
    stopAnimation();
    m_currentFrame = 0;
    m_repetitionsComplete = 0;
    m_desiredFrameStartTime = 0;
    m_animationFinished = false;

    // For extremely large animations, when the animation is reset, we just throw everything away.
    destroyDecodedDataIfNecessary(true);
}

    // TODO
/*void BitmapImage::advanceAnimation(Timer<BitmapImage>*)
{
    internalAdvanceAnimation(false);
    // At this point the image region has been marked dirty, and if it's
    // onscreen, we'll soon make a call to draw(), which will call
    // startAnimation() again to keep the animation moving.
}*/

bool BitmapImage::internalAdvanceAnimation(bool skippingFrames)
{
    // Stop the animation.
    stopAnimation();

    // See if anyone is still paying attention to this animation.  If not, we don't
    // advance and will remain suspended at the current frame until the animation is resumed.
    if (!skippingFrames && imageObserver()->shouldPauseAnimation(this))
        return false;

    ++m_currentFrame;
    bool advancedAnimation = true;
    bool destroyAll = false;
    if (m_currentFrame >= frameCount()) {
        ++m_repetitionsComplete;

        // Get the repetition count again.  If we weren't able to get a
        // repetition count before, we should have decoded the whole image by
        // now, so it should now be available.
        // Note that we don't need to special-case cAnimationLoopOnce here
        // because it is 0 (see comments on its declaration in ImageSource.h).
        if (repetitionCount(true) != cAnimationLoopInfinite && m_repetitionsComplete > m_repetitionCount) {
            m_animationFinished = true;
            m_desiredFrameStartTime = 0;
            --m_currentFrame;
            advancedAnimation = false;
        } else {
            m_currentFrame = 0;
            destroyAll = true;
        }
    }
    destroyDecodedDataIfNecessary(destroyAll);

    // We need to draw this frame if we advanced to it while not skipping, or if
    // while trying to skip frames we hit the last frame and thus had to stop.
    if (skippingFrames != advancedAnimation)
        imageObserver()->animationAdvanced(this);
    return advancedAnimation;
}
</file>

<file path="color.cpp">
#include "color.h"

//#include <math.h>
#include <cmath>
#include <fenv.h>

using namespace std;

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/qt/ColorQt.cpp
Color::Color(const QColor& c)
    : m_color(makeRGBA(c.red(), c.green(), c.blue(), c.alpha()))
{
    m_valid = c.isValid();
}

Color::operator QColor() const
{
    if (m_valid)
        return QColor(red(), green(), blue(), alpha());
    else
        return QColor();
}

//////////////////////////

//#if !COMPILER(MSVC)
const RGBA32 Color::black;
const RGBA32 Color::white;
const RGBA32 Color::darkGray;
const RGBA32 Color::gray;
const RGBA32 Color::lightGray;
const RGBA32 Color::transparent;
//#endif

static const RGBA32 lightenedBlack = 0xFF545454;
static const RGBA32 darkenedWhite = 0xFFABABAB;

RGBA32 makeRGB(int r, int g, int b)
{
    return 0xFF000000 | max(0, min(r, 255)) << 16 | max(0, min(g, 255)) << 8 | max(0, min(b, 255));
}

RGBA32 makeRGBA(int r, int g, int b, int a)
{
    return max(0, min(a, 255)) << 24 | max(0, min(r, 255)) << 16 | max(0, min(g, 255)) << 8 | max(0, min(b, 255));
}

static int colorFloatToRGBAByte(float f)
{
    // We use lroundf and 255 instead of nextafterf(256, 0) to match CG's rounding
    return max(0, min(static_cast<int>(lroundf(255.0f * f)), 255));
}

RGBA32 makeRGBA32FromFloats(float r, float g, float b, float a)
{
    return colorFloatToRGBAByte(a) << 24 | colorFloatToRGBAByte(r) << 16 | colorFloatToRGBAByte(g) << 8 | colorFloatToRGBAByte(b);
}

RGBA32 colorWithOverrideAlpha(RGBA32 color, float overrideAlpha)
{
    RGBA32 rgbOnly = color & 0x00FFFFFF;
    RGBA32 rgba = rgbOnly | colorFloatToRGBAByte(overrideAlpha) << 24;
    return rgba;
}

static double calcHue(double temp1, double temp2, double hueVal)
{
    if (hueVal < 0.0)
        hueVal++;
    else if (hueVal > 1.0)
        hueVal--;
    if (hueVal * 6.0 < 1.0)
        return temp1 + (temp2 - temp1) * hueVal * 6.0;
    if (hueVal * 2.0 < 1.0)
        return temp2;
    if (hueVal * 3.0 < 2.0)
        return temp1 + (temp2 - temp1) * (2.0 / 3.0 - hueVal) * 6.0;
    return temp1;
}

// Explanation of this algorithm can be found in the CSS3 Color Module
// specification at http://www.w3.org/TR/css3-color/#hsl-color with further
// explanation available at http://en.wikipedia.org/wiki/HSL_color_space

// all values are in the range of 0 to 1.0
RGBA32 makeRGBAFromHSLA(double hue, double saturation, double lightness, double alpha)
{
    const double scaleFactor = nextafter(256.0, 0.0);

    if (!saturation) {
        int greyValue = static_cast<int>(lightness * scaleFactor);
        return makeRGBA(greyValue, greyValue, greyValue, static_cast<int>(alpha * scaleFactor));
    }

    double temp2 = lightness < 0.5 ? lightness * (1.0 + saturation) : lightness + saturation - lightness * saturation;
    double temp1 = 2.0 * lightness - temp2;

    return makeRGBA(static_cast<int>(calcHue(temp1, temp2, hue + 1.0 / 3.0) * scaleFactor),
                    static_cast<int>(calcHue(temp1, temp2, hue) * scaleFactor),
                    static_cast<int>(calcHue(temp1, temp2, hue - 1.0 / 3.0) * scaleFactor),
                    static_cast<int>(alpha * scaleFactor));
}

RGBA32 makeRGBAFromCMYKA(float c, float m, float y, float k, float a)
{
    double colors = 1 - k;
    int r = static_cast<int>(nextafter(256, 0) * (colors * (1 - c)));
    int g = static_cast<int>(nextafter(256, 0) * (colors * (1 - m)));
    int b = static_cast<int>(nextafter(256, 0) * (colors * (1 - y)));
    return makeRGBA(r, g, b, static_cast<float>(nextafter(256, 0) * a));
}

// originally moved here from the CSS parser
bool Color::parseHexColor(const UChar* name, unsigned length, RGBA32& rgb)
{
    if (length != 3 && length != 6)
        return false;
    unsigned value = 0;
    for (unsigned i = 0; i < length; ++i) {
        if (!isASCIIHexDigit(name[i]))
            return false;
        value <<= 4;
        value |= toASCIIHexValue(name[i]);
    }
    if (length == 6) {
        rgb = 0xFF000000 | value;
        return true;
    }
    // #abc converts to #aabbcc
    rgb = 0xFF000000
        | (value & 0xF00) << 12 | (value & 0xF00) << 8
        | (value & 0xF0) << 8 | (value & 0xF0) << 4
        | (value & 0xF) << 4 | (value & 0xF);
    return true;
}

bool Color::parseHexColor(const String& name, RGBA32& rgb)
{
    //return parseHexColor(name.characters(), name.length(), rgb);
    return parseHexColor(name.toStdString().c_str(), name.length(), rgb);
}

int differenceSquared(const Color& c1, const Color& c2)
{
    int dR = c1.red() - c2.red();
    int dG = c1.green() - c2.green();
    int dB = c1.blue() - c2.blue();
    return dR * dR + dG * dG + dB * dB;
}

Color::Color(const String& name)
{
    if (name[0] == '#')
        //m_valid = parseHexColor(name.characters() + 1, name.length() - 1, m_color);
        m_valid = parseHexColor(name.toStdString().c_str() + 1, name.length() - 1, m_color);
    /*else
        setNamedColor(name);*/
}

Color::Color(const char* name)
{
    if (name[0] == '#')
        m_valid = parseHexColor(&name[1], m_color);
    else {
        /*const NamedColor* foundColor = findColor(name, strlen(name));
        m_color = foundColor ? foundColor->RGBValue : 0;
        m_color |= 0xFF000000;
        m_valid = foundColor;*/
    }
}

/*String Color::serialized() const
{
    if (alpha() == 0xFF)
        return String::format("#%02x%02x%02x", red(), green(), blue());

    // Match Gecko ("0.0" for zero, 5 decimals for anything else)
    if (!alpha())
        return String::format("rgba(%u, %u, %u, 0.0)", red(), green(), blue());

    return String::format("rgba(%u, %u, %u, %.5f)", red(), green(), blue(), alpha() / 255.0f);
}

String Color::name() const
{
    if (alpha() < 0xFF)
        return String::format("#%02X%02X%02X%02X", red(), green(), blue(), alpha());
    return String::format("#%02X%02X%02X", red(), green(), blue());
}

static inline const NamedColor* findNamedColor(const String& name)
{
    char buffer[64]; // easily big enough for the longest color name
    unsigned length = name.length();
    if (length > sizeof(buffer) - 1)
        return 0;
    for (unsigned i = 0; i < length; ++i) {
        UChar c = name[i].toLatin1();//name[i]
        if (!c || c > 0x7F)
            return 0;
        buffer[i] = toASCIILower(static_cast<char>(c));
    }
    buffer[length] = '\0';
    return findColor(buffer, length);
}

void Color::setNamedColor(const String& name)
{
    const NamedColor* foundColor = findNamedColor(name);
    m_color = foundColor ? foundColor->RGBValue : 0;
    m_color |= 0xFF000000;
    m_valid = foundColor;
}*/

Color Color::light() const
{
    // Hardcode this common case for speed.
    if (m_color == black)
        return lightenedBlack;

    const float scaleFactor = nextafterf(256.0f, 0.0f);

    float r, g, b, a;
    getRGBA(r, g, b, a);

    float v = max(r, max(g, b));

    if (v == 0.0f)
        // Lightened black with alpha.
        return Color(0x54, 0x54, 0x54, alpha());

    float multiplier = min(1.0f, v + 0.33f) / v;

    return Color(static_cast<int>(multiplier * r * scaleFactor),
                 static_cast<int>(multiplier * g * scaleFactor),
                 static_cast<int>(multiplier * b * scaleFactor),
                 alpha());
}

Color Color::dark() const
{
    // Hardcode this common case for speed.
    if (m_color == white)
        return darkenedWhite;

    const float scaleFactor = nextafterf(256.0f, 0.0f);

    float r, g, b, a;
    getRGBA(r, g, b, a);

    float v = max(r, max(g, b));
    float multiplier = max(0.0f, (v - 0.33f) / v);

    return Color(static_cast<int>(multiplier * r * scaleFactor),
                 static_cast<int>(multiplier * g * scaleFactor),
                 static_cast<int>(multiplier * b * scaleFactor),
                 alpha());
}

static int blendComponent(int c, int a)
{
    // We use white.
    float alpha = a / 255.0f;
    int whiteBlend = 255 - a;
    c -= whiteBlend;
    return static_cast<int>(c / alpha);
}

const int cStartAlpha = 153; // 60%
const int cEndAlpha = 204; // 80%;
const int cAlphaIncrement = 17; // Increments in between.

Color Color::blend(const Color& source) const
{
    if (!alpha() || !source.hasAlpha())
        return source;

    if (!source.alpha())
        return *this;

    int d = 255 * (alpha() + source.alpha()) - alpha() * source.alpha();
    int a = d / 255;
    int r = (red() * alpha() * (255 - source.alpha()) + 255 * source.alpha() * source.red()) / d;
    int g = (green() * alpha() * (255 - source.alpha()) + 255 * source.alpha() * source.green()) / d;
    int b = (blue() * alpha() * (255 - source.alpha()) + 255 * source.alpha() * source.blue()) / d;
    return Color(r, g, b, a);
}

Color Color::blendWithWhite() const
{
    // If the color contains alpha already, we leave it alone.
    if (hasAlpha())
        return *this;

    Color newColor;
    for (int alpha = cStartAlpha; alpha <= cEndAlpha; alpha += cAlphaIncrement) {
        // We have a solid color.  Convert to an equivalent color that looks the same when blended with white
        // at the current alpha.  Try using less transparency if the numbers end up being negative.
        int r = blendComponent(red(), alpha);
        int g = blendComponent(green(), alpha);
        int b = blendComponent(blue(), alpha);

        newColor = Color(r, g, b, alpha);

        if (r >= 0 && g >= 0 && b >= 0)
            break;
    }
    return newColor;
}

void Color::getRGBA(float& r, float& g, float& b, float& a) const
{
    r = red() / 255.0f;
    g = green() / 255.0f;
    b = blue() / 255.0f;
    a = alpha() / 255.0f;
}

void Color::getRGBA(double& r, double& g, double& b, double& a) const
{
    r = red() / 255.0;
    g = green() / 255.0;
    b = blue() / 255.0;
    a = alpha() / 255.0;
}

void Color::getHSL(double& hue, double& saturation, double& lightness) const
{
    // http://en.wikipedia.org/wiki/HSL_color_space. This is a direct copy of
    // the algorithm therein, although it's 360^o based and we end up wanting
    // [0...1) based. It's clearer if we stick to 360^o until the end.
    double r = static_cast<double>(red()) / 255.0;
    double g = static_cast<double>(green()) / 255.0;
    double b = static_cast<double>(blue()) / 255.0;
    double max = std::max(std::max(r, g), b);
    double min = std::min(std::min(r, g), b);

    if (max == min)
        hue = 0.0;
    else if (max == r)
        hue = (60.0 * ((g - b) / (max - min))) + 360.0;
    else if (max == g)
        hue = (60.0 * ((b - r) / (max - min))) + 120.0;
    else
        hue = (60.0 * ((r - g) / (max - min))) + 240.0;

    if (hue >= 360.0)
        hue -= 360.0;

    // makeRGBAFromHSLA assumes that hue is in [0...1).
    hue /= 360.0;

    lightness = 0.5 * (max + min);
    if (max == min)
        saturation = 0.0;
    else if (lightness <= 0.5)
        saturation = ((max - min) / (max + min));
    else
        saturation = ((max - min) / (2.0 - (max + min)));
}

Color colorFromPremultipliedARGB(unsigned pixelColor)
{
    RGBA32 rgba;

    if (unsigned alpha = (pixelColor & 0xFF000000) >> 24) {
        rgba = makeRGBA(((pixelColor & 0x00FF0000) >> 16) * 255 / alpha,
                        ((pixelColor & 0x0000FF00) >> 8) * 255 / alpha,
                         (pixelColor & 0x000000FF) * 255 / alpha,
                          alpha);
    } else
        rgba = pixelColor;

    return Color(rgba);
}

unsigned premultipliedARGBFromColor(const Color& color)
{
    unsigned pixelColor;

    if (unsigned alpha = color.alpha()) {
        pixelColor = alpha << 24 |
             ((color.red() * alpha  + 254) / 255) << 16 |
             ((color.green() * alpha  + 254) / 255) << 8 |
             ((color.blue() * alpha  + 254) / 255);
    } else
         pixelColor = color.rgb();

    return pixelColor;
}

////////////////////

/*
#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))

#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
#endif

// https://github.com/trevorlinton/webkit.js/blob/15306b5c540ccafc3be008225eafebd1932d356d/src/WebCoreDerived/ColorData.cpp#L42
enum
{
  TOTAL_KEYWORDS = 150,
  MIN_WORD_LENGTH = 3,
  MAX_WORD_LENGTH = 20,
  MIN_HASH_VALUE = 3,
  MAX_HASH_VALUE = 1055
};

class ColorDataHash
{
private:
  static inline unsigned int colordata_hash_function (const char *str, unsigned int len);
public:
  static const struct NamedColor *findColorImpl (const char *str, unsigned int len);
};


inline unsigned int
ColorDataHash::colordata_hash_function (register const char *str, register unsigned int len)
{
  static const unsigned short asso_values[] =
    {
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056,    5,    0,  105,
         0,    0,   30,   40,   40,   10,    0,    0,   15,   60,
         0,    5,  255,   40,    0,   10,   15,  130,  300,  215,
         5,    0,    0, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056, 1056,
      1056, 1056, 1056, 1056, 1056, 1056, 1056
    };
  register int hval = (int)len;

  switch (hval)
    {
      default:
        hval += asso_values[(unsigned char)str[19]];

      case 19:
        hval += asso_values[(unsigned char)str[18]];

      case 18:
        hval += asso_values[(unsigned char)str[17]];

      case 17:
        hval += asso_values[(unsigned char)str[16]];

      case 16:
        hval += asso_values[(unsigned char)str[15]];

      case 15:
        hval += asso_values[(unsigned char)str[14]];

      case 14:
        hval += asso_values[(unsigned char)str[13]];

      case 13:
        hval += asso_values[(unsigned char)str[12]];

      case 12:
        hval += asso_values[(unsigned char)str[11]];

      case 11:
        hval += asso_values[(unsigned char)str[10]+1];

      case 10:
        hval += asso_values[(unsigned char)str[9]];

      case 9:
        hval += asso_values[(unsigned char)str[8]];

      case 8:
        hval += asso_values[(unsigned char)str[7]];

      case 7:
        hval += asso_values[(unsigned char)str[6]];

      case 6:
        hval += asso_values[(unsigned char)str[5]];

      case 5:
        hval += asso_values[(unsigned char)str[4]];

      case 4:
        hval += asso_values[(unsigned char)str[3]];

      case 3:
        hval += asso_values[(unsigned char)str[2]];

      case 2:
        hval += asso_values[(unsigned char)str[1]];

      case 1:
        hval += asso_values[(unsigned char)str[0]];
        break;
    }
  return hval;
}

static const struct NamedColor wordlist[] =
  {
#line 145 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"red", 0xffff0000},
#line 57 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darkred", 0xff8b0000},
#line 162 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"tan", 0xffd2b48c},
#line 110 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"linen", 0xfffaf0e6},
#line 153 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"sienna", 0xffa0522d},
#line 84 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"indianred", 0xffcd5c5c},
#line 163 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"teal", 0xff008080},
#line 79 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"grey", 0xff808080},
#line 80 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"green", 0xff008000},
#line 78 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"gray", 0xff808080},
#line 50 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darkgrey", 0xffa9a9a9},
#line 51 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darkgreen", 0xff006400},
#line 30 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"beige", 0xfff5f5dc},
#line 131 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"orange", 0xffffa500},
#line 49 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darkgray", 0xffa9a9a9},
#line 132 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"orangered", 0xffff4500},
#line 87 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"khaki", 0xfff0e68c},
#line 151 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"seagreen", 0xff2e8b57},
#line 76 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"gold", 0xffffd700},
#line 55 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darkorange", 0xffff8c00},
#line 52 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darkkhaki", 0xffbdb76b},
#line 85 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"indigo", 0xff4b0082},
#line 77 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"goldenrod", 0xffdaa520},
#line 112 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"maroon", 0xff800000},
#line 74 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"gainsboro", 0xffdcdcdc},
#line 108 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lime", 0xff00ff00},
#line 81 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"greenyellow", 0xffadff2f},
#line 48 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darkgoldenrod", 0xffb8860b},
#line 158 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"slategrey", 0xff708090},
#line 157 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"slategray", 0xff708090},
#line 149 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"salmon", 0xfffa8072},
#line 59 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darkseagreen", 0xff8fbc8f},
#line 152 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"seashell", 0xfffff5ee},
#line 58 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darksalmon", 0xffe9967a},
#line 165 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"tomato", 0xffff6347},
#line 164 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"thistle", 0xffd8bfd8},
#line 62 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darkslategrey", 0xff2f4f4f},
#line 45 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"cyan", 0xff00ffff},
#line 72 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"forestgreen", 0xff228b22},
#line 68 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"dimgrey", 0xff696969},
#line 61 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darkslategray", 0xff2f4f4f},
#line 124 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"mistyrose", 0xffffe4e1},
#line 67 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"dimgray", 0xff696969},
#line 47 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darkcyan", 0xff008b8b},
#line 32 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"black", 0xff000000},
#line 111 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"magenta", 0xffff00ff},
#line 109 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"limegreen", 0xff32cd32},
#line 41 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"coral", 0xffff7f50},
#line 53 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darkmagenta", 0xff8b008b},
#line 29 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"azure", 0xfff0ffff},
#line 34 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"blue", 0xff0000ff},
#line 128 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"oldlace", 0xfffdf5e6},
#line 43 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"cornsilk", 0xfffff8dc},
#line 46 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darkblue", 0xff00008b},
#line 155 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"skyblue", 0xff87ceeb},
#line 70 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"firebrick", 0xffb22222},
#line 133 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"orchid", 0xffda70d6},
#line 97 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lightgrey", 0xffd3d3d3},
#line 98 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lightgreen", 0xff90ee90},
#line 107 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lightyellow", 0xffffffe0},
#line 96 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lightgray", 0xffd3d3d3},
#line 56 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darkorchid", 0xff9932cc},
#line 147 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"royalblue", 0xff4169e1},
#line 27 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"aqua", 0xff00ffff},
#line 161 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"steelblue", 0xff4682b4},
#line 31 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"bisque", 0xffffe4c4},
#line 44 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"crimson", 0xffdc143c},
#line 156 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"slateblue", 0xff6a5acd},
#line 69 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"dodgerblue", 0xff1e90ff},
#line 33 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"blanchedalmond", 0xffffebcd},
#line 101 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lightseagreen", 0xff20b2aa},
#line 105 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lightslategrey", 0xff778899},
#line 104 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lightslategray", 0xff778899},
#line 36 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"brown", 0xffa52a2a},
#line 100 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lightsalmon", 0xffffa07a},
#line 159 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"snow", 0xfffffafa},
#line 94 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lightcyan", 0xffe0ffff},
#line 146 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"rosybrown", 0xffbc8f8f},
#line 150 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"sandybrown", 0xfff4a460},
#line 60 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darkslateblue", 0xff483d8b},
#line 173 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"yellow", 0xffffff00},
#line 93 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lightcoral", 0xfff08080},
#line 123 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"mintcream", 0xfff5fffa},
#line 28 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"aquamarine", 0xff7fffd4},
#line 148 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"saddlebrown", 0xff8b4513},
#line 82 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"honeydew", 0xfff0fff0},
#line 141 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"pink", 0xffffc0cb},
#line 92 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lightblue", 0xffadd8e6},
#line 38 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"cadetblue", 0xff5f9ea0},
#line 170 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"wheat", 0xfff5deb3},
#line 90 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lawngreen", 0xff7cfc00},
#line 171 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"white", 0xffffffff},
#line 25 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"aliceblue", 0xfff0f8ff},
#line 40 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"chocolate", 0xffd2691e},
#line 174 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"yellowgreen", 0xff9acd32},
#line 125 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"moccasin", 0xffffe4b5},
#line 127 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"navy", 0xff000080},
#line 39 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"chartreuse", 0xff7fff00},
#line 86 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"ivory", 0xfffffff0},
#line 135 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"palegreen", 0xff98fb98},
#line 88 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lavender", 0xffe6e6fa},
#line 83 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"hotpink", 0xffff69b4},
#line 129 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"olive", 0xff808000},
#line 73 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"fuchsia", 0xffff00ff},
#line 117 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"mediumseagreen", 0xff3cb371},
#line 154 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"silver", 0xffc0c0c0},
#line 130 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"olivedrab", 0xff6b8e23},
#line 63 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darkturquoise", 0xff00ced1},
#line 167 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"turquoise", 0xff40e0d0},
#line 168 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"violet", 0xffee82ee},
#line 169 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"violetred", 0xffd02090},
#line 64 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darkviolet", 0xff9400d3},
#line 134 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"palegoldenrod", 0xffeee8aa},
#line 172 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"whitesmoke", 0xfff5f5f5},
#line 160 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"springgreen", 0xff00ff7f},
#line 37 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"burlywood", 0xffdeb887},
#line 140 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"peru", 0xffcd853f},
#line 71 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"floralwhite", 0xfffffaf0},
#line 99 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lightpink", 0xffffb6c1},
#line 54 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"darkolivegreen", 0xff556b2f},
#line 75 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"ghostwhite", 0xfff8f8ff},
#line 114 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"mediumblue", 0xff0000cd},
#line 115 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"mediumorchid", 0xffba55d3},
#line 106 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lightsteelblue", 0xffb0c4de},
#line 103 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lightslateblue", 0xff8470ff},
#line 166 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"transparent", 0x00000000},
#line 66 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"deepskyblue", 0xff00bfff},
#line 102 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lightskyblue", 0xff87cefa},
#line 95 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lightgoldenrodyellow", 0xfffafad2},
#line 142 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"plum", 0xffdda0dd},
#line 113 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"mediumaquamarine", 0xff66cdaa},
#line 118 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"mediumslateblue", 0xff7b68ee},
#line 35 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"blueviolet", 0xff8a2be2},
#line 122 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"midnightblue", 0xff191970},
#line 65 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"deeppink", 0xffff1493},
#line 91 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lemonchiffon", 0xfffffacd},
#line 26 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"antiquewhite", 0xfffaebd7},
#line 136 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"paleturquoise", 0xffafeeee},
#line 143 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"powderblue", 0xffb0e0e6},
#line 126 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"navajowhite", 0xffffdead},
#line 119 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"mediumspringgreen", 0xff00fa9a},
#line 42 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"cornflowerblue", 0xff6495ed},
#line 137 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"palevioletred", 0xffdb7093},
#line 121 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"mediumvioletred", 0xffc71585},
#line 144 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"purple", 0xff800080},
#line 89 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"lavenderblush", 0xfffff0f5},
#line 120 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"mediumturquoise", 0xff48d1cc},
#line 139 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"peachpuff", 0xffffdab9},
#line 116 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"mediumpurple", 0xff9370db},
#line 138 "/Tint/webkit.js/tools/../deps/WebKit/Source/WebCore/platform/ColorData.gperf"
    {"papayawhip", 0xffffefd5}
  };

static const short lookup[] =
  {
     -1,  -1,  -1,   0,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,   1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,   2,  -1,  -1,  -1,  -1,  -1,  -1,
      3,   4,  -1,  -1,   5,  -1,  -1,  -1,  -1,   6,
     -1,  -1,  -1,  -1,   7,   8,  -1,  -1,  -1,   9,
     -1,  -1,  -1,  10,  11,  12,  13,  -1,  14,  15,
     16,  -1,  -1,  17,  18,  19,  -1,  -1,  -1,  20,
     -1,  21,  -1,  -1,  22,  -1,  -1,  -1,  -1,  -1,
     -1,  23,  -1,  -1,  24,  -1,  -1,  -1,  -1,  25,
     -1,  26,  -1,  27,  28,  -1,  -1,  -1,  -1,  29,
     -1,  30,  31,  32,  -1,  -1,  -1,  -1,  -1,  -1,
     33,  34,  35,  36,  37,  -1,  38,  39,  40,  41,
     -1,  -1,  42,  43,  -1,  -1,  -1,  -1,  -1,  -1,
     44,  -1,  45,  -1,  46,  47,  48,  -1,  -1,  -1,
     49,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  50,
     -1,  -1,  51,  52,  -1,  -1,  -1,  -1,  53,  -1,
     -1,  -1,  54,  -1,  55,  -1,  56,  -1,  -1,  57,
     58,  59,  -1,  -1,  60,  61,  -1,  -1,  -1,  62,
     -1,  -1,  -1,  -1,  63,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  64,  -1,  65,  66,  -1,  67,
     68,  -1,  -1,  -1,  69,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  70,  71,
     -1,  -1,  -1,  -1,  72,  73,  -1,  -1,  -1,  -1,
     -1,  74,  -1,  -1,  75,  -1,  -1,  -1,  -1,  76,
     -1,  -1,  -1,  -1,  77,  78,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  79,  -1,  -1,  80,  -1,  -1,  -1,
     81,  -1,  -1,  -1,  82,  83,  84,  -1,  85,  86,
     -1,  -1,  -1,  -1,  87,  -1,  -1,  -1,  -1,  88,
     89,  -1,  -1,  -1,  90,  91,  -1,  -1,  -1,  92,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  93,  -1,  94,  -1,  95,  96,
     -1,  -1,  -1,  -1,  -1,  97,  -1,  -1,  -1,  -1,
     98,  -1,  -1,  -1,  99,  -1,  -1,  -1, 100,  -1,
     -1,  -1, 101,  -1,  -1, 102,  -1, 103,  -1, 104,
     -1, 105,  -1,  -1, 106,  -1,  -1,  -1, 107, 108,
     -1, 109,  -1,  -1, 110,  -1,  -1,  -1,  -1,  -1,
    111,  -1,  -1, 112,  -1, 113,  -1,  -1,  -1,  -1,
     -1, 114,  -1,  -1,  -1,  -1,  -1,  -1,  -1, 115,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, 116,
     -1, 117,  -1,  -1, 118,  -1,  -1,  -1,  -1, 119,
    120,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1, 121,  -1,  -1,  -1,  -1,
     -1,  -1, 122,  -1, 123,  -1,  -1,  -1,  -1, 124,
     -1, 125,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1, 126,  -1,  -1,  -1,  -1,  -1, 127,  -1,  -1,
    128,  -1,  -1,  -1, 129,  -1,  -1,  -1,  -1,  -1,
     -1, 130,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1, 131,  -1,  -1,  -1,  -1,
    132,  -1, 133,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, 134,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1, 135,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1, 136,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, 137,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    138,  -1,  -1,  -1,  -1,  -1, 139, 140,  -1, 141,
     -1,  -1,  -1, 142,  -1,  -1,  -1,  -1,  -1,  -1,
    143,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1, 144,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, 145,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1, 146,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, 147,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1, 148,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1, 149
  };

const struct NamedColor *
ColorDataHash::findColorImpl (register const char *str, register unsigned int len)
{
  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      register int key = colordata_hash_function (str, len);

      if (key <= MAX_HASH_VALUE && key >= 0)
        {
          register int index = lookup[key];

          if (index >= 0)
            {
              register const char *s = wordlist[index].name;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1) && s[len] == '\0')
                return &wordlist[index];
            }
        }
    }
  return 0;
}

const struct NamedColor* findColor(const char* str, unsigned int len)
{
    return ColorDataHash::findColorImpl(str, len);
}*/
</file>

<file path="common.cpp">
// this_file: qlith-pro/src/common.cpp
#include "qlith/common.h"

#include "litehtml.h"
#include "qlith/color.h"

////////////////////////////////

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/GraphicsTypes.cpp

static const char* const compositeOperatorNames[] = {
    "clear",
    "copy",
    "source-over",
    "source-in",
    "source-out",
    "source-atop",
    "destination-over",
    "destination-in",
    "destination-out",
    "destination-atop",
    "xor",
    "darker",
    "highlight",
    "lighter"
};
const int numCompositeOperatorNames = sizeof(compositeOperatorNames) / sizeof(compositeOperatorNames[0]);

bool parseCompositeOperator(const String& s, CompositeOperator& op)
{
    for (int i = 0; i < numCompositeOperatorNames; i++)
        if (s == compositeOperatorNames[i]) {
            op = static_cast<CompositeOperator>(i);
            return true;
        }
    return false;
}

String compositeOperatorName(CompositeOperator op)
{
    ASSERT(op >= 0);
    ASSERT(op < numCompositeOperatorNames);
    return compositeOperatorNames[op];
}

bool parseLineCap(const String& s, LineCap& cap)
{
    if (s == "butt") {
        cap = ButtCap;
        return true;
    }
    if (s == "round") {
        cap = RoundCap;
        return true;
    }
    if (s == "square") {
        cap = SquareCap;
        return true;
    }
    return false;
}

String lineCapName(LineCap cap)
{
    ASSERT(cap >= 0);
    ASSERT(cap < 3);
    const char* const names[3] = { "butt", "round", "square" };
    return names[cap];
}

bool parseLineJoin(const String& s, LineJoin& join)
{
    if (s == "miter") {
        join = MiterJoin;
        return true;
    }
    if (s == "round") {
        join = RoundJoin;
        return true;
    }
    if (s == "bevel") {
        join = BevelJoin;
        return true;
    }
    return false;
}

String lineJoinName(LineJoin join)
{
    ASSERT(join >= 0);
    ASSERT(join < 3);
    const char* const names[3] = { "miter", "round", "bevel" };
    return names[join];
}

String textAlignName(TextAlign align)
{
    ASSERT(align >= 0);
    ASSERT(align < 5);
    const char* const names[5] = { "start", "end", "left", "center", "right" };
    return names[align];
}

bool parseTextAlign(const String& s, TextAlign& align)
{
    if (s == "start") {
        align = StartTextAlign;
        return true;
    }
    if (s == "end") {
        align = EndTextAlign;
        return true;
    }
    if (s == "left") {
        align = LeftTextAlign;
        return true;
    }
    if (s == "center") {
        align = CenterTextAlign;
        return true;
    }
    if (s == "right") {
        align = RightTextAlign;
        return true;
    }
    return false;
}

String textBaselineName(TextBaseline baseline)
{
    ASSERT(baseline >= 0);
    ASSERT(baseline < 6);
    const char* const names[6] = { "alphabetic", "top", "middle", "bottom", "ideographic", "hanging" };
    return names[baseline];
}

bool parseTextBaseline(const String& s, TextBaseline& baseline)
{
    if (s == "alphabetic") {
        baseline = AlphabeticTextBaseline;
        return true;
    }
    if (s == "top") {
        baseline = TopTextBaseline;
        return true;
    }
    if (s == "middle") {
        baseline = MiddleTextBaseline;
        return true;
    }
    if (s == "bottom") {
        baseline = BottomTextBaseline;
        return true;
    }
    if (s == "ideographic") {
        baseline = IdeographicTextBaseline;
        return true;
    }
    if (s == "hanging") {
        baseline = HangingTextBaseline;
        return true;
    }
    return false;
}

Color toColor(const litehtml::web_color &clr) {
  return Color(clr.red,clr.green,clr.blue,clr.alpha);
}
</file>

<file path="contextshadow.cpp">
#include "contextshadow.h"

/*#include "config.h"
#include "ContextShadow.h"

#include <wtf/MathExtras.h>
#include <wtf/Noncopyable.h>

using WTF::min;
using WTF::max;*/

ContextShadow::ContextShadow()
    : m_type(NoShadow)
    , m_blurDistance(0)
{
}

ContextShadow::ContextShadow(const Color& color, float radius, const FloatSize& offset)
    : m_color(color)
    , m_blurDistance(round(radius))
    , m_offset(offset)
{
    // See comments in http://webkit.org/b/40793, it seems sensible
    // to follow Skia's limit of 128 pixels of blur radius
    m_blurDistance = std::min(m_blurDistance, 128);

    // The type of shadow is decided by the blur radius, shadow offset, and shadow color.
    if (!m_color.isValid() || !color.alpha()) {
        // Can't paint the shadow with invalid or invisible color.
        m_type = NoShadow;
    } else if (radius > 0) {
        // Shadow is always blurred, even the offset is zero.
        m_type = BlurShadow;
    } else if (!m_offset.width() && !m_offset.height()) {
        // Without blur and zero offset means the shadow is fully hidden.
        m_type = NoShadow;
    } else {
        m_type = SolidShadow;
    }
}

void ContextShadow::clear()
{
    m_type = NoShadow;
    m_color = Color();
    m_blurDistance = 0;
    m_offset = FloatSize();
}

// Instead of integer division, we use 17.15 for fixed-point division.
static const int BlurSumShift = 15;

// Check http://www.w3.org/TR/SVG/filters.html#feGaussianBlur.
// As noted in the SVG filter specification, running box blur 3x
// approximates a real gaussian blur nicely.

void ContextShadow::blurLayerImage(unsigned char* imageData, const IntSize& size, int rowStride)
{
    int channels[4] = { 3, 0, 1, 3 };
    int d = std::max(2, static_cast<int>(floorf((2 / 3.f) * m_blurDistance)));
    int dmax = d >> 1;
    int dmin = dmax - 1 + (d & 1);
    if (dmin < 0)
        dmin = 0;

    // Two stages: horizontal and vertical
    for (int k = 0; k < 2; ++k) {

        unsigned char* pixels = imageData;
        int stride = (!k) ? 4 : rowStride;
        int delta = (!k) ? rowStride : 4;
        int jfinal = (!k) ? size.height() : size.width();
        int dim = (!k) ? size.width() : size.height();

        for (int j = 0; j < jfinal; ++j, pixels += delta) {

            // For each step, we blur the alpha in a channel and store the result
            // in another channel for the subsequent step.
            // We use sliding window algorithm to accumulate the alpha values.
            // This is much more efficient than computing the sum of each pixels
            // covered by the box kernel size for each x.

            for (int step = 0; step < 3; ++step) {
                int side1 = (!step) ? dmin : dmax;
                int side2 = (step == 1) ? dmin : dmax;
                int pixelCount = side1 + 1 + side2;
                int invCount = ((1 << BlurSumShift) + pixelCount - 1) / pixelCount;
                int ofs = 1 + side2;
                int alpha1 = pixels[channels[step]];
                int alpha2 = pixels[(dim - 1) * stride + channels[step]];
                unsigned char* ptr = pixels + channels[step + 1];
                unsigned char* prev = pixels + stride + channels[step];
                unsigned char* next = pixels + ofs * stride + channels[step];

                int i;
                int sum = side1 * alpha1 + alpha1;
                int limit = (dim < side2 + 1) ? dim : side2 + 1;
                for (i = 1; i < limit; ++i, prev += stride)
                    sum += *prev;
                if (limit <= side2)
                    sum += (side2 - limit + 1) * alpha2;

                limit = (side1 < dim) ? side1 : dim;
                for (i = 0; i < limit; ptr += stride, next += stride, ++i, ++ofs) {
                    *ptr = (sum * invCount) >> BlurSumShift;
                    sum += ((ofs < dim) ? *next : alpha2) - alpha1;
                }
                prev = pixels + channels[step];
                for (; ofs < dim; ptr += stride, prev += stride, next += stride, ++i, ++ofs) {
                    *ptr = (sum * invCount) >> BlurSumShift;
                    sum += (*next) - (*prev);
                }
                for (; i < dim; ptr += stride, prev += stride, ++i) {
                    *ptr = (sum * invCount) >> BlurSumShift;
                    sum += alpha2 - (*prev);
                }
            }
        }
    }
}

void ContextShadow::calculateLayerBoundingRect(const FloatRect& layerArea, const IntRect& clipRect)
{
    // Calculate the destination of the blurred layer.
    FloatRect destinationRect(layerArea);
    destinationRect.move(m_offset);
    m_layerRect = enclosingIntRect(destinationRect);

    // We expand the area by the blur radius to give extra space for the blur transition.
    m_layerRect.inflate(m_type == BlurShadow ? m_blurDistance : 0);

    if (!clipRect.contains(m_layerRect)) {
        // No need to have the buffer larger than the clip.
        m_layerRect.intersect(clipRect);

        // If we are totally outside the clip region, we aren't painting at all.
        if (m_layerRect.isEmpty())
            return;

        // We adjust again because the pixels at the borders are still
        // potentially affected by the pixels outside the buffer.
        if (m_type == BlurShadow)
            m_layerRect.inflate(m_type == BlurShadow ? m_blurDistance : 0);
    }
}


//////////////////

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/qt/ContextShadowQt.cpp

//#include "config.h"
//#include "ContextShadow.h"

#include <QPainter>
#include <QTimerEvent>

// ContextShadow needs a scratch image as the buffer for the blur filter.
// Instead of creating and destroying the buffer for every operation,
// we create a buffer which will be automatically purged via a timer.

class ShadowBuffer: public QObject {
public:
    ShadowBuffer(QObject* parent = 0);

    QImage* scratchImage(const QSize& size);

    void schedulePurge();

protected:
    void timerEvent(QTimerEvent* event);

private:
    QImage image;
    int timerId;
};

ShadowBuffer::ShadowBuffer(QObject* parent)
    : QObject(parent)
    , timerId(0)
{
}

QImage* ShadowBuffer::scratchImage(const QSize& size)
{
    int width = size.width();
    int height = size.height();

    // We do not need to recreate the buffer if the buffer is reasonably
    // larger than the requested size. However, if the requested size is
    // much smaller than our buffer, reduce our buffer so that we will not
    // keep too many allocated pixels for too long.
    if (!image.isNull() && (image.width() > width) && (image.height() > height))
        if (((2 * width) > image.width()) && ((2 * height) > image.height())) {
            image.fill(Qt::transparent);
            return &image;
        }

    // Round to the nearest 32 pixels so we do not grow the buffer everytime
    // there is larger request by 1 pixel.
    width = (1 + (width >> 5)) << 5;
    height = (1 + (height >> 5)) << 5;

    image = QImage(width, height, QImage::Format_ARGB32_Premultiplied);
    image.fill(Qt::transparent);
    return &image;
}

void ShadowBuffer::schedulePurge()
{
    static const double BufferPurgeDelay = 2; // seconds
    killTimer(timerId);
    timerId = startTimer(BufferPurgeDelay * 1000);
}

void ShadowBuffer::timerEvent(QTimerEvent* event)
{
    if (event->timerId() == timerId) {
        killTimer(timerId);
        image = QImage();
    }
    QObject::timerEvent(event);
}

Q_GLOBAL_STATIC(ShadowBuffer, scratchShadowBuffer)

PlatformContext ContextShadow::beginShadowLayer(PlatformContext p, const FloatRect& layerArea)
{
    QRect clipRect;
    if (p->hasClipping())
#if QT_VERSION >= QT_VERSION_CHECK(4, 8, 0)
        clipRect = p->clipBoundingRect().toAlignedRect();
#else
        clipRect = p->clipRegion().boundingRect();
#endif
    else
        clipRect = p->transform().inverted().mapRect(p->window());

    calculateLayerBoundingRect(layerArea, IntRect(clipRect.x(), clipRect.y(), clipRect.width(), clipRect.height()));

    // Don't paint if we are totally outside the clip region.
    if (m_layerRect.isEmpty())
        return 0;

    ShadowBuffer* shadowBuffer = scratchShadowBuffer();
    QImage* shadowImage = shadowBuffer->scratchImage(m_layerRect.size());
    m_layerImage = QImage(*shadowImage);

    m_layerContext = new QPainter;
    m_layerContext->begin(&m_layerImage);
    m_layerContext->setFont(p->font());
    m_layerContext->translate(m_offset.width(), m_offset.height());

    // The origin is now the top left corner of the scratch image.
    m_layerContext->translate(-m_layerRect.x(), -m_layerRect.y());

    return m_layerContext;
}

void ContextShadow::endShadowLayer(PlatformContext p)
{
    m_layerContext->end();
    delete m_layerContext;
    m_layerContext = 0;

    if (m_type == BlurShadow) {
        blurLayerImage(m_layerImage.bits(), IntSize(m_layerImage.width(), m_layerImage.height()),
                       m_layerImage.bytesPerLine());

        // "Colorize" with the right shadow color.
        QPainter p(&m_layerImage);
        p.setCompositionMode(QPainter::CompositionMode_SourceIn);
        p.fillRect(m_layerImage.rect(), m_color.rgb());
        p.end();
    }

    p->drawImage(m_layerRect.topLeft(), m_layerImage);
    scratchShadowBuffer()->schedulePurge();
}
</file>

<file path="floatpoint.cpp">
// this_file: qlith-pro/src/floatpoint.cpp
#include "qlith/floatpoint.h"

#include "qlith/transformationmatrix.h"

#include "qlith/common.h"

/*#include "config.h"
#include "FloatPoint.h"

#include "TransformationMatrix.h"
#include "FloatConversion.h"
#include "IntPoint.h"*/

#include <cmath>

FloatPoint::FloatPoint(const IntPoint& p) : m_x(p.x()), m_y(p.y())
{
}

void FloatPoint::normalize()
{
    float tempLength = length();

    if (tempLength) {
        m_x /= tempLength;
        m_y /= tempLength;
    }
}

float FloatPoint::length() const
{
    return sqrtf(lengthSquared());
}

FloatPoint FloatPoint::matrixTransform(const AffineTransform& transform) const
{
    double newX, newY;
    transform.map(static_cast<double>(m_x), static_cast<double>(m_y), newX, newY);
    return narrowPrecision(newX, newY);
}

FloatPoint FloatPoint::matrixTransform(const TransformationMatrix& transform) const
{
    double newX, newY;
    transform.map(static_cast<double>(m_x), static_cast<double>(m_y), newX, newY);
    return narrowPrecision(newX, newY);
}

FloatPoint FloatPoint::narrowPrecision(double x, double y)
{
    return FloatPoint(narrowPrecisionToFloat(x), narrowPrecisionToFloat(y));
}

//////////////////

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/qt/FloatPointQt.cpp
FloatPoint::FloatPoint(const QPointF& p)
    : m_x(p.x())
    , m_y(p.y())
{
}

FloatPoint::operator QPointF() const
{
    return QPointF(m_x, m_y);
}
</file>

<file path="floatpoint3d.cpp">
// this_file: qlith-pro/src/floatpoint3d.cpp
#include "qlith/floatpoint3d.h"

#include <cmath>

void FloatPoint3D::normalize()
{
    float tempLength = length();

    if (tempLength) {
        m_x /= tempLength;
        m_y /= tempLength;
        m_z /= tempLength;
    }
}

float FloatPoint3D::length() const
{
    return sqrtf(lengthSquared());
}
</file>

<file path="floatquad.cpp">
// this_file: qlith-pro/src/floatquad.cpp
#include "qlith/floatquad.h"

#include "qlith/common.h"

#include <algorithm>

using std::max;
using std::min;

static inline float min4(float a, float b, float c, float d)
{
    return min(min(a, b), min(c, d));
}

static inline float max4(float a, float b, float c, float d)
{
    return max(max(a, b), max(c, d));
}

inline float dot(const FloatSize& a, const FloatSize& b)
{
    return a.width() * b.width() + a.height() * b.height();
}

inline bool isPointInTriangle(const FloatPoint& p, const FloatPoint& t1, const FloatPoint& t2, const FloatPoint& t3)
{
    // Compute vectors
    FloatSize v0 = t3 - t1;
    FloatSize v1 = t2 - t1;
    FloatSize v2 = p - t1;

    // Compute dot products
    float dot00 = dot(v0, v0);
    float dot01 = dot(v0, v1);
    float dot02 = dot(v0, v2);
    float dot11 = dot(v1, v1);
    float dot12 = dot(v1, v2);

    // Compute barycentric coordinates
    float invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);
    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;

    // Check if point is in triangle
    return (u >= 0) && (v >= 0) && (u + v <= 1);
}

FloatRect FloatQuad::boundingBox() const
{
    float left   = min4(m_p1.x(), m_p2.x(), m_p3.x(), m_p4.x());
    float top    = min4(m_p1.y(), m_p2.y(), m_p3.y(), m_p4.y());

    float right  = max4(m_p1.x(), m_p2.x(), m_p3.x(), m_p4.x());
    float bottom = max4(m_p1.y(), m_p2.y(), m_p3.y(), m_p4.y());

    return FloatRect(left, top, right - left, bottom - top);
}

bool FloatQuad::isRectilinear() const
{
    return (m_p1.x() == m_p2.x() && m_p2.y() == m_p3.y() && m_p3.x() == m_p4.x() && m_p4.y() == m_p1.y())
        || (m_p1.y() == m_p2.y() && m_p2.x() == m_p3.x() && m_p3.y() == m_p4.y() && m_p4.x() == m_p1.x());
}

bool FloatQuad::containsPoint(const FloatPoint& p) const
{
    return isPointInTriangle(p, m_p1, m_p2, m_p3) || isPointInTriangle(p, m_p1, m_p3, m_p4);
}

// Note that we only handle convex quads here.
bool FloatQuad::containsQuad(const FloatQuad& other) const
{
    return containsPoint(other.p1()) && containsPoint(other.p2()) && containsPoint(other.p3()) && containsPoint(other.p4());
}
</file>

<file path="floatrect.cpp">
// this_file: qlith-pro/src/floatrect.cpp
#include "qlith/floatrect.h"

#include "qlith/common.h"

/*#include "config.h"
#include "FloatRect.h"

#include "FloatConversion.h"
#include "IntRect.h"*/

#include <algorithm>
#include <limits>
#include <cmath>

#include "qlith/floatpoint.h"
#include "qlith/intpoint.h"
#include "qlith/intsize.h"
#include "qlith/floatsize.h"
#include "qlith/intrect.h"

#include <QRectF>

using std::max;
using std::min;

FloatRect::FloatRect(const IntRect& r) : m_location(r.location()), m_size(r.size())
{
}

FloatRect FloatRect::narrowPrecision(double x, double y, double width, double height)
{
    return FloatRect(narrowPrecisionToFloat(x), narrowPrecisionToFloat(y), narrowPrecisionToFloat(width), narrowPrecisionToFloat(height));
}

bool FloatRect::intersects(const FloatRect& other) const
{
    // Checking emptiness handles negative widths as well as zero.
    return !isEmpty() && !other.isEmpty()
        && x() < other.right() && other.x() < right()
        && y() < other.bottom() && other.y() < bottom();
}

bool FloatRect::contains(const FloatRect& other) const
{
    return x() <= other.x() && right() >= other.right()
        && y() <= other.y() && bottom() >= other.bottom();
}

void FloatRect::intersect(const FloatRect& other)
{
    float l = max(x(), other.x());
    float t = max(y(), other.y());
    float r = min(right(), other.right());
    float b = min(bottom(), other.bottom());

    // Return a clean empty rectangle for non-intersecting cases.
    if (l >= r || t >= b) {
        l = 0;
        t = 0;
        r = 0;
        b = 0;
    }

    setLocationAndSizeFromEdges(l, t, r, b);
}

void FloatRect::unite(const FloatRect& other)
{
    // Handle empty special cases first.
    if (other.isEmpty())
        return;
    if (isEmpty()) {
        *this = other;
        return;
    }

    float l = min(x(), other.x());
    float t = min(y(), other.y());
    float r = max(right(), other.right());
    float b = max(bottom(), other.bottom());

    setLocationAndSizeFromEdges(l, t, r, b);
}

void FloatRect::scale(float sx, float sy)
{
    m_location.setX(x() * sx);
    m_location.setY(y() * sy);
    m_size.setWidth(width() * sx);
    m_size.setHeight(height() * sy);
}

void FloatRect::fitToPoints(const FloatPoint& p0, const FloatPoint& p1)
{
    float left = min(p0.x(), p1.x());
    float top = min(p0.y(), p1.y());
    float right = max(p0.x(), p1.x());
    float bottom = max(p0.y(), p1.y());

    setLocationAndSizeFromEdges(left, top, right, bottom);
}

namespace {
// Helpers for 3- and 4-way max and min.

template <typename T>
T min3(const T& v1, const T& v2, const T& v3)
{
    return min(min(v1, v2), v3);
}

template <typename T>
T max3(const T& v1, const T& v2, const T& v3)
{
    return max(max(v1, v2), v3);
}

template <typename T>
T min4(const T& v1, const T& v2, const T& v3, const T& v4)
{
    return min(min(v1, v2), min(v3, v4));
}

template <typename T>
T max4(const T& v1, const T& v2, const T& v3, const T& v4)
{
    return max(max(v1, v2), max(v3, v4));
}

} // anonymous namespace

void FloatRect::fitToPoints(const FloatPoint& p0, const FloatPoint& p1, const FloatPoint& p2)
{
    float left = min3(p0.x(), p1.x(), p2.x());
    float top = min3(p0.y(), p1.y(), p2.y());
    float right = max3(p0.x(), p1.x(), p2.x());
    float bottom = max3(p0.y(), p1.y(), p2.y());

    setLocationAndSizeFromEdges(left, top, right, bottom);
}

void FloatRect::fitToPoints(const FloatPoint& p0, const FloatPoint& p1, const FloatPoint& p2, const FloatPoint& p3)
{
    float left = min4(p0.x(), p1.x(), p2.x(), p3.x());
    float top = min4(p0.y(), p1.y(), p2.y(), p3.y());
    float right = max4(p0.x(), p1.x(), p2.x(), p3.x());
    float bottom = max4(p0.y(), p1.y(), p2.y(), p3.y());

    setLocationAndSizeFromEdges(left, top, right, bottom);
}

static inline int safeFloatToInt(float x)
{
    static const int s_intMax = std::numeric_limits<int>::max();
    static const int s_intMin = std::numeric_limits<int>::min();

    if (x >= static_cast<float>(s_intMax))
        return s_intMax;
    if (x < static_cast<float>(s_intMin))
        return s_intMin;
    return static_cast<int>(x);
}

IntRect enclosingIntRect(const FloatRect& rect)
{
    float left = floorf(rect.x());
    float top = floorf(rect.y());
    float width = ceilf(rect.right()) - left;
    float height = ceilf(rect.bottom()) - top;
    return IntRect(safeFloatToInt(left), safeFloatToInt(top),
                   safeFloatToInt(width), safeFloatToInt(height));
}

FloatRect mapRect(const FloatRect& r, const FloatRect& srcRect, const FloatRect& destRect)
{
    if (srcRect.width() == 0 || srcRect.height() == 0)
        return FloatRect();

    float widthScale = destRect.width() / srcRect.width();
    float heightScale = destRect.height() / srcRect.height();
    return FloatRect(destRect.x() + (r.x() - srcRect.x()) * widthScale,
                     destRect.y() + (r.y() - srcRect.y()) * heightScale,
                     r.width() * widthScale, r.height() * heightScale);
}

/////////////////
// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/qt/FloatRectQt.cpp

FloatRect::FloatRect(const QRectF& r)
    : m_location(r.topLeft())
    , m_size(r.width()
    , r.height())
{
}

FloatRect::operator QRectF() const
{
    return QRectF(x(), y(), width(), height());
}

FloatRect FloatRect::normalized() const
{
    FloatRect normalizedRect = *this;

    if (width() < 0) {
        normalizedRect.setX(x() + width());
        normalizedRect.setWidth(-width());
    }
    if (height() < 0) {
        normalizedRect.setY(y() + height());
        normalizedRect.setHeight(-height());
    }
    return normalizedRect;
}
</file>

<file path="floatsize.cpp">
// this_file: qlith-pro/src/floatsize.cpp
#include "qlith/floatsize.h"

#include "qlith/common.h"

#include "qlith/intsize.h"
#include <cmath>

FloatSize::FloatSize(const IntSize& size) : m_width(size.width()), m_height(size.height())
{
}

float FloatSize::diagonalLength() const
{
    return sqrtf(diagonalLengthSquared());
}

FloatSize FloatSize::narrowPrecision(double width, double height)
{
    return FloatSize(narrowPrecisionToFloat(width), narrowPrecisionToFloat(height));
}
</file>

<file path="gradient.cpp">
// this_file: qlith-pro/src/gradient.cpp
#include "qlith/gradient.h"

#include <QGradient>
#include <QPainter>

#include "qlith/common.h"
//#include "Gradient.h"

#include "qlith/graphicscontext.h"

#include "qlith/color.h"
#include "qlith/floatrect.h"
//#include <wtf/UnusedParam.h>

Gradient::Gradient(const FloatPoint& p0, const FloatPoint& p1)
    : m_radial(false)
    , m_p0(p0)
    , m_p1(p1)
    , m_r0(0)
    , m_r1(0)
    , m_stopsSorted(false)
    , m_lastStop(0)
    , m_spreadMethod(SpreadMethodPad)
{
    platformInit();
}

Gradient::Gradient(const FloatPoint& p0, float r0, const FloatPoint& p1, float r1)
    : m_radial(true)
    , m_p0(p0)
    , m_p1(p1)
    , m_r0(r0)
    , m_r1(r1)
    , m_stopsSorted(false)
    , m_lastStop(0)
    , m_spreadMethod(SpreadMethodPad)
{
    platformInit();
}

Gradient::~Gradient()
{
    platformDestroy();
}

void Gradient::adjustParametersForTiledDrawing(IntSize& size, FloatRect& srcRect)
{
    if (m_radial)
        return;

    if (srcRect.isEmpty())
        return;

    if (m_p0.x() == m_p1.x()) {
        size.setWidth(1);
        srcRect.setWidth(1);
        srcRect.setX(0);
        return;
    }
    if (m_p0.y() != m_p1.y())
        return;

    size.setHeight(1);
    srcRect.setHeight(1);
    srcRect.setY(0);
}

void Gradient::addColorStop(float value, const Color& color)
{
    float r;
    float g;
    float b;
    float a;
    color.getRGBA(r, g, b, a);
    m_stops.append(ColorStop(value, r, g, b, a));

    m_stopsSorted = false;
    platformDestroy();
}

void Gradient::addColorStop(const Gradient::ColorStop& stop)
{
    m_stops.append(stop);

    m_stopsSorted = false;
    platformDestroy();
}

static inline bool compareStops(const Gradient::ColorStop& a, const Gradient::ColorStop& b)
{
    return a.stop < b.stop;
}

void Gradient::sortStopsIfNecessary()
{
    if (m_stopsSorted)
        return;

    m_stopsSorted = true;

    if (!m_stops.size())
        return;

    // Shortcut for the ideal case (ordered 2-stop gradient)
    if (m_stops.size() == 2 && compareStops(*m_stops.begin(), *m_stops.end()))
        return;

    std::stable_sort(m_stops.begin(), m_stops.end(), compareStops);
}

void Gradient::getColor(float value, float* r, float* g, float* b, float* a) const
{
    ASSERT(value >= 0);
    ASSERT(value <= 1);

    if (m_stops.isEmpty()) {
        *r = 0;
        *g = 0;
        *b = 0;
        *a = 0;
        return;
    }
    if (!m_stopsSorted) {
        if (m_stops.size())
            std::stable_sort(m_stops.begin(), m_stops.end(), compareStops);
        m_stopsSorted = true;
    }
    if (value <= 0 || value <= m_stops.first().stop) {
        *r = m_stops.first().red;
        *g = m_stops.first().green;
        *b = m_stops.first().blue;
        *a = m_stops.first().alpha;
        return;
    }
    if (value >= 1 || value >= m_stops.last().stop) {
        *r = m_stops.last().red;
        *g = m_stops.last().green;
        *b = m_stops.last().blue;
        *a = m_stops.last().alpha;
        return;
    }

    // Find stop before and stop after and interpolate.
    int stop = findStop(value);
    const ColorStop& lastStop = m_stops[stop];
    const ColorStop& nextStop = m_stops[stop + 1];
    float stopFraction = (value - lastStop.stop) / (nextStop.stop - lastStop.stop);
    *r = lastStop.red + (nextStop.red - lastStop.red) * stopFraction;
    *g = lastStop.green + (nextStop.green - lastStop.green) * stopFraction;
    *b = lastStop.blue + (nextStop.blue - lastStop.blue) * stopFraction;
    *a = lastStop.alpha + (nextStop.alpha - lastStop.alpha) * stopFraction;
}

int Gradient::findStop(float value) const
{
    ASSERT(value >= 0);
    ASSERT(value <= 1);
    ASSERT(m_stopsSorted);

    int numStops = m_stops.size();
    ASSERT(numStops >= 2);
    ASSERT(m_lastStop < numStops - 1);

    int i = m_lastStop;
    if (value < m_stops[i].stop)
        i = 1;
    else
        i = m_lastStop + 1;

    for (; i < numStops - 1; ++i)
        if (value < m_stops[i].stop)
            break;

    m_lastStop = i - 1;
    return m_lastStop;
}

void Gradient::setSpreadMethod(GradientSpreadMethod spreadMethod)
{
    // FIXME: Should it become necessary, allow calls to this method after m_gradient has been set.
    ASSERT(m_gradient == 0);
    m_spreadMethod = spreadMethod;
}

void Gradient::setGradientSpaceTransform(const AffineTransform& gradientSpaceTransformation)
{
    m_gradientSpaceTransformation = gradientSpaceTransformation;
    setPlatformGradientSpaceTransform(gradientSpaceTransformation);
}

//#if !PLATFORM(SKIA) && !PLATFORM(CAIRO)
void Gradient::setPlatformGradientSpaceTransform(const AffineTransform&)
{
}
//#endif

////////////////////////////

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/qt/GradientQt.cpp


void Gradient::platformDestroy()
{
    delete m_gradient;
    m_gradient = 0;
}

QGradient* Gradient::platformGradient()
{
    if (m_gradient)
        return m_gradient;

    bool reversed = m_r0 > m_r1;

    qreal innerRadius = reversed ? m_r1 : m_r0;
    qreal outerRadius = reversed ? m_r0 : m_r1;
    QPointF center = reversed ? m_p0 : m_p1;
    QPointF focalPoint = reversed ? m_p1 : m_p0;

    if (m_radial)
        m_gradient = new QRadialGradient(center, outerRadius, focalPoint);
    else
        m_gradient = new QLinearGradient(m_p0.x(), m_p0.y(), m_p1.x(), m_p1.y());

    m_gradient->setInterpolationMode(QGradient::ComponentInterpolation);

    sortStopsIfNecessary();

    QColor stopColor;
    QVector<ColorStop>::iterator stopIterator = m_stops.begin();
    qreal lastStop(0.0);
    const qreal lastStopDiff = 0.0000001;
    while (stopIterator != m_stops.end()) {
        stopColor.setRgbF(stopIterator->red, stopIterator->green, stopIterator->blue, stopIterator->alpha);
        if (qFuzzyCompare(lastStop, qreal(stopIterator->stop)))
            lastStop = stopIterator->stop + lastStopDiff;
        else
            lastStop = stopIterator->stop;

        if (m_radial && !qFuzzyCompare(1 + outerRadius, qreal(1))) {
            lastStop = lastStop * (1.0f - innerRadius / outerRadius);
            if (!reversed)
                lastStop += innerRadius / outerRadius;
        }

        qreal stopPosition = qMin(lastStop, qreal(1.0f));

        if (m_radial && reversed)
            stopPosition = 1 - stopPosition;

        m_gradient->setColorAt(stopPosition, stopColor);
        // Keep the lastStop as orginal value, since the following stopColor depend it
        lastStop = stopIterator->stop;
        ++stopIterator;
    }

    if (m_stops.isEmpty()) {
        // The behavior of QGradient with no stops is defined differently from HTML5 spec,
        // where the latter requires the gradient to be transparent black.
        m_gradient->setColorAt(0.0, QColor(0, 0, 0, 0));
    }

    switch (m_spreadMethod) {
    case SpreadMethodPad:
        m_gradient->setSpread(QGradient::PadSpread);
        break;
    case SpreadMethodReflect:
        m_gradient->setSpread(QGradient::ReflectSpread);
        break;
    case SpreadMethodRepeat:
        m_gradient->setSpread(QGradient::RepeatSpread);
        break;
    }

    return m_gradient;
}

void Gradient::fill(GraphicsContext* context, const FloatRect& rect)
{
    context->platformContext()->fillRect(rect, *platformGradient());
}
</file>

<file path="graphicscontext.cpp">
// this_file: qlith-pro/src/graphicscontext.cpp
#include "qlith/graphicscontext.h"

#include "qlith/contextshadow.h"

#include <QBrush>
#include <QDebug>
#include <QGradient>
#include <QPaintDevice>
#include <QPaintEngine>
#include <QPainter>
#include <QPainterPath>
#include <QPixmap>
#include <QPolygonF>
#include <QStack>
#include <QVector>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

#define LOG_ERROR qDebug

GraphicsContextPrivate* GraphicsContext::createGraphicsContextPrivate()
{
    return new GraphicsContextPrivate;
}

void GraphicsContext::destroyGraphicsContextPrivate(GraphicsContextPrivate* deleteMe)
{
    delete deleteMe;
}

void GraphicsContext::save()
{
    if (paintingDisabled())
        return;

    m_common->stack.append(m_common->state);

    savePlatformState();
}

void GraphicsContext::restore()
{
    if (paintingDisabled())
        return;

    if (m_common->stack.isEmpty()) {
        LOG_ERROR("ERROR void GraphicsContext::restore() stack is empty");
        return;
    }
    m_common->state = m_common->stack.last();
    m_common->stack.removeLast();

    restorePlatformState();
}


void GraphicsContext::setStrokeThickness(float thickness)
{
    m_common->state.strokeThickness = thickness;
    setPlatformStrokeThickness(thickness);
}

void GraphicsContext::setStrokeStyle(const StrokeStyle& style)
{
    m_common->state.strokeStyle = style;
    setPlatformStrokeStyle(style);
}

void GraphicsContext::setStrokeColor(const Color& color, ColorSpace colorSpace)
{
    m_common->state.strokeColor = color;
    m_common->state.strokeColorSpace = colorSpace;
    m_common->state.strokeGradient.reset();
    //m_common->state.strokeGradient.clear();
    //m_common->state.strokePattern.clear();
    setPlatformStrokeColor(color, colorSpace);
}

void GraphicsContext::setShadow(const FloatSize& offset, float blur, const Color& color, ColorSpace colorSpace)
{
    m_common->state.shadowOffset = offset;
    m_common->state.shadowBlur = blur;
    m_common->state.shadowColor = color;
    setPlatformShadow(offset, blur, color, colorSpace);
}

void GraphicsContext::clearShadow()
{
    m_common->state.shadowOffset = FloatSize();
    m_common->state.shadowBlur = 0;
    m_common->state.shadowColor = Color();
    clearPlatformShadow();
}

bool GraphicsContext::getShadow(FloatSize& offset, float& blur, Color& color) const
{
    offset = m_common->state.shadowOffset;
    blur = m_common->state.shadowBlur;
    color = m_common->state.shadowColor;

    return color.isValid() && color.alpha() && (blur || offset.width() || offset.height());
}

float GraphicsContext::strokeThickness() const
{
    return m_common->state.strokeThickness;
}

StrokeStyle GraphicsContext::strokeStyle() const
{
    return m_common->state.strokeStyle;
}

Color GraphicsContext::strokeColor() const
{
    return m_common->state.strokeColor;
}

ColorSpace GraphicsContext::strokeColorSpace() const
{
    return m_common->state.strokeColorSpace;
}

WindRule GraphicsContext::fillRule() const
{
    return m_common->state.fillRule;
}

void GraphicsContext::setFillRule(WindRule fillRule)
{
    m_common->state.fillRule = fillRule;
}

void GraphicsContext::setFillColor(const Color& color, ColorSpace colorSpace)
{
    m_common->state.fillColor = color;
    m_common->state.fillColorSpace = colorSpace;
    //m_common->state.fillGradient.clear();
    m_common->state.fillGradient.reset();
    //m_common->state.fillPattern.clear();
    setPlatformFillColor(color, colorSpace);
}

Color GraphicsContext::fillColor() const
{
    return m_common->state.fillColor;
}

ColorSpace GraphicsContext::fillColorSpace() const
{
    return m_common->state.fillColorSpace;
}

void GraphicsContext::setShouldAntialias(bool b)
{
    m_common->state.shouldAntialias = b;
    setPlatformShouldAntialias(b);
}

bool GraphicsContext::shouldAntialias() const
{
    return m_common->state.shouldAntialias;
}

/*void GraphicsContext::setStrokePattern(PassRefPtr<Pattern> pattern)
{
    ASSERT(pattern);
    if (!pattern) {
        setStrokeColor(Color::black, DeviceColorSpace);
        return;
    }
    m_common->state.strokeGradient.clear();
    m_common->state.strokePattern = pattern;
    setPlatformStrokePattern(m_common->state.strokePattern.get());
}

void GraphicsContext::setFillPattern(PassRefPtr<Pattern> pattern)
{
    ASSERT(pattern);
    if (!pattern) {
        setFillColor(Color::black, DeviceColorSpace);
        return;
    }
    m_common->state.fillGradient.clear();
    m_common->state.fillPattern = pattern;
    setPlatformFillPattern(m_common->state.fillPattern.get());
}*/

void GraphicsContext::setStrokeGradient(PassRefPtr<Gradient> gradient)
{
    ASSERT(gradient);
    if (!gradient) {
        setStrokeColor(Color::black, DeviceColorSpace);
        return;
    }
    m_common->state.strokeGradient = gradient;
    //m_common->state.strokePattern.clear();
    setPlatformStrokeGradient(m_common->state.strokeGradient.get());
}

void GraphicsContext::setFillGradient(PassRefPtr<Gradient> gradient)
{
    ASSERT(gradient);
    if (!gradient) {
        setFillColor(Color::black, DeviceColorSpace);
        return;
    }
    m_common->state.fillGradient = gradient;
    //m_common->state.fillPattern.clear();
    setPlatformFillGradient(m_common->state.fillGradient.get());
}

Gradient* GraphicsContext::fillGradient() const
{
    return m_common->state.fillGradient.get();
}

Gradient* GraphicsContext::strokeGradient() const
{
    return m_common->state.strokeGradient.get();
}

/*Pattern* GraphicsContext::fillPattern() const
{
    return m_common->state.fillPattern.get();
}

Pattern* GraphicsContext::strokePattern() const
{
    return m_common->state.strokePattern.get();
}*/

void GraphicsContext::setShadowsIgnoreTransforms(bool ignoreTransforms)
{
    m_common->state.shadowsIgnoreTransforms = ignoreTransforms;
}

bool GraphicsContext::updatingControlTints() const
{
    return m_common->m_updatingControlTints;
}

void GraphicsContext::setUpdatingControlTints(bool b)
{
    setPaintingDisabled(b);
    m_common->m_updatingControlTints = b;
}

void GraphicsContext::setPaintingDisabled(bool f)
{
    m_common->state.paintingDisabled = f;
}

bool GraphicsContext::paintingDisabled() const
{
    return m_common->state.paintingDisabled;
}

void GraphicsContext::drawImage(Image* image, ColorSpace styleColorSpace, const IntPoint& p, CompositeOperator op)
{
    drawImage(image, styleColorSpace, p, IntRect(0, 0, -1, -1), op);
}

void GraphicsContext::drawImage(Image* image, ColorSpace styleColorSpace, const IntRect& r, CompositeOperator op, bool useLowQualityScale)
{
    drawImage(image, styleColorSpace, r, IntRect(0, 0, -1, -1), op, useLowQualityScale);
}

void GraphicsContext::drawImage(Image* image, ColorSpace styleColorSpace, const IntPoint& dest, const IntRect& srcRect, CompositeOperator op)
{
    drawImage(image, styleColorSpace, IntRect(dest, srcRect.size()), srcRect, op);
}

void GraphicsContext::drawImage(Image* image, ColorSpace styleColorSpace, const IntRect& dest, const IntRect& srcRect, CompositeOperator op, bool useLowQualityScale)
{
    drawImage(image, styleColorSpace, FloatRect(dest), srcRect, op, useLowQualityScale);
}

/*#if !OS(WINCE) || PLATFORM(QT)
void GraphicsContext::drawText(const Font& font, const TextRun& run, const IntPoint& point, int from, int to)
{
    if (paintingDisabled())
        return;

    font.drawText(this, run, point, from, to);
}
#endif

void GraphicsContext::drawBidiText(const Font& font, const TextRun& run, const FloatPoint& point)
{
    if (paintingDisabled())
        return;

    BidiResolver<TextRunIterator, BidiCharacterRun> bidiResolver;
    WTF::Unicode::Direction paragraphDirection = run.ltr() ? WTF::Unicode::LeftToRight : WTF::Unicode::RightToLeft;

    bidiResolver.setStatus(BidiStatus(paragraphDirection, paragraphDirection, paragraphDirection, BidiContext::create(run.ltr() ? 0 : 1, paragraphDirection, run.directionalOverride())));

    bidiResolver.setPosition(TextRunIterator(&run, 0));
    bidiResolver.createBidiRunsForLine(TextRunIterator(&run, run.length()));

    if (!bidiResolver.runCount())
        return;

    FloatPoint currPoint = point;
    BidiCharacterRun* bidiRun = bidiResolver.firstRun();
    while (bidiRun) {

        TextRun subrun = run;
        subrun.setText(run.data(bidiRun->start()), bidiRun->stop() - bidiRun->start());
        subrun.setRTL(bidiRun->level() % 2);
        subrun.setDirectionalOverride(bidiRun->dirOverride(false));

        font.drawText(this, subrun, currPoint);

        bidiRun = bidiRun->next();
        // FIXME: Have Font::drawText return the width of what it drew so that we don't have to re-measure here.
        if (bidiRun)
            currPoint.move(font.floatWidth(subrun), 0.f);
    }

    bidiResolver.deleteRuns();
}

void GraphicsContext::drawHighlightForText(const Font& font, const TextRun& run, const IntPoint& point, int h, const Color& backgroundColor, ColorSpace colorSpace, int from, int to)
{
    if (paintingDisabled())
        return;

    fillRect(font.selectionRectForText(run, point, h, from, to), backgroundColor, colorSpace);
}*/

void GraphicsContext::drawImage(Image* image, ColorSpace styleColorSpace, const FloatRect& dest, const FloatRect& src, CompositeOperator op, bool useLowQualityScale)
{
    if (paintingDisabled() || !image)
        return;

    float tsw = src.width();
    float tsh = src.height();
    float tw = dest.width();
    float th = dest.height();

    if (tsw == -1)
        tsw = image->width();
    if (tsh == -1)
        tsh = image->height();

    if (tw == -1)
        tw = image->width();
    if (th == -1)
        th = image->height();

    if (useLowQualityScale) {
        save();
        setImageInterpolationQuality(InterpolationNone);
    }
    image->draw(this, FloatRect(dest.location(), FloatSize(tw, th)), FloatRect(src.location(), FloatSize(tsw, tsh)), styleColorSpace, op);
    if (useLowQualityScale)
        restore();
}

void GraphicsContext::drawTiledImage(Image* image, ColorSpace styleColorSpace, const IntRect& rect, const IntPoint& srcPoint, const IntSize& tileSize, CompositeOperator op, bool useLowQualityScale)
{
    if (paintingDisabled() || !image)
        return;
    if (useLowQualityScale) {
        save();
        setImageInterpolationQuality(InterpolationLow);
    }
    image->drawTiled(this, rect, srcPoint, tileSize, styleColorSpace, op);
    if (useLowQualityScale)
        restore();
}

void GraphicsContext::drawTiledImage(Image* image, ColorSpace styleColorSpace, const IntRect& dest, const IntRect& srcRect, Image::TileRule hRule, Image::TileRule vRule, CompositeOperator op, bool useLowQualityScale)
{
    if (paintingDisabled() || !image)
        return;

    if (useLowQualityScale) {
        save();
        setImageInterpolationQuality(InterpolationLow);
    }
    if (hRule == Image::StretchTile && vRule == Image::StretchTile)
        // Just do a scale.
        drawImage(image, styleColorSpace, dest, srcRect, op);
    else
        image->drawTiled(this, dest, srcRect, hRule, vRule, styleColorSpace, op);
    if (useLowQualityScale)
        restore();
}

/*void GraphicsContext::drawImageBuffer(ImageBuffer* image, ColorSpace styleColorSpace, const IntPoint& p, CompositeOperator op)
{
    drawImageBuffer(image, styleColorSpace, p, IntRect(0, 0, -1, -1), op);
}

void GraphicsContext::drawImageBuffer(ImageBuffer* image, ColorSpace styleColorSpace, const IntRect& r, CompositeOperator op, bool useLowQualityScale)
{
    drawImageBuffer(image, styleColorSpace, r, IntRect(0, 0, -1, -1), op, useLowQualityScale);
}

void GraphicsContext::drawImageBuffer(ImageBuffer* image, ColorSpace styleColorSpace, const IntPoint& dest, const IntRect& srcRect, CompositeOperator op)
{
    drawImageBuffer(image, styleColorSpace, IntRect(dest, srcRect.size()), srcRect, op);
}

void GraphicsContext::drawImageBuffer(ImageBuffer* image, ColorSpace styleColorSpace, const IntRect& dest, const IntRect& srcRect, CompositeOperator op, bool useLowQualityScale)
{
    drawImageBuffer(image, styleColorSpace, FloatRect(dest), srcRect, op, useLowQualityScale);
}

void GraphicsContext::drawImageBuffer(ImageBuffer* image, ColorSpace styleColorSpace, const FloatRect& dest, const FloatRect& src, CompositeOperator op, bool useLowQualityScale)
{
    if (paintingDisabled() || !image)
        return;

    float tsw = src.width();
    float tsh = src.height();
    float tw = dest.width();
    float th = dest.height();

    if (tsw == -1)
        tsw = image->width();
    if (tsh == -1)
        tsh = image->height();

    if (tw == -1)
        tw = image->width();
    if (th == -1)
        th = image->height();

    if (useLowQualityScale) {
        save();
        setImageInterpolationQuality(InterpolationNone);
    }

    image->draw(this, styleColorSpace, dest, src, op, useLowQualityScale);

    if (useLowQualityScale)
        restore();
}*/

void GraphicsContext::addRoundedRectClip(const IntRect& rect, const IntSize& topLeft, const IntSize& topRight,
    const IntSize& bottomLeft, const IntSize& bottomRight)
{
    if (paintingDisabled())
        return;

    Path path;
    path.addRoundedRect(rect, topLeft, topRight, bottomLeft, bottomRight);
    clip(path);
}

void GraphicsContext::clipOutRoundedRect(const IntRect& rect, const IntSize& topLeft, const IntSize& topRight,
                                         const IntSize& bottomLeft, const IntSize& bottomRight)
{
    if (paintingDisabled())
        return;

    Path path;
    path.addRoundedRect(rect, topLeft, topRight, bottomLeft, bottomRight);
    clipOut(path);
}

/*void GraphicsContext::clipToImageBuffer(ImageBuffer* buffer, const FloatRect& rect)
{
    if (paintingDisabled())
        return;
    buffer->clip(this, rect);
}

int GraphicsContext::textDrawingMode()
{
    return m_common->state.textDrawingMode;
}

void GraphicsContext::setTextDrawingMode(int mode)
{
    m_common->state.textDrawingMode = mode;
    if (paintingDisabled())
        return;
    setPlatformTextDrawingMode(mode);
}*/

void GraphicsContext::fillRect(const FloatRect& rect, Generator& generator)
{
    if (paintingDisabled())
        return;
    generator.fill(this, rect);
}

//#if !PLATFORM(SKIA)
void GraphicsContext::setPlatformFillGradient(Gradient*)
{
}

/*void GraphicsContext::setPlatformFillPattern(Pattern*)
{
}*/

void GraphicsContext::setPlatformStrokeGradient(Gradient*)
{
}

/*void GraphicsContext::setPlatformStrokePattern(Pattern*)
{
}*/
//#endif

/*#if !PLATFORM(CG) && !PLATFORM(SKIA)
// Implement this if you want to go ahead and push the drawing mode into your native context
// immediately.
void GraphicsContext::setPlatformTextDrawingMode(int mode)
{
}
#endif

#if !PLATFORM(QT) && !PLATFORM(CAIRO) && !PLATFORM(SKIA) && !PLATFORM(HAIKU) && !PLATFORM(OPENVG)
void GraphicsContext::setPlatformStrokeStyle(const StrokeStyle&)
{
}
#endif

#if !PLATFORM(SKIA)
void GraphicsContext::setSharedGraphicsContext3D(SharedGraphicsContext3D*, DrawingBuffer*, const IntSize&)
{
}

void GraphicsContext::syncSoftwareCanvas()
{
}

void GraphicsContext::markDirtyRect(const IntRect&)
{
}
#endif*/


void GraphicsContext::adjustLineToPixelBoundaries(FloatPoint& p1, FloatPoint& p2, float strokeWidth, const StrokeStyle& penStyle)
{
    // For odd widths, we add in 0.5 to the appropriate x/y so that the float arithmetic
    // works out.  For example, with a border width of 3, WebKit will pass us (y1+y2)/2, e.g.,
    // (50+53)/2 = 103/2 = 51 when we want 51.5.  It is always true that an even width gave
    // us a perfect position, but an odd width gave us a position that is off by exactly 0.5.
    if (penStyle == DottedStroke || penStyle == DashedStroke) {
        if (p1.x() == p2.x()) {
            p1.setY(p1.y() + strokeWidth);
            p2.setY(p2.y() - strokeWidth);
        } else {
            p1.setX(p1.x() + strokeWidth);
            p2.setX(p2.x() - strokeWidth);
        }
    }

    if (static_cast<int>(strokeWidth) % 2) { //odd
        if (p1.x() == p2.x()) {
            // We're a vertical line.  Adjust our x.
            p1.setX(p1.x() + 0.5f);
            p2.setX(p2.x() + 0.5f);
        } else {
            // We're a horizontal line. Adjust our y.
            p1.setY(p1.y() + 0.5f);
            p2.setY(p2.y() + 0.5f);
        }
    }
}

///////////////////////////////////////////////////////////////////////


QPainter::CompositionMode GraphicsContext::toQtCompositionMode(CompositeOperator op)
{
    switch (op) {
    case CompositeClear:
        return QPainter::CompositionMode_Clear;
    case CompositeCopy:
        return QPainter::CompositionMode_Source;
    case CompositeSourceOver:
        return QPainter::CompositionMode_SourceOver;
    case CompositeSourceIn:
        return QPainter::CompositionMode_SourceIn;
    case CompositeSourceOut:
        return QPainter::CompositionMode_SourceOut;
    case CompositeSourceAtop:
        return QPainter::CompositionMode_SourceAtop;
    case CompositeDestinationOver:
        return QPainter::CompositionMode_DestinationOver;
    case CompositeDestinationIn:
        return QPainter::CompositionMode_DestinationIn;
    case CompositeDestinationOut:
        return QPainter::CompositionMode_DestinationOut;
    case CompositeDestinationAtop:
        return QPainter::CompositionMode_DestinationAtop;
    case CompositeXOR:
        return QPainter::CompositionMode_Xor;
    case CompositePlusDarker:
        // there is no exact match, but this is the closest
        return QPainter::CompositionMode_Darken;
    case CompositeHighlight:
        return QPainter::CompositionMode_SourceOver;
    case CompositePlusLighter:
        return QPainter::CompositionMode_Plus;
    }

    return QPainter::CompositionMode_SourceOver;
}

static inline Qt::PenCapStyle toQtLineCap(LineCap lc)
{
    switch (lc) {
    case ButtCap:
        return Qt::FlatCap;
    case RoundCap:
        return Qt::RoundCap;
    case SquareCap:
        return Qt::SquareCap;
    }

    return Qt::FlatCap;
}

static inline Qt::PenJoinStyle toQtLineJoin(LineJoin lj)
{
    switch (lj) {
    case MiterJoin:
        return Qt::SvgMiterJoin;
    case RoundJoin:
        return Qt::RoundJoin;
    case BevelJoin:
        return Qt::BevelJoin;
    }

    return Qt::MiterJoin;
}

static Qt::PenStyle toQPenStyle(StrokeStyle style)
{
    switch (style) {
    case NoStroke:
        return Qt::NoPen;
        break;
    case SolidStroke:
        return Qt::SolidLine;
        break;
    case DottedStroke:
        return Qt::DotLine;
        break;
    case DashedStroke:
        return Qt::DashLine;
        break;
    }
    qWarning("couldn't recognize the pen style");
    return Qt::NoPen;
}

static inline Qt::FillRule toQtFillRule(WindRule rule)
{
    switch (rule) {
    case RULE_EVENODD:
        return Qt::OddEvenFill;
    case RULE_NONZERO:
        return Qt::WindingFill;
    }
    qDebug("Qt: unrecognized wind rule!");
    return Qt::OddEvenFill;
}


GraphicsContextPlatformPrivate::GraphicsContextPlatformPrivate(QPainter* p)
{
    ASSERT(p);

    painter = p;
    layerCount = 0;

    solidColor = QBrush(Qt::black);

    imageInterpolationQuality = InterpolationDefault;

    if (painter) {
        // use the default the QPainter was constructed with
        antiAliasingForRectsAndLines = painter->testRenderHint(QPainter::Antialiasing);
        // FIXME: Maybe only enable in SVG mode?
        painter->setRenderHint(QPainter::Antialiasing, true);
        painter->setRenderHint(QPainter::SmoothPixmapTransform, true);
    } else
        antiAliasingForRectsAndLines = false;
}

GraphicsContextPlatformPrivate::~GraphicsContextPlatformPrivate()
{
}

GraphicsContext::GraphicsContext(PlatformGraphicsContext* context)
    : m_common(createGraphicsContextPrivate())
    , m_data(new GraphicsContextPlatformPrivate(context))
{
    ASSERT(m_data->p());
    setPaintingDisabled(!context);
    if (context) {
        // Make sure the context starts in sync with our state.
        setPlatformFillColor(fillColor(), DeviceColorSpace);
        setPlatformStrokeColor(strokeColor(), DeviceColorSpace);

        // Make sure we start with the correct join mode.
        setLineJoin(MiterJoin);
    }
}

GraphicsContext::~GraphicsContext()
{
   /* while (!m_data->layers.isEmpty())
        endTransparencyLayer();*/

    destroyGraphicsContextPrivate(m_common);
    delete m_data;
}

PlatformGraphicsContext* GraphicsContext::platformContext() const
{
    return m_data->p();
}

AffineTransform GraphicsContext::getCTM() const
{
    QTransform matrix(platformContext()->combinedTransform());
    return AffineTransform(matrix.m11(), matrix.m12(), matrix.m21(),
                           matrix.m22(), matrix.dx(), matrix.dy());
}

void GraphicsContext::savePlatformState()
{
    /*if (!m_data->layers.isEmpty() && !m_data->layers.top()->alphaMask.isNull())
        ++m_data->layers.top()->saveCounter;*/
    m_data->p()->save();
    m_data->shadowStack.push(m_data->shadow);
}

void GraphicsContext::restorePlatformState()
{
    /*if (!m_data->layers.isEmpty() && !m_data->layers.top()->alphaMask.isNull())
        if (!--m_data->layers.top()->saveCounter)
            endTransparencyLayer();*/

    m_data->p()->restore();

    if (!m_data->currentPath.isEmpty() && m_common->state.pathTransform.isInvertible()) {
        QTransform matrix = m_common->state.pathTransform;
        m_data->currentPath = m_data->currentPath * matrix;
    }

    if (m_data->shadowStack.isEmpty())
        m_data->shadow = ContextShadow();
    else
        m_data->shadow = m_data->shadowStack.pop();
}

// Draws a filled rectangle with a stroked border.
// This is only used to draw borders (real fill is done via fillRect), and
// thus it must not cast any shadow.
void GraphicsContext::drawRect(const IntRect& rect)
{
    if (paintingDisabled())
        return;

    QPainter* p = m_data->p();

    ASSERT(p);

    const bool antiAlias = p->testRenderHint(QPainter::Antialiasing);
    p->setRenderHint(QPainter::Antialiasing, m_data->antiAliasingForRectsAndLines);

    p->drawRect(rect);

    p->setRenderHint(QPainter::Antialiasing, antiAlias);
}

// This is only used to draw borders.
// Must not cast any shadow.
void GraphicsContext::drawLine(const IntPoint& point1, const IntPoint& point2)
{
    if (paintingDisabled())
        return;

    StrokeStyle style = strokeStyle();
    Color color = strokeColor();
    if (style == NoStroke)
        return;

    float width = strokeThickness();

    FloatPoint p1 = point1;
    FloatPoint p2 = point2;
    bool isVerticalLine = (p1.x() == p2.x());

    QPainter* p = m_data->p();

    ASSERT(p);

    const bool antiAlias = p->testRenderHint(QPainter::Antialiasing);
    p->setRenderHint(QPainter::Antialiasing, m_data->antiAliasingForRectsAndLines);
    adjustLineToPixelBoundaries(p1, p2, width, style);

    int patWidth = 0;
    switch (style) {
    case NoStroke:
    case SolidStroke:
        break;
    case DottedStroke:
        patWidth = static_cast<int>(width);
        break;
    case DashedStroke:
        patWidth = 3 * static_cast<int>(width);
        break;
    }

    if (patWidth) {
        p->save();

        // Do a rect fill of our endpoints.  This ensures we always have the
        // appearance of being a border.  We then draw the actual dotted/dashed line.
        if (isVerticalLine) {
            p->fillRect(FloatRect(p1.x() - width / 2, p1.y() - width, width, width), QColor(color));
            p->fillRect(FloatRect(p2.x() - width / 2, p2.y(), width, width), QColor(color));
        } else {
            p->fillRect(FloatRect(p1.x() - width, p1.y() - width / 2, width, width), QColor(color));
            p->fillRect(FloatRect(p2.x(), p2.y() - width / 2, width, width), QColor(color));
        }

        // Example: 80 pixels with a width of 30 pixels.
        // Remainder is 20.  The maximum pixels of line we could paint
        // will be 50 pixels.
        int distance = (isVerticalLine ? (point2.y() - point1.y()) : (point2.x() - point1.x())) - 2*(int)width;
        int remainder = distance % patWidth;
        int coverage = distance - remainder;
        int numSegments = coverage / patWidth;

        float patternOffset = 0.0f;
        // Special case 1px dotted borders for speed.
        if (patWidth == 1)
            patternOffset = 1.0f;
        else {
            bool evenNumberOfSegments = !(numSegments % 2);
            if (remainder)
                evenNumberOfSegments = !evenNumberOfSegments;
            if (evenNumberOfSegments) {
                if (remainder) {
                    patternOffset += patWidth - remainder;
                    patternOffset += remainder / 2;
                } else
                    patternOffset = patWidth / 2;
            } else {
                if (remainder)
                    patternOffset = (patWidth - remainder) / 2;
            }
        }

        QVector<qreal> dashes;
        dashes << qreal(patWidth) / width << qreal(patWidth) / width;

        QPen pen = p->pen();
        pen.setWidthF(width);
        pen.setCapStyle(Qt::FlatCap);
        pen.setDashPattern(dashes);
        pen.setDashOffset(patternOffset / width);
        p->setPen(pen);
    }

    p->drawLine(p1, p2);

    if (patWidth)
        p->restore();

    p->setRenderHint(QPainter::Antialiasing, antiAlias);
}

// This method is only used to draw the little circles used in lists.
void GraphicsContext::drawEllipse(const IntRect& rect)
{
    if (paintingDisabled())
        return;

    m_data->p()->drawEllipse(rect);
}

void GraphicsContext::strokeArc(const IntRect& rect, int startAngle, int angleSpan)
{
    if (paintingDisabled() || strokeStyle() == NoStroke || strokeThickness() <= 0.0f)
        return;

    QPainter* p = m_data->p();

    ASSERT(p);

    const bool antiAlias = p->testRenderHint(QPainter::Antialiasing);
    p->setRenderHint(QPainter::Antialiasing, true);

    startAngle *= 16;
    angleSpan *= 16;

    if (m_data->hasShadow()) {
        p->save();
        p->translate(m_data->shadow.offset());
        QPen pen(p->pen());
        pen.setColor(m_data->shadow.m_color);
        p->setPen(pen);
        p->drawArc(rect, startAngle, angleSpan);
        p->restore();
    }
    p->drawArc(rect, startAngle, angleSpan);

    p->setRenderHint(QPainter::Antialiasing, antiAlias);
}

void GraphicsContext::drawConvexPolygon(size_t npoints, const FloatPoint* points, bool shouldAntialias)
{
    if (paintingDisabled())
        return;

    if (npoints <= 1)
        return;

    QPolygonF polygon(npoints);

    for (size_t i = 0; i < npoints; i++)
        polygon[i] = points[i];

    QPainter* p = m_data->p();

    ASSERT(p);

    p->save();
    p->setRenderHint(QPainter::Antialiasing, shouldAntialias);
    if (m_data->hasShadow()) {
        p->save();
        p->translate(m_data->shadow.offset());
        if (p->brush().style() != Qt::NoBrush)
            p->setBrush(QBrush(m_data->shadow.m_color));
        QPen pen(p->pen());
        if (pen.style() != Qt::NoPen) {
            pen.setColor(m_data->shadow.m_color);
            p->setPen(pen);
        }
        p->drawConvexPolygon(polygon);
        p->restore();
    }
    p->drawConvexPolygon(polygon);
    p->restore();
}

void GraphicsContext::clipConvexPolygon(size_t numPoints, const FloatPoint* points, bool antialiased)
{
    if (paintingDisabled())
        return;

    if (numPoints <= 1)
        return;

    QPainterPath path(points[0]);
    for (size_t i = 1; i < numPoints; ++i)
        path.lineTo(points[i]);
    path.setFillRule(Qt::WindingFill);
    m_data->p()->setClipPath(path, Qt::IntersectClip);
}

QPen GraphicsContext::pen()
{
    if (paintingDisabled())
        return QPen();

    QPainter* p = m_data->p();

    ASSERT(p);

    return p->pen();
}

void GraphicsContext::fillPath()
{
    if (paintingDisabled())
        return;

    QPainter* p = m_data->p();

    ASSERT(p);

    QPainterPath& path = m_data->currentPath; // Avoid detaching the QPainterPath
    path.setFillRule(toQtFillRule(fillRule()));

    if (m_data->hasShadow()) {
        p->translate(m_data->shadow.offset());
        p->fillPath(path, QColor(m_data->shadow.m_color));
        p->translate(-m_data->shadow.offset());
    }
    /*if (m_common->state.fillPattern) {
        AffineTransform affine;
        p->fillPath(path, QBrush(m_common->state.fillPattern->createPlatformPattern(affine)));
    } */else if (m_common->state.fillGradient) {
        QBrush brush(*m_common->state.fillGradient->platformGradient());
        brush.setTransform(m_common->state.fillGradient->gradientSpaceTransform());
        p->fillPath(path, brush);
    } else
        p->fillPath(path, p->brush());

    m_data->clearCurrentPath();
}

void GraphicsContext::strokePath()
{
    if (paintingDisabled())
        return;

    QPainter* p = m_data->p();

    ASSERT(p);

    QPen pen(p->pen());
    QPainterPath& path = m_data->currentPath; // Avoid detaching the QPainterPath
    path.setFillRule(toQtFillRule(fillRule()));

    if (m_data->hasShadow()) {
        p->translate(m_data->shadow.offset());
        QPen shadowPen(pen);
        shadowPen.setColor(m_data->shadow.m_color);
        p->strokePath(path, shadowPen);
        p->translate(-m_data->shadow.offset());
    }
    /*if (m_common->state.strokePattern) {
        AffineTransform affine;
        pen.setBrush(QBrush(m_common->state.strokePattern->createPlatformPattern(affine)));
        p->setPen(pen);
        p->strokePath(path, pen);
    } */else if (m_common->state.strokeGradient) {
        QBrush brush(*m_common->state.strokeGradient->platformGradient());
        brush.setTransform(m_common->state.strokeGradient->gradientSpaceTransform());
        pen.setBrush(brush);
        p->setPen(pen);
        p->strokePath(path, pen);
    } else
        p->strokePath(path, pen);
    m_data->clearCurrentPath();
}

static inline void drawRepeatPattern(QPainter* p, QPixmap* image, const FloatRect& rect, const bool repeatX, const bool repeatY)
{

    ASSERT(p);

    // Patterns must be painted so that the top left of the first image is anchored at
    // the origin of the coordinate space
    if (image) {
        int w = image->width();
        int h = image->height();
        int startX, startY;
        QRect r(static_cast<int>(rect.x()), static_cast<int>(rect.y()), static_cast<int>(rect.width()), static_cast<int>(rect.height()));

        // startX, startY is the coordinate of the first image we need to put on the left-top of the rect
        if (repeatX && repeatY) {
            // repeat
            // startX, startY is at the left top side of the left-top of the rect
            startX = r.x() >=0 ? r.x() - (r.x() % w) : r.x() - (w - qAbs(r.x()) % w);
            startY = r.y() >=0 ? r.y() - (r.y() % h) : r.y() - (h - qAbs(r.y()) % h);
        } else {
           if (!repeatX && !repeatY) {
               // no-repeat
               // only draw the image once at orgin once, check if need to draw
               QRect imageRect(0, 0, w, h);
               if (imageRect.intersects(r)) {
                   startX = 0;
                   startY = 0;
               } else
                   return;
           } else if (repeatX && !repeatY) {
               // repeat-x
               // startY is fixed, but startX change based on the left-top of the rect
               QRect imageRect(r.x(), 0, r.width(), h);
               if (imageRect.intersects(r)) {
                   startX = r.x() >=0 ? r.x() - (r.x() % w) : r.x() - (w - qAbs(r.x()) % w);
                   startY = 0;
               } else
                   return;
           } else {
               // repeat-y
               // startX is fixed, but startY change based on the left-top of the rect
               QRect imageRect(0, r.y(), w, r.height());
               if (imageRect.intersects(r)) {
                   startX = 0;
                   startY = r.y() >=0 ? r.y() - (r.y() % h) : r.y() - (h - qAbs(r.y()) % h);
               } else
                   return;
           }
        }

        int x = startX;
        int y = startY;
        do {
            // repeat Y
            do {
                // repeat X
                QRect   imageRect(x, y, w, h);
                QRect   intersectRect = imageRect.intersected(r);
                QPoint  destStart(intersectRect.x(), intersectRect.y());
                QRect   sourceRect(intersectRect.x() - imageRect.x(), intersectRect.y() - imageRect.y(), intersectRect.width(), intersectRect.height());

                p->drawPixmap(destStart, *image, sourceRect);
                x += w;
            } while (repeatX && x < r.x() + r.width());
            x = startX;
            y += h;
        } while (repeatY && y < r.y() + r.height());
    }
}

void GraphicsContext::fillRect(const FloatRect& rect)
{
    if (paintingDisabled())
        return;

    QPainter* p = m_data->p();

    ASSERT(p);

    QRectF normalizedRect = rect.normalized();
    ContextShadow* shadow = contextShadow();

    /*if (m_common->state.fillPattern) {
        AffineTransform affine;
        QBrush brush(m_common->state.fillPattern->createPlatformPattern(affine));
        QPixmap* image = m_common->state.fillPattern->tileImage()->nativeImageForCurrentFrame();
        QPainter* shadowPainter = m_data->hasShadow() ? shadow->beginShadowLayer(p, normalizedRect) : 0;
        if (shadowPainter) {
            drawRepeatPattern(shadowPainter, image, normalizedRect, m_common->state.fillPattern->repeatX(), m_common->state.fillPattern->repeatY());
            shadowPainter->setCompositionMode(QPainter::CompositionMode_SourceIn);
            shadowPainter->fillRect(normalizedRect, shadow->m_color);
            shadow->endShadowLayer(p);
        }
        drawRepeatPattern(p, image, normalizedRect, m_common->state.fillPattern->repeatX(), m_common->state.fillPattern->repeatY());
    } else*/ if (m_common->state.fillGradient) {
        QBrush brush(*m_common->state.fillGradient->platformGradient());
        brush.setTransform(m_common->state.fillGradient->gradientSpaceTransform());
        QPainter* shadowPainter = m_data->hasShadow() ? shadow->beginShadowLayer(p, normalizedRect) : 0;
        if (shadowPainter) {
            shadowPainter->fillRect(normalizedRect, brush);
            shadowPainter->setCompositionMode(QPainter::CompositionMode_SourceIn);
            shadowPainter->fillRect(normalizedRect, shadow->m_color);
            shadow->endShadowLayer(p);
        }
        p->fillRect(normalizedRect, brush);
    } else {
        if (m_data->hasShadow()) {
            if (shadow->m_type == ContextShadow::BlurShadow) {
                QPainter* shadowPainter = shadow->beginShadowLayer(p, normalizedRect);
                if (shadowPainter) {
                    shadowPainter->fillRect(normalizedRect, p->brush());
                    shadow->endShadowLayer(p);
                }
            } else {
                // Solid rectangle fill with no blur shadow can be done faster
                // without using the shadow layer at all.
                QColor shadowColor = shadow->m_color;
                shadowColor.setAlphaF(shadowColor.alphaF() * p->brush().color().alphaF());
                p->fillRect(normalizedRect.translated(shadow->offset()), shadowColor);
            }
        }
        p->fillRect(normalizedRect, p->brush());
    }
}


void GraphicsContext::fillRect(const FloatRect& rect, const Color& color, ColorSpace colorSpace)
{
    if (paintingDisabled() || !color.isValid())
        return;

    m_data->solidColor.setColor(color);
    QPainter* p = m_data->p();
    QRectF normalizedRect = rect.normalized();

    if (m_data->hasShadow()) {
        ContextShadow* shadow = contextShadow();

        if (shadow->m_type != ContextShadow::BlurShadow) {
            // We do not need any layer for simple shadow.
            p->fillRect(normalizedRect.translated(shadow->offset()), shadow->m_color);
        } else {
            QPainter* shadowPainter = shadow->beginShadowLayer(p, normalizedRect);
            if (shadowPainter) {
                shadowPainter->setCompositionMode(QPainter::CompositionMode_Source);
                shadowPainter->fillRect(normalizedRect, shadow->m_color);
                shadow->endShadowLayer(p);
            }
        }
    }

    p->fillRect(normalizedRect, m_data->solidColor);
}

void GraphicsContext::fillRoundedRect(const IntRect& rect, const IntSize& topLeft, const IntSize& topRight, const IntSize& bottomLeft, const IntSize& bottomRight, const Color& color, ColorSpace colorSpace)
{
    if (paintingDisabled() || !color.isValid())
        return;

    Path path;
    path.addRoundedRect(rect, topLeft, topRight, bottomLeft, bottomRight);
    QPainter* p = m_data->p();
    if (m_data->hasShadow()) {
        p->translate(m_data->shadow.offset());
        p->fillPath(path.platformPath(), QColor(m_data->shadow.m_color));
        p->translate(-m_data->shadow.offset());
    }
    p->fillPath(path.platformPath(), QColor(color));
}

void GraphicsContext::beginPath()
{
    m_data->clearCurrentPath();
}

void GraphicsContext::addPath(const Path& path)
{
    if (!m_data->currentPath.elementCount()) {
        m_data->currentPath = path.platformPath();
        return;
    }
    m_data->currentPath.addPath(path.platformPath());
}

/*bool GraphicsContext::inTransparencyLayer() const
{
    return m_data->layerCount;
}*/

PlatformPath* GraphicsContext::currentPath()
{
    return &m_data->currentPath;
}

ContextShadow* GraphicsContext::contextShadow()
{
    return &m_data->shadow;
}

void GraphicsContext::clip(const FloatRect& rect)
{
    if (paintingDisabled())
        return;

    m_data->p()->setClipRect(rect, Qt::IntersectClip);
}

void GraphicsContext::clipPath(WindRule clipRule)
{
    if (paintingDisabled())
        return;

    QPainter* p = m_data->p();

    ASSERT(p);

    QPainterPath newPath = m_data->currentPath;
    newPath.setFillRule(clipRule == RULE_EVENODD ? Qt::OddEvenFill : Qt::WindingFill);
    p->setClipPath(newPath, Qt::IntersectClip);
}

void GraphicsContext::drawFocusRing(const QVector<Path>& /*paths*/, int /*width*/, int /*offset*/, const Color& /*color*/)
{
    // FIXME: implement
}

/**
 * Focus ring handling is not handled here. Qt style in
 * RenderTheme handles drawing focus on widgets which
 * need it.
 */
void GraphicsContext::drawFocusRing(const QVector<IntRect>& /*rects*/, int /* width */, int /* offset */, const Color& /*color*/)
{
    if (paintingDisabled() || !color.isValid())
        return;

    unsigned rectCount = rects.size();

    if (!rects.size())
        return;

    QPainter* p = m_data->p();

    ASSERT(p);

    const bool antiAlias = p->testRenderHint(QPainter::Antialiasing);
    p->setRenderHint(QPainter::Antialiasing, m_data->antiAliasingForRectsAndLines);

    const QPen oldPen = p->pen();
    const QBrush oldBrush = p->brush();

    QPen nPen = p->pen();
    nPen.setColor(color);
    p->setBrush(Qt::NoBrush);
    nPen.setStyle(Qt::DotLine);
    p->setPen(nPen);
#if 0
    // FIXME How do we do a bounding outline with Qt?
    QPainterPath path;
    for (int i = 0; i < rectCount; ++i)
        path.addRect(QRectF(rects[i]));
    QPainterPathStroker stroker;
    QPainterPath newPath = stroker.createStroke(path);
    p->strokePath(newPath, nPen);
#else
    for (unsigned i = 0; i < rectCount; ++i)
        p->drawRect(QRectF(rects[i]));
#endif
    p->setPen(oldPen);
    p->setBrush(oldBrush);

    p->setRenderHint(QPainter::Antialiasing, antiAlias);
}

/*void GraphicsContext::drawLineForText(const IntPoint& origin, int width, bool)
{
    if (paintingDisabled())
        return;

    IntPoint endPoint = origin + IntSize(width, 0);
    drawLine(origin, endPoint);
}

void GraphicsContext::drawLineForTextChecking(const IntPoint&, int, TextCheckingLineStyle)
{
    if (paintingDisabled())
        return;

    notImplemented();
}*/

FloatRect GraphicsContext::roundToDevicePixels(const FloatRect& frect)
{
    // It is not enough just to round to pixels in device space. The rotation part of the
    // affine transform matrix to device space can mess with this conversion if we have a
    // rotating image like the hands of the world clock widget. We just need the scale, so
    // we get the affine transform matrix and extract the scale.
    QPainter* painter = platformContext();

    ASSERT(painter);

    QTransform deviceTransform = painter->deviceTransform();
    if (deviceTransform.isIdentity())
        return frect;

    qreal deviceScaleX = sqrtf(deviceTransform.m11() * deviceTransform.m11() + deviceTransform.m12() * deviceTransform.m12());
    qreal deviceScaleY = sqrtf(deviceTransform.m21() * deviceTransform.m21() + deviceTransform.m22() * deviceTransform.m22());

    QPoint deviceOrigin(frect.x() * deviceScaleX, frect.y() * deviceScaleY);
    QPoint deviceLowerRight(frect.right() * deviceScaleX, frect.bottom() * deviceScaleY);

    // Don't let the height or width round to 0 unless either was originally 0
    if (deviceOrigin.y() == deviceLowerRight.y() && frect.height())
        deviceLowerRight.setY(deviceLowerRight.y() + 1);
    if (deviceOrigin.x() == deviceLowerRight.x() && frect.width())
        deviceLowerRight.setX(deviceLowerRight.x() + 1);

    FloatPoint roundedOrigin = FloatPoint(deviceOrigin.x() / deviceScaleX, deviceOrigin.y() / deviceScaleY);
    FloatPoint roundedLowerRight = FloatPoint(deviceLowerRight.x() / deviceScaleX, deviceLowerRight.y() / deviceScaleY);
    return FloatRect(roundedOrigin, roundedLowerRight - roundedOrigin);
}

void GraphicsContext::setPlatformShadow(const FloatSize& size, float blur, const Color& color, ColorSpace)
{
    // Qt doesn't support shadows natively, they are drawn manually in the draw*
    // functions

    if (m_common->state.shadowsIgnoreTransforms) {
        // Meaning that this graphics context is associated with a CanvasRenderingContext
        // We flip the height since CG and HTML5 Canvas have opposite Y axis
        m_common->state.shadowOffset = FloatSize(size.width(), -size.height());
        m_data->shadow = ContextShadow(color, blur, FloatSize(size.width(), -size.height()));
    } else {
        m_data->shadow = ContextShadow(color, blur, FloatSize(size.width(), size.height()));
    }
}

void GraphicsContext::clearPlatformShadow()
{
    m_data->shadow.clear();
}
/*
void GraphicsContext::pushTransparencyLayerInternal(const QRect &rect, qreal opacity, QPixmap& alphaMask)
{
   m_data->layers.push(new TransparencyLayer(m_data->p(), m_data->p()->transform().mapRect(rect), 1.0, alphaMask));
}

void GraphicsContext::beginTransparencyLayer(float opacity)
{
    if (paintingDisabled())
        return;

    int x, y, w, h;
    x = y = 0;
    QPainter* p = m_data->p();
    const QPaintDevice* device = p->device();
    w = device->width();
    h = device->height();

    QRectF clip = m_data->clipBoundingRect();
    QRectF deviceClip = p->transform().mapRect(clip);
    x = int(qBound(qreal(0), deviceClip.x(), (qreal)w));
    y = int(qBound(qreal(0), deviceClip.y(), (qreal)h));
    w = int(qBound(qreal(0), deviceClip.width(), (qreal)w) + 2);
    h = int(qBound(qreal(0), deviceClip.height(), (qreal)h) + 2);

    QPixmap emptyAlphaMask;
    m_data->layers.push(new TransparencyLayer(m_data->p(), QRect(x, y, w, h), opacity, emptyAlphaMask));
    ++m_data->layerCount;
}

void GraphicsContext::endTransparencyLayer()
{
    if (paintingDisabled())
        return;

    TransparencyLayer* layer = m_data->layers.pop();
    if (!layer->alphaMask.isNull()) {
        layer->painter.resetTransform();
        layer->painter.setCompositionMode(QPainter::CompositionMode_DestinationIn);
        layer->painter.drawPixmap(QPoint(), layer->alphaMask);
    } else
        --m_data->layerCount; // see the comment for layerCount
    layer->painter.end();

    QPainter* p = m_data->p();
    p->save();
    p->resetTransform();
    p->setOpacity(layer->opacity);
    p->drawPixmap(layer->offset, layer->pixmap);
    p->restore();

    delete layer;
}*/

void GraphicsContext::clearRect(const FloatRect& rect)
{
    if (paintingDisabled())
        return;

    QPainter* p = m_data->p();

    ASSERT(p);

    QPainter::CompositionMode currentCompositionMode = p->compositionMode();
    if (p->paintEngine()->hasFeature(QPaintEngine::PorterDuff))
        p->setCompositionMode(QPainter::CompositionMode_Source);
    p->fillRect(rect, Qt::transparent);
    if (p->paintEngine()->hasFeature(QPaintEngine::PorterDuff))
        p->setCompositionMode(currentCompositionMode);
}

void GraphicsContext::strokeRect(const FloatRect& rect, float width)
{
    if (paintingDisabled())
        return;

    QPainterPath path;
    path.addRect(rect);
    setStrokeThickness(width);
    m_data->currentPath = path;

    strokePath();
}

void GraphicsContext::setLineCap(LineCap lc)
{
    if (paintingDisabled())
        return;

    QPainter* p = m_data->p();
    QPen nPen = p->pen();
    nPen.setCapStyle(toQtLineCap(lc));
    p->setPen(nPen);
}

void GraphicsContext::setLineDash(const DashArray& dashes, float dashOffset)
{
    QPainter* p = m_data->p();
    QPen pen = p->pen();
    unsigned dashLength = dashes.size();
    if (dashLength) {
        QVector<qreal> pattern;
        unsigned count = dashLength;
        if (dashLength % 2)
            count *= 2;

        float penWidth = narrowPrecisionToFloat(double(pen.widthF()));
        for (unsigned i = 0; i < count; i++)
            pattern.append(dashes[i % dashLength] / penWidth);

        pen.setDashPattern(pattern);
        pen.setDashOffset(dashOffset / penWidth);
    } else
        pen.setStyle(Qt::SolidLine);
    p->setPen(pen);
}

void GraphicsContext::setLineJoin(LineJoin lj)
{
    if (paintingDisabled())
        return;

    QPainter* p = m_data->p();
    QPen nPen = p->pen();
    nPen.setJoinStyle(toQtLineJoin(lj));
    p->setPen(nPen);
}

void GraphicsContext::setMiterLimit(float limit)
{
    if (paintingDisabled())
        return;

    QPainter* p = m_data->p();

    ASSERT(p);

    QPen nPen = p->pen();
    nPen.setMiterLimit(limit);
    p->setPen(nPen);
}

void GraphicsContext::setAlpha(float opacity)
{
    if (paintingDisabled())
        return;
    QPainter* p = m_data->p();

    ASSERT(p);

    p->setOpacity(opacity);
}

void GraphicsContext::setCompositeOperation(CompositeOperator op)
{
    if (paintingDisabled())
        return;

    if (m_data->p()->paintEngine()->hasFeature(QPaintEngine::PorterDuff))
        m_data->p()->setCompositionMode(toQtCompositionMode(op));
}

void GraphicsContext::clip(const Path& path)
{
    if (paintingDisabled())
        return;

    m_data->p()->setClipPath(path.platformPath(), Qt::IntersectClip);
}

void GraphicsContext::canvasClip(const Path& path)
{
    if (paintingDisabled())
        return;

    QPainterPath clipPath = path.platformPath();
    clipPath.setFillRule(Qt::WindingFill);
    m_data->p()->setClipPath(clipPath, Qt::IntersectClip);
}

void GraphicsContext::clipOut(const Path& path)
{
    if (paintingDisabled())
        return;

    QPainter* p = m_data->p();

    ASSERT(p);

    QPainterPath clippedOut = path.platformPath();
    QPainterPath newClip;
    newClip.setFillRule(Qt::OddEvenFill);
    if (p->hasClipping()) {
        newClip.addRect(m_data->clipBoundingRect());
        newClip.addPath(clippedOut);
        p->setClipPath(newClip, Qt::IntersectClip);
    } else {
        QRect windowRect = p->transform().inverted().mapRect(p->window());
        newClip.addRect(windowRect);
        newClip.addPath(clippedOut.intersected(newClip));
        p->setClipPath(newClip);
    }
}

void GraphicsContext::translate(float x, float y)
{
    if (paintingDisabled())
        return;

    m_data->p()->translate(x, y);

    if (!m_data->currentPath.isEmpty()) {
        QTransform matrix;
        m_data->currentPath = m_data->currentPath * matrix.translate(-x, -y);
        m_common->state.pathTransform.translate(x, y);
    }
}

IntPoint GraphicsContext::origin()
{
    if (paintingDisabled())
        return IntPoint();
    const QTransform &transform = m_data->p()->transform();
    return IntPoint(qRound(transform.dx()), qRound(transform.dy()));
}

void GraphicsContext::rotate(float radians)
{
    if (paintingDisabled())
        return;

    m_data->p()->rotate(180 / M_PI*radians);

    if (!m_data->currentPath.isEmpty()) {
        QTransform matrix;
        m_data->currentPath = m_data->currentPath * matrix.rotate(-180 / M_PI*radians);
        m_common->state.pathTransform.rotate(radians);
    }
}

void GraphicsContext::scale(const FloatSize& s)
{
    if (paintingDisabled())
        return;

    m_data->p()->scale(s.width(), s.height());

    if (!m_data->currentPath.isEmpty()) {
        QTransform matrix;
        m_data->currentPath = m_data->currentPath * matrix.scale(1 / s.width(), 1 / s.height());
        m_common->state.pathTransform.scaleNonUniform(s.width(), s.height());
    }
}

void GraphicsContext::clipOut(const IntRect& rect)
{
    if (paintingDisabled())
        return;

    QPainter* p = m_data->p();

    ASSERT(p);

    QPainterPath newClip;
    newClip.setFillRule(Qt::OddEvenFill);
    if (p->hasClipping()) {
        newClip.addRect(m_data->clipBoundingRect());
        newClip.addRect(QRect(rect));
        p->setClipPath(newClip, Qt::IntersectClip);
    } else {
        QRect clipOutRect(rect);
        QRect window = p->transform().inverted().mapRect(p->window());
        clipOutRect &= window;
        newClip.addRect(window);
        newClip.addRect(clipOutRect);
        p->setClipPath(newClip);
    }
}

void GraphicsContext::clipOutEllipseInRect(const IntRect& rect)
{
    if (paintingDisabled())
        return;

    QPainter* p = m_data->p();

    ASSERT(p);

    QPainterPath newClip;
    newClip.setFillRule(Qt::OddEvenFill);
    if (p->hasClipping()) {
        newClip.addRect(m_data->clipBoundingRect());
        newClip.addEllipse(QRect(rect));
        p->setClipPath(newClip, Qt::IntersectClip);
    } else {
        QRect clipOutRect(rect);
        QRect window(p->window());
        clipOutRect &= window;
        newClip.addRect(window);
        newClip.addEllipse(clipOutRect);
        p->setClipPath(newClip);
    }
}

void GraphicsContext::addInnerRoundedRectClip(const IntRect& rect,
                                              int thickness)
{
    if (paintingDisabled())
        return;

    clip(rect);
    QPainterPath path;

    // Add outer ellipse
    path.addEllipse(QRectF(rect.x(), rect.y(), rect.width(), rect.height()));

    // Add inner ellipse.
    path.addEllipse(QRectF(rect.x() + thickness, rect.y() + thickness,
                           rect.width() - (thickness * 2), rect.height() - (thickness * 2)));

    path.setFillRule(Qt::OddEvenFill);

    QPainter* p = m_data->p();

    ASSERT(p);

    const bool antiAlias = p->testRenderHint(QPainter::Antialiasing);
    p->setRenderHint(QPainter::Antialiasing, true);
    p->setClipPath(path, Qt::IntersectClip);
    p->setRenderHint(QPainter::Antialiasing, antiAlias);
}

void GraphicsContext::concatCTM(const AffineTransform& transform)
{
    if (paintingDisabled())
        return;

    m_data->p()->setWorldTransform(transform, true);

    // Transformations to the context shouldn't transform the currentPath.
    // We have to undo every change made to the context from the currentPath
    // to avoid wrong drawings.
    if (!m_data->currentPath.isEmpty() && transform.isInvertible()) {
        QTransform matrix = transform.inverse();
        m_data->currentPath = m_data->currentPath * matrix;
        m_common->state.pathTransform.multiply(transform.toTransformationMatrix());
    }
}

/*void GraphicsContext::setURLForRect(const KURL&, const IntRect&)
{
    notImplemented();
}*/

void GraphicsContext::setPlatformStrokeColor(const Color& color, ColorSpace /*colorSpace*/)
{
    if (paintingDisabled() || !color.isValid())
        return;

    QPainter* p = m_data->p();
    QPen newPen(p->pen());
    m_data->solidColor.setColor(color);
    newPen.setBrush(m_data->solidColor);
    p->setPen(newPen);
}

void GraphicsContext::setPlatformStrokeStyle(const StrokeStyle& strokeStyle)
{
    if (paintingDisabled())
        return;
    QPainter* p = m_data->p();

    ASSERT(p);

    QPen newPen(p->pen());
    newPen.setStyle(toQPenStyle(strokeStyle));
    p->setPen(newPen);
}

void GraphicsContext::setPlatformStrokeThickness(float thickness)
{
    if (paintingDisabled())
        return;
    QPainter* p = m_data->p();

    ASSERT(p);

    QPen newPen(p->pen());
    newPen.setWidthF(thickness);
    p->setPen(newPen);
}

void GraphicsContext::setPlatformFillColor(const Color& color, ColorSpace /*colorSpace*/)
{
    if (paintingDisabled() || !color.isValid())
        return;

    m_data->solidColor.setColor(color);
    m_data->p()->setBrush(m_data->solidColor);
}

void GraphicsContext::setPlatformShouldAntialias(bool enable)
{
    if (paintingDisabled())
        return;
    m_data->p()->setRenderHint(QPainter::Antialiasing, enable);
}

#ifdef Q_WS_WIN

HDC GraphicsContext::getWindowsContext(const IntRect& dstRect, bool supportAlphaBlend, bool mayCreateBitmap)
{
    // painting through native HDC is only supported for plugin, where mayCreateBitmap is always true
    Q_ASSERT(mayCreateBitmap);

    if (dstRect.isEmpty())
        return 0;

    // Create a bitmap DC in which to draw.
    BITMAPINFO bitmapInfo;
    bitmapInfo.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    bitmapInfo.bmiHeader.biWidth         = dstRect.width();
    bitmapInfo.bmiHeader.biHeight        = dstRect.height();
    bitmapInfo.bmiHeader.biPlanes        = 1;
    bitmapInfo.bmiHeader.biBitCount      = 32;
    bitmapInfo.bmiHeader.biCompression   = BI_RGB;
    bitmapInfo.bmiHeader.biSizeImage     = 0;
    bitmapInfo.bmiHeader.biXPelsPerMeter = 0;
    bitmapInfo.bmiHeader.biYPelsPerMeter = 0;
    bitmapInfo.bmiHeader.biClrUsed       = 0;
    bitmapInfo.bmiHeader.biClrImportant  = 0;

    void* pixels = 0;
    HBITMAP bitmap = ::CreateDIBSection(0, &bitmapInfo, DIB_RGB_COLORS, &pixels, 0, 0);
    if (!bitmap)
        return 0;

    HDC displayDC = ::GetDC(0);
    HDC bitmapDC = ::CreateCompatibleDC(displayDC);
    ::ReleaseDC(0, displayDC);

    ::SelectObject(bitmapDC, bitmap);

    // Fill our buffer with clear if we're going to alpha blend.
    if (supportAlphaBlend) {
        BITMAP bmpInfo;
        GetObject(bitmap, sizeof(bmpInfo), &bmpInfo);
        int bufferSize = bmpInfo.bmWidthBytes * bmpInfo.bmHeight;
        memset(bmpInfo.bmBits, 0, bufferSize);
    }

#if !OS(WINCE)
    // Make sure we can do world transforms.
    SetGraphicsMode(bitmapDC, GM_ADVANCED);

    // Apply a translation to our context so that the drawing done will be at (0,0) of the bitmap.
    XFORM xform;
    xform.eM11 = 1.0f;
    xform.eM12 = 0.0f;
    xform.eM21 = 0.0f;
    xform.eM22 = 1.0f;
    xform.eDx = -dstRect.x();
    xform.eDy = -dstRect.y();
    ::SetWorldTransform(bitmapDC, &xform);
#endif

    return bitmapDC;
}

void GraphicsContext::releaseWindowsContext(HDC hdc, const IntRect& dstRect, bool supportAlphaBlend, bool mayCreateBitmap)
{
    // painting through native HDC is only supported for plugin, where mayCreateBitmap is always true
    Q_ASSERT(mayCreateBitmap);

    if (hdc) {

        if (!dstRect.isEmpty()) {

            HBITMAP bitmap = static_cast<HBITMAP>(GetCurrentObject(hdc, OBJ_BITMAP));
            BITMAP info;
            GetObject(bitmap, sizeof(info), &info);
            ASSERT(info.bmBitsPixel == 32);

            QPixmap pixmap = QPixmap::fromWinHBITMAP(bitmap, supportAlphaBlend ? QPixmap::PremultipliedAlpha : QPixmap::NoAlpha);
            m_data->p()->drawPixmap(dstRect, pixmap);

            ::DeleteObject(bitmap);
        }

        ::DeleteDC(hdc);
    }
}
#endif

void GraphicsContext::setImageInterpolationQuality(InterpolationQuality quality)
{
    m_data->imageInterpolationQuality = quality;

    switch (quality) {
    case InterpolationNone:
    case InterpolationLow:
        // use nearest-neigbor
        m_data->p()->setRenderHint(QPainter::SmoothPixmapTransform, false);
        break;

    case InterpolationDefault:
    case InterpolationMedium:
    case InterpolationHigh:
    default:
        // use the filter
        m_data->p()->setRenderHint(QPainter::SmoothPixmapTransform, true);
        break;
    };
}

InterpolationQuality GraphicsContext::imageInterpolationQuality() const
{
    return m_data->imageInterpolationQuality;
}
</file>

<file path="image.cpp">
// this_file: qlith-pro/src/image.cpp
#include "qlith/common.h"

#include "qlith/image.h"
#include "qlith/graphicscontext.h"
#include "qlith/intrect.h"
#include "qlith/affinetransform.h"
#include "qlith/bitmapimage.h"
#include "qlith/mimetyperegistry.h"
#include "qlith/stillimageqt.h"
#include "qlith/sharedbuffer.h"

#include <cmath>

/*#include "config.h"
#include "Image.h"

#include "AffineTransform.h"
#include "BitmapImage.h"
#include "GraphicsContext.h"
#include "IntRect.h"
#include "MIMETypeRegistry.h"
#include "SharedBuffer.h"
#include <math.h>
#include <wtf/StdLibExtras.h>*/

Image::Image(ImageObserver* observer)
    : m_imageObserver(observer)
{
}

Image::~Image()
{
}

Image* Image::nullImage()
{
    //ASSERT(isMainThread());
    DEFINE_STATIC_LOCAL(RefPtr<Image>, nullImage, (BitmapImage::create()));;
    return nullImage.get();
}

bool Image::supportsType(const String& type)
{
    return MIMETypeRegistry::isSupportedImageResourceMIMEType(type);
}

bool Image::setData(PassRefPtr<SharedBuffer> data, bool allDataReceived)
{
    m_data = data;
    if (!m_data.get())
        return true;

    int length = m_data->size();
    if (!length)
        return true;

    return dataChanged(allDataReceived);
}

void Image::fillWithSolidColor(GraphicsContext* ctxt, const FloatRect& dstRect, const Color& color, ColorSpace styleColorSpace, CompositeOperator op)
{
    if (color.alpha() <= 0)
        return;

    ctxt->save();
    ctxt->setCompositeOperation(!color.hasAlpha() && op == CompositeSourceOver ? CompositeCopy : op);
    ctxt->fillRect(dstRect, color, styleColorSpace);
    ctxt->restore();
}

static inline FloatSize calculatePatternScale(const FloatRect& dstRect, const FloatRect& srcRect, Image::TileRule hRule, Image::TileRule vRule)
{
    float scaleX = 1.0f, scaleY = 1.0f;

    if (hRule == Image::StretchTile)
        scaleX = dstRect.width() / srcRect.width();
    if (vRule == Image::StretchTile)
        scaleY = dstRect.height() / srcRect.height();

    if (hRule == Image::RepeatTile)
        scaleX = scaleY;
    if (vRule == Image::RepeatTile)
        scaleY = scaleX;

    return FloatSize(scaleX, scaleY);
}


void Image::drawTiled(GraphicsContext* ctxt, const FloatRect& destRect, const FloatPoint& srcPoint, const FloatSize& scaledTileSize, ColorSpace styleColorSpace, CompositeOperator op)
{
    if (mayFillWithSolidColor()) {
        fillWithSolidColor(ctxt, destRect, solidColor(), styleColorSpace, op);
        return;
    }

    FloatSize intrinsicTileSize = size();
    if (hasRelativeWidth())
        intrinsicTileSize.setWidth(scaledTileSize.width());
    if (hasRelativeHeight())
        intrinsicTileSize.setHeight(scaledTileSize.height());

    FloatSize scale(scaledTileSize.width() / intrinsicTileSize.width(),
                    scaledTileSize.height() / intrinsicTileSize.height());

    FloatRect oneTileRect;
    oneTileRect.setX(destRect.x() + fmodf(fmodf(-srcPoint.x(), scaledTileSize.width()) - scaledTileSize.width(), scaledTileSize.width()));
    oneTileRect.setY(destRect.y() + fmodf(fmodf(-srcPoint.y(), scaledTileSize.height()) - scaledTileSize.height(), scaledTileSize.height()));
    oneTileRect.setSize(scaledTileSize);

    // Check and see if a single draw of the image can cover the entire area we are supposed to tile.
    if (oneTileRect.contains(destRect)) {
        FloatRect visibleSrcRect;
        visibleSrcRect.setX((destRect.x() - oneTileRect.x()) / scale.width());
        visibleSrcRect.setY((destRect.y() - oneTileRect.y()) / scale.height());
        visibleSrcRect.setWidth(destRect.width() / scale.width());
        visibleSrcRect.setHeight(destRect.height() / scale.height());
        draw(ctxt, destRect, visibleSrcRect, styleColorSpace, op);
        return;
    }

    AffineTransform patternTransform = AffineTransform().scaleNonUniform(scale.width(), scale.height());
    FloatRect tileRect(FloatPoint(), intrinsicTileSize);
    drawPattern(ctxt, tileRect, patternTransform, oneTileRect.location(), styleColorSpace, op, destRect);

    startAnimation();
}

// FIXME: Merge with the other drawTiled eventually, since we need a combination of both for some things.
void Image::drawTiled(GraphicsContext* ctxt, const FloatRect& dstRect, const FloatRect& srcRect, TileRule hRule, TileRule vRule, ColorSpace styleColorSpace, CompositeOperator op)
{
    if (mayFillWithSolidColor()) {
        fillWithSolidColor(ctxt, dstRect, solidColor(), styleColorSpace, op);
        return;
    }

    // FIXME: We do not support 'round' yet.  For now just map it to 'repeat'.
    if (hRule == RoundTile)
        hRule = RepeatTile;
    if (vRule == RoundTile)
        vRule = RepeatTile;

    FloatSize scale = calculatePatternScale(dstRect, srcRect, hRule, vRule);
    AffineTransform patternTransform = AffineTransform().scaleNonUniform(scale.width(), scale.height());

    // We want to construct the phase such that the pattern is centered (when stretch is not
    // set for a particular rule).
    float hPhase = scale.width() * srcRect.x();
    float vPhase = scale.height() * srcRect.y();
    if (hRule == Image::RepeatTile)
        hPhase -= fmodf(dstRect.width(), scale.width() * srcRect.width()) / 2.0f;
    if (vRule == Image::RepeatTile)
        vPhase -= fmodf(dstRect.height(), scale.height() * srcRect.height()) / 2.0f;
    FloatPoint patternPhase(dstRect.x() - hPhase, dstRect.y() - vPhase);

    drawPattern(ctxt, srcRect, patternTransform, patternPhase, styleColorSpace, op, dstRect);

    startAnimation();
}

//////////////////////////

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/qt/ImageQt.cpp

#include "common.h"

#include "image.h"

#include "affinetransform.h"
#include "imageobserver.h"
#include "bitmapimage.h"
#include "floatrect.h"
//#include "PlatformString.h"
#include "graphicscontext.h"
#include "stillimageqt.h"
//#include "qwebsettings.h"

#include <QPixmap>
#include <QPainter>
#include <QImage>
#include <QImageReader>
#include <QTransform>

#include <QDebug>

#include <math.h>

// This function loads resources into WebKit
/*static QPixmap loadResourcePixmap(const char *name)
{
    QPixmap pixmap;
    if (qstrcmp(name, "missingImage") == 0)
        pixmap = QWebSettings::webGraphic(QWebSettings::MissingImageGraphic);
    else if (qstrcmp(name, "nullPlugin") == 0)
        pixmap = QWebSettings::webGraphic(QWebSettings::MissingPluginGraphic);
    else if (qstrcmp(name, "urlIcon") == 0)
        pixmap = QWebSettings::webGraphic(QWebSettings::DefaultFrameIconGraphic);
    else if (qstrcmp(name, "textAreaResizeCorner") == 0)
        pixmap = QWebSettings::webGraphic(QWebSettings::TextAreaSizeGripCornerGraphic);
    else if (qstrcmp(name, "deleteButton") == 0)
        pixmap = QWebSettings::webGraphic(QWebSettings::DeleteButtonGraphic);
    else if (!qstrcmp(name, "inputSpeech"))
        pixmap = QWebSettings::webGraphic(QWebSettings::InputSpeechButtonGraphic);

    return pixmap;
}*/

bool FrameData::clear(bool clearMetadata)
{
    if (clearMetadata)
        m_haveMetadata = false;

    if (m_frame) {
        delete m_frame;
        m_frame = 0;
        return true;
    }
    return false;
}


// ================================================
// Image Class
// ================================================

/*PassRefPtr<Image> Image::loadPlatformResource(const char* name)
{
    return StillImage::create(loadResourcePixmap(name));
}*/

void Image::drawPattern(GraphicsContext* ctxt, const FloatRect& tileRect, const AffineTransform& patternTransform,
                        const FloatPoint& phase, ColorSpace, CompositeOperator op, const FloatRect& destRect)
{
    QPixmap* framePixmap = nativeImageForCurrentFrame();
    if (!framePixmap) // If it's too early we won't have an image yet.
        return;

    QPixmap pixmap = *framePixmap;
    QRect tr = QRectF(tileRect).toRect();
    if (tr.x() || tr.y() || tr.width() != pixmap.width() || tr.height() != pixmap.height())
        pixmap = pixmap.copy(tr);

    QBrush b(pixmap);
    b.setTransform(patternTransform);
    ctxt->save();
    ctxt->setCompositeOperation(op);
    QPainter* p = ctxt->platformContext();
    if (!pixmap.hasAlpha() && p->compositionMode() == QPainter::CompositionMode_SourceOver)
        p->setCompositionMode(QPainter::CompositionMode_Source);
    p->setBrushOrigin(phase);
    p->fillRect(destRect, b);
    ctxt->restore();

    if (imageObserver())
        imageObserver()->didDraw(this);
}

BitmapImage::BitmapImage(QPixmap* pixmap, ImageObserver* observer)
    : Image(observer)
    , m_currentFrame(0)
    , m_frames(0)

    // TODO
    //, m_frameTimer(0)

    , m_repetitionCount(cAnimationNone)
    , m_repetitionCountStatus(Unknown)
    , m_repetitionsComplete(0)
    , m_isSolidColor(false)
    , m_checkedForSolidColor(false)
    , m_animationFinished(true)
    , m_allDataReceived(true)
    , m_haveSize(true)
    , m_sizeAvailable(true)
    , m_decodedSize(0)
    , m_haveFrameCount(true)
    , m_frameCount(1)
{
    initPlatformData();

    int width = pixmap->width();
    int height = pixmap->height();
    m_decodedSize = width * height * 4;
    m_size = IntSize(width, height);

    //m_frames.grow(1);
    m_frames.reserve(1);

    m_frames[0].m_frame = pixmap;
    m_frames[0].m_hasAlpha = pixmap->hasAlpha();
    m_frames[0].m_haveMetadata = true;
    checkForSolidColor();
}

void BitmapImage::initPlatformData()
{
}

void BitmapImage::invalidatePlatformData()
{
}

// Drawing Routines
void BitmapImage::draw(GraphicsContext* ctxt, const FloatRect& dst,
                       const FloatRect& src, ColorSpace styleColorSpace, CompositeOperator op)
{
    FloatRect normalizedDst = dst.normalized();
    FloatRect normalizedSrc = src.normalized();

    startAnimation();

    QPixmap* image = nativeImageForCurrentFrame();
    if (!image)
        return;

    if (mayFillWithSolidColor()) {
        fillWithSolidColor(ctxt, normalizedDst, solidColor(), styleColorSpace, op);
        return;
    }

    QPainter* painter(ctxt->platformContext());

    QPainter::CompositionMode compositionMode = GraphicsContext::toQtCompositionMode(op);

    if (!image->hasAlpha() && painter->compositionMode() == QPainter::CompositionMode_SourceOver)
        compositionMode = QPainter::CompositionMode_Source;

    QPainter::CompositionMode lastCompositionMode = painter->compositionMode();
    painter->setCompositionMode(compositionMode);

    FloatSize shadowOffset;
    float shadowBlur;
    Color shadowColor;
    if (ctxt->getShadow(shadowOffset, shadowBlur, shadowColor)) {
        FloatRect shadowImageRect(normalizedDst);
        shadowImageRect.move(shadowOffset.width(), shadowOffset.height());

        QImage shadowImage(QSize(static_cast<int>(normalizedSrc.width()), static_cast<int>(normalizedSrc.height())), QImage::Format_ARGB32_Premultiplied);
        QPainter p(&shadowImage);
        p.setCompositionMode(QPainter::CompositionMode_Source);
        p.fillRect(shadowImage.rect(), shadowColor);
        p.setCompositionMode(QPainter::CompositionMode_DestinationIn);
        p.drawPixmap(QRect(0, 0, normalizedDst.width(), normalizedDst.height()), *image, normalizedSrc);
        p.end();
        painter->drawImage(shadowImageRect, shadowImage, normalizedSrc);
    }

    // Test using example site at
    // http://www.meyerweb.com/eric/css/edge/complexspiral/demo.html
    painter->drawPixmap(normalizedDst, *image, normalizedSrc);

    painter->setCompositionMode(lastCompositionMode);

    if (imageObserver())
        imageObserver()->didDraw(this);
}

void BitmapImage::checkForSolidColor()
{
    m_isSolidColor = false;
    m_checkedForSolidColor = true;

    if (frameCount() > 1)
        return;

    QPixmap* framePixmap = frameAtIndex(0);
    if (!framePixmap || framePixmap->width() != 1 || framePixmap->height() != 1)
        return;

    m_isSolidColor = true;
    m_solidColor = QColor::fromRgba(framePixmap->toImage().pixel(0, 0));
}
</file>

<file path="imagedecoder.cpp">
// this_file: qlith-pro/src/imagedecoder.cpp
#ifndef QT_CORE_LIB

#include "qlith/common.h"
#include "qlith/imagedecoder.h"

//#include "config.h"

#include <algorithm>
#include <cmath>

//#include "BMPImageDecoder.h"
//#include "GIFImageDecoder.h"
//#include "ICOImageDecoder.h"
//#include "JPEGImageDecoder.h"
//#include "PNGImageDecoder.h"
#include "qlith/sharedbuffer.h"

using namespace std;

static unsigned copyFromSharedBuffer(char* buffer, unsigned bufferLength, const SharedBuffer& sharedBuffer, unsigned offset)
{
    unsigned bytesExtracted = 0;
    const char* moreData;
    while (unsigned moreDataLength = sharedBuffer.getSomeData(moreData, offset)) {
        unsigned bytesToCopy = min(bufferLength - bytesExtracted, moreDataLength);
        memcpy(buffer + bytesExtracted, moreData, bytesToCopy);
        bytesExtracted += bytesToCopy;
        if (bytesExtracted == bufferLength)
            break;
        offset += bytesToCopy;
    }
    return bytesExtracted;
}

ImageDecoder* ImageDecoder::create(const SharedBuffer& data, bool premultiplyAlpha)
{
    // We need at least 4 bytes to figure out what kind of image we're dealing
    // with.
    static const unsigned maxMarkerLength = 4;
    char contents[maxMarkerLength];
    unsigned length = copyFromSharedBuffer(contents, maxMarkerLength, data, 0);
    if (length < maxMarkerLength)
        return 0;

    // GIFs begin with GIF8(7 or 9).
    //if (strncmp(contents, "GIF8", 4) == 0)
    //    return new GIFImageDecoder(premultiplyAlpha);

    // Test for PNG.
    //if (!memcmp(contents, "\x89\x50\x4E\x47", 4))
    //    return new PNGImageDecoder(premultiplyAlpha);

    // JPEG
    //if (!memcmp(contents, "\xFF\xD8\xFF", 3))
    //    return new JPEGImageDecoder(premultiplyAlpha);
    //
    //// BMP
    //if (strncmp(contents, "BM", 2) == 0)
    //    return new BMPImageDecoder(premultiplyAlpha);
    //
    //// ICOs always begin with a 2-byte 0 followed by a 2-byte 1.
    //// CURs begin with 2-byte 0 followed by 2-byte 2.
    //if (!memcmp(contents, "\x00\x00\x01\x00", 4) || !memcmp(contents, "\x00\x00\x02\x00", 4))
    //    return new ICOImageDecoder(premultiplyAlpha);

    // Give up. We don't know what the heck this is.
    return 0;
}

//#if !PLATFORM(SKIA)

RGBA32Buffer::RGBA32Buffer()
    : m_hasAlpha(false)
    , m_status(FrameEmpty)
    , m_duration(0)
    , m_disposalMethod(DisposeNotSpecified)
    , m_premultiplyAlpha(true)
{
}

RGBA32Buffer& RGBA32Buffer::operator=(const RGBA32Buffer& other)
{
    if (this == &other)
        return *this;

    copyBitmapData(other);
    setRect(other.rect());
    setStatus(other.status());
    setDuration(other.duration());
    setDisposalMethod(other.disposalMethod());
    setPremultiplyAlpha(other.premultiplyAlpha());
    return *this;
}

void RGBA32Buffer::clear()
{
    m_bytes.clear();
    m_status = FrameEmpty;
    // NOTE: Do not reset other members here; clearFrameBufferCache() calls this
    // to free the bitmap data, but other functions like initFrameBuffer() and
    // frameComplete() may still need to read other metadata out of this frame
    // later.
}

void RGBA32Buffer::zeroFill()
{
    m_bytes.fill(0);
    m_hasAlpha = true;
}

bool RGBA32Buffer::copyBitmapData(const RGBA32Buffer& other)
{
    if (this == &other)
        return true;

    m_bytes = other.m_bytes;
    m_size = other.m_size;
    setHasAlpha(other.m_hasAlpha);
    return true;
}

bool RGBA32Buffer::setSize(int newWidth, int newHeight)
{
    // NOTE: This has no way to check for allocation failure if the requested
    // size was too big...
    m_bytes.resize(newWidth * newHeight);
    m_size = IntSize(newWidth, newHeight);

    // Zero the image.
    zeroFill();

    return true;
}

bool RGBA32Buffer::hasAlpha() const
{
    return m_hasAlpha;
}

void RGBA32Buffer::setHasAlpha(bool alpha)
{
    m_hasAlpha = alpha;
}

void RGBA32Buffer::setStatus(FrameStatus status)
{
    m_status = status;
}

int RGBA32Buffer::width() const
{
    return m_size.width();
}

int RGBA32Buffer::height() const
{
    return m_size.height();
}

//#endif

namespace {

enum MatchType {
    Exact,
    UpperBound,
    LowerBound
};

inline void fillScaledValues(QVector<int>& scaledValues, double scaleRate, int length)
{
    double inflateRate = 1. / scaleRate;
    //scaledValues.reserveCapacity(static_cast<int>(length * scaleRate + 0.5));
    scaledValues.reserve(static_cast<int>(length * scaleRate + 0.5));
    for (int scaledIndex = 0; ; ++scaledIndex) {
        int index = static_cast<int>(scaledIndex * inflateRate + 0.5);
        if (index >= length)
            break;
        scaledValues.append(index);
    }
}

template <MatchType type> int getScaledValue(const QVector<int>& scaledValues, int valueToMatch, int searchStart)
{
    if (scaledValues.isEmpty())
        return valueToMatch;

    const int* dataStart = scaledValues.data();
    const int* dataEnd = dataStart + scaledValues.size();
    const int* matched = std::lower_bound(dataStart + searchStart, dataEnd, valueToMatch);
    switch (type) {
    case Exact:
        return matched != dataEnd && *matched == valueToMatch ? matched - dataStart : -1;
    case LowerBound:
        return matched != dataEnd && *matched == valueToMatch ? matched - dataStart : matched - dataStart - 1;
    case UpperBound:
    default:
        return matched != dataEnd ? matched - dataStart : -1;
    }
}

}

void ImageDecoder::prepareScaleDataIfNecessary()
{
    m_scaled = false;
    m_scaledColumns.clear();
    m_scaledRows.clear();

    int width = size().width();
    int height = size().height();
    int numPixels = height * width;
    if (m_maxNumPixels <= 0 || numPixels <= m_maxNumPixels)
        return;

    m_scaled = true;
    double scale = sqrt(m_maxNumPixels / (double)numPixels);
    fillScaledValues(m_scaledColumns, scale, width);
    fillScaledValues(m_scaledRows, scale, height);
}

int ImageDecoder::upperBoundScaledX(int origX, int searchStart)
{
    return getScaledValue<UpperBound>(m_scaledColumns, origX, searchStart);
}

int ImageDecoder::lowerBoundScaledX(int origX, int searchStart)
{
    return getScaledValue<LowerBound>(m_scaledColumns, origX, searchStart);
}

int ImageDecoder::upperBoundScaledY(int origY, int searchStart)
{
    return getScaledValue<UpperBound>(m_scaledRows, origY, searchStart);
}

int ImageDecoder::lowerBoundScaledY(int origY, int searchStart)
{
    return getScaledValue<LowerBound>(m_scaledRows, origY, searchStart);
}

int ImageDecoder::scaledY(int origY, int searchStart)
{
    return getScaledValue<Exact>(m_scaledRows, origY, searchStart);
}

#endif
</file>

<file path="imagedecoderqt.cpp">
// this_file: qlith-pro/src/imagedecoderqt.cpp
#include "qlith/imagedecoderqt.h"

//#include "config.h"
//#include "imagedecoderqt.h"

#include <QtCore/QByteArray>
#include <QtCore/QBuffer>

#include <QtGui/QImageReader>
#include <QDebug>

ImageDecoder* ImageDecoder::create(const SharedBuffer& data, bool premultiplyAlpha)
{
    // We need at least 4 bytes to figure out what kind of image we're dealing with.
    if (data.size() < 4)
        return 0;

    return new ImageDecoderQt(premultiplyAlpha);
}

ImageDecoderQt::ImageDecoderQt(bool premultiplyAlpha)
    : ImageDecoder(premultiplyAlpha)
    , m_repetitionCount(cAnimationNone)
{
}

ImageDecoderQt::~ImageDecoderQt()
{
}

void ImageDecoderQt::setData(SharedBuffer* data, bool allDataReceived)
{
    if (failed())
        return;

    // No progressive loading possible
    if (!allDataReceived)
        return;

    // Cache our own new data.
    ImageDecoder::setData(data, allDataReceived);

    // We expect to be only called once with allDataReceived
    ASSERT(!m_buffer);
    ASSERT(!m_reader);

    // Attempt to load the data
    QByteArray imageData = QByteArray::fromRawData(m_data->data(), m_data->size());

    //m_buffer.set(new QBuffer);
    m_buffer = adoptOwnPtr<QBuffer>( );

    m_buffer->setData(imageData);
    m_buffer->open(QIODevice::ReadOnly | QIODevice::Unbuffered);

    // return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
    //m_reader.set(new QImageReader(m_buffer.get(), m_format));
    //std::unique_ptr<QImageReader> n = std::make_unique<QImageReader>(m_buffer.get(), m_format);
    m_reader = adoptOwnPtr<QImageReader>(m_buffer.get(), m_format);

    // This will force the JPEG decoder to use JDCT_IFAST
    m_reader->setQuality(49);

    // QImageReader only allows retrieving the format before reading the image
    m_format = m_reader->format();
}

bool ImageDecoderQt::isSizeAvailable()
{
    if (!ImageDecoder::isSizeAvailable() && m_reader)
        internalDecodeSize();

    return ImageDecoder::isSizeAvailable();
}

size_t ImageDecoderQt::frameCount()
{
    if (m_frameBufferCache.isEmpty() && m_reader) {
        if (m_reader->supportsAnimation()) {
            int imageCount = m_reader->imageCount();

            // Fixup for Qt decoders... imageCount() is wrong
            // and jumpToNextImage does not work either... so
            // we will have to parse everything...
            if (!imageCount)
                forceLoadEverything();
            else {
                m_frameBufferCache.resize(imageCount);
                for (size_t i = 0; i < m_frameBufferCache.size(); ++i)
                    m_frameBufferCache[i].setPremultiplyAlpha(m_premultiplyAlpha);
            }
        } else {
            m_frameBufferCache.resize(1);
            m_frameBufferCache[0].setPremultiplyAlpha(m_premultiplyAlpha);
        }
    }

    return m_frameBufferCache.size();
}

int ImageDecoderQt::repetitionCount() const
{
    if (m_reader && m_reader->supportsAnimation())
        m_repetitionCount = m_reader->loopCount();
    return m_repetitionCount;
}

String ImageDecoderQt::filenameExtension() const
{
    //QString str;
    //m_format.data();
    return QString(QByteArray(m_format.data(), m_format.length()));
};

RGBA32Buffer* ImageDecoderQt::frameBufferAtIndex(size_t index)
{
    // In case the ImageDecoderQt got recreated we don't know
    // yet how many images we are going to have and need to
    // find that out now.
    size_t count = m_frameBufferCache.size();
    if (!failed() && !count) {
        internalDecodeSize();
        count = frameCount();
    }

    if (index >= count)
        return 0;

    RGBA32Buffer& frame = m_frameBufferCache[index];
    if (frame.status() != RGBA32Buffer::FrameComplete && m_reader)
        internalReadImage(index);
    return &frame;
}

void ImageDecoderQt::clearFrameBufferCache(size_t /*index*/)
{
}

void ImageDecoderQt::internalDecodeSize()
{
    ASSERT(m_reader);

    // If we have a QSize() something failed
    QSize size = m_reader->size();
    if (size.isEmpty()) {
        setFailed();
        return clearPointers();
    }

    setSize(size.width(), size.height());
}

void ImageDecoderQt::internalReadImage(size_t frameIndex)
{
    ASSERT(m_reader);

    if (m_reader->supportsAnimation())
        m_reader->jumpToImage(frameIndex);
    else if (frameIndex) {
        setFailed();
        return clearPointers();
    }

    if (!internalHandleCurrentImage(frameIndex))
      setFailed();

    // Attempt to return some memory
    for (int i = 0; i < m_frameBufferCache.size(); ++i) {
        if (m_frameBufferCache[i].status() != RGBA32Buffer::FrameComplete)
            return;
    }

    clearPointers();
}

bool ImageDecoderQt::internalHandleCurrentImage(size_t frameIndex)
{
    QPixmap pixmap;

#if QT_VERSION >= QT_VERSION_CHECK(4, 7, 0)
    pixmap = QPixmap::fromImageReader(m_reader.get());
#else
    QImage img;
    if (m_reader->read(&img))
        pixmap = QPixmap::fromImage(img);
#endif

    if (pixmap.isNull()) {
        frameCount();
        repetitionCount();
        clearPointers();
        return false;
    }

    // now into the RGBA32Buffer - even if the image is not
    RGBA32Buffer* const buffer = &m_frameBufferCache[frameIndex];
    buffer->setRect(m_reader->currentImageRect());
    buffer->setStatus(RGBA32Buffer::FrameComplete);
    buffer->setDuration(m_reader->nextImageDelay());
    buffer->setPixmap(pixmap);
    return true;
}

// The QImageIOHandler is not able to tell us how many frames
// we have and we need to parse every image. We do this by
// increasing the m_frameBufferCache by one and try to parse
// the image. We stop when QImage::read fails and then need
// to resize the m_frameBufferCache to the final size and update
// the failed bit. If we failed to decode the first image
// then we truly failed to decode, otherwise we're OK.

// TODO: Do not increment the m_frameBufferCache.size() by one but more than one
void ImageDecoderQt::forceLoadEverything()
{
    int imageCount = 0;

    do {
        m_frameBufferCache.resize(++imageCount);
    } while (internalHandleCurrentImage(imageCount - 1));

    // If we failed decoding the first image we actually
    // have no images and need to set the failed bit.
    // Otherwise, we want to forget about
    // the last attempt to decode a image.
    m_frameBufferCache.resize(imageCount - 1);
    for (size_t i = 0; i < m_frameBufferCache.size(); ++i)
        m_frameBufferCache[i].setPremultiplyAlpha(m_premultiplyAlpha);
    if (imageCount == 1)
      setFailed();
}

void ImageDecoderQt::clearPointers()
{
    //m_reader.clear();
    //m_buffer.clear();
    m_reader.reset();
    m_buffer.reset();
}
</file>

<file path="imageobserver.cpp">
// this_file: qlith-pro/src/imageobserver.cpp
#include "qlith/imageobserver.h"
</file>

<file path="imagesource.cpp">
// this_file: qlith-pro/src/imagesource.cpp
#include "qlith/imagesource.h"
#include "qlith/common.h"

//#include "config.h"
//#include "ImageSource.h"

#include "qlith/imagedecoderqt.h"

/*#if ENABLE(IMAGE_DECODER_DOWN_SAMPLING)
unsigned ImageSource::s_maxPixelsPerDecodedImage = 1024 * 1024;
#endif*/

ImageSource::ImageSource(bool premultiplyAlpha)
    : m_decoder(0)
    , m_premultiplyAlpha(premultiplyAlpha)
{
}

ImageSource::~ImageSource()
{
    clear(true);
}

void ImageSource::clear(bool destroyAll, size_t clearBeforeFrame, SharedBuffer* data, bool allDataReceived)
{
    if (!destroyAll) {
        if (m_decoder)
            m_decoder->clearFrameBufferCache(clearBeforeFrame);
        return;
    }

    delete m_decoder;
    m_decoder = 0;
    if (data)
        setData(data, allDataReceived);
}

bool ImageSource::initialized() const
{
    return m_decoder;
}

void ImageSource::setData(SharedBuffer* data, bool allDataReceived)
{
    // Make the decoder by sniffing the bytes.
    // This method will examine the data and instantiate an instance of the appropriate decoder plugin.
    // If insufficient bytes are available to determine the image type, no decoder plugin will be
    // made.
    if (!m_decoder) {
        m_decoder = static_cast<NativeImageSourcePtr>(ImageDecoder::create(*data, m_premultiplyAlpha));
/*#if ENABLE(IMAGE_DECODER_DOWN_SAMPLING)
        if (m_decoder && s_maxPixelsPerDecodedImage)
            m_decoder->setMaxNumPixels(s_maxPixelsPerDecodedImage);
#endif*/
    }

    if (m_decoder)
        m_decoder->setData(data, allDataReceived);
}

String ImageSource::filenameExtension() const
{
    return m_decoder ? m_decoder->filenameExtension() : String();
}

bool ImageSource::isSizeAvailable()
{
    return m_decoder && m_decoder->isSizeAvailable();
}

IntSize ImageSource::size() const
{
    return m_decoder ? m_decoder->size() : IntSize();
}

IntSize ImageSource::frameSizeAtIndex(size_t index) const
{
    return m_decoder ? m_decoder->frameSizeAtIndex(index) : IntSize();
}

bool ImageSource::getHotSpot(IntPoint&) const
{
    return false;
}

int ImageSource::repetitionCount()
{
    return m_decoder ? m_decoder->repetitionCount() : cAnimationNone;
}

size_t ImageSource::frameCount() const
{
    return m_decoder ? m_decoder->frameCount() : 0;
}

NativeImagePtr ImageSource::createFrameAtIndex(size_t index)
{
    if (!m_decoder)
        return 0;

    RGBA32Buffer* buffer = m_decoder->frameBufferAtIndex(index);
    if (!buffer || buffer->status() == RGBA32Buffer::FrameEmpty)
        return 0;

    // Zero-height images can cause problems for some ports.  If we have an
    // empty image dimension, just bail.
    if (size().isEmpty())
        return 0;

    // Return the buffer contents as a native image.  For some ports, the data
    // is already in a native container, and this just increments its refcount.
    return buffer->asNewNativeImage();
}

float ImageSource::frameDurationAtIndex(size_t index)
{
    if (!m_decoder)
        return 0;

    RGBA32Buffer* buffer = m_decoder->frameBufferAtIndex(index);
    if (!buffer || buffer->status() == RGBA32Buffer::FrameEmpty)
        return 0;

    // Many annoying ads specify a 0 duration to make an image flash as quickly
    // as possible.  We follow WinIE's behavior and use a duration of 100 ms
    // for any frames that specify a duration of <= 50 ms.  See
    // <http://bugs.webkit.org/show_bug.cgi?id=14413> or Radar 4051389 for
    // more.
    const float duration = buffer->duration() / 1000.0f;
    return (duration < 0.051f) ? 0.100f : duration;
}

bool ImageSource::frameHasAlphaAtIndex(size_t index)
{
    // When a frame has not finished decoding, always mark it as having alpha.
    // Ports that check the result of this function to determine their
    // compositing op need this in order to not draw the undecoded portion as
    // black.
    // TODO: Perhaps we should ensure that each individual decoder returns true
    // in this case.
    return !frameIsCompleteAtIndex(index)
        || m_decoder->frameBufferAtIndex(index)->hasAlpha();
}

bool ImageSource::frameIsCompleteAtIndex(size_t index)
{
    if (!m_decoder)
        return false;

    RGBA32Buffer* buffer = m_decoder->frameBufferAtIndex(index);
    return buffer && buffer->status() == RGBA32Buffer::FrameComplete;
}
</file>

<file path="intpoint.cpp">
// this_file: qlith-pro/src/intpoint.cpp
#include "qlith/intpoint.h"

#include <QPoint>

/*IntPoint::IntPoint()
{

}*/

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/qt/IntPointQt.cpp
IntPoint::IntPoint(const QPoint& p)
    : m_x(p.x())
    , m_y(p.y())
{
}

IntPoint::operator QPoint() const
{
    return QPoint(m_x, m_y);
}
</file>

<file path="intrect.cpp">
// this_file: qlith-pro/src/intrect.cpp
#include "qlith/intrect.h"

#include "qlith/common.h"

#include "qlith/floatrect.h"

#include <algorithm>

#include <QRect>

using std::max;
using std::min;

IntRect::IntRect(const FloatRect& r)
    : m_location(IntPoint(static_cast<int>(r.x()), static_cast<int>(r.y())))
    , m_size(IntSize(static_cast<int>(r.width()), static_cast<int>(r.height())))
{
}

bool IntRect::intersects(const IntRect& other) const
{
    // Checking emptiness handles negative widths as well as zero.
    return !isEmpty() && !other.isEmpty()
        && x() < other.right() && other.x() < right()
        && y() < other.bottom() && other.y() < bottom();
}

bool IntRect::contains(const IntRect& other) const
{
    return x() <= other.x() && right() >= other.right()
        && y() <= other.y() && bottom() >= other.bottom();
}

void IntRect::intersect(const IntRect& other)
{
    int l = max(x(), other.x());
    int t = max(y(), other.y());
    int r = min(right(), other.right());
    int b = min(bottom(), other.bottom());

    // Return a clean empty rectangle for non-intersecting cases.
    if (l >= r || t >= b) {
        l = 0;
        t = 0;
        r = 0;
        b = 0;
    }

    m_location.setX(l);
    m_location.setY(t);
    m_size.setWidth(r - l);
    m_size.setHeight(b - t);
}

void IntRect::unite(const IntRect& other)
{
    // Handle empty special cases first.
    if (other.isEmpty())
        return;
    if (isEmpty()) {
        *this = other;
        return;
    }

    int l = min(x(), other.x());
    int t = min(y(), other.y());
    int r = max(right(), other.right());
    int b = max(bottom(), other.bottom());

    m_location.setX(l);
    m_location.setY(t);
    m_size.setWidth(r - l);
    m_size.setHeight(b - t);
}

void IntRect::scale(float s)
{
    m_location.setX((int)(x() * s));
    m_location.setY((int)(y() * s));
    m_size.setWidth((int)(width() * s));
    m_size.setHeight((int)(height() * s));
}

IntRect unionRect(const QVector<IntRect>& rects)
{
    IntRect result;

    size_t count = rects.size();
    for (size_t i = 0; i < count; ++i)
        result.unite(rects[i]);

    return result;
}


/////////////
// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/qt/IntRectQt.cpp

IntRect::IntRect(const QRect& r)
    : m_location(r.topLeft())
    , m_size(r.width(), r.height())
{
}

IntRect::operator QRect() const
{
    return QRect(x(), y(), width(), height());
}
</file>

<file path="intsize.cpp">
// this_file: qlith-pro/src/intsize.cpp
#include "qlith/intsize.h"

#include <QSize>

/*IntSize::IntSize()
{

}*/

// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/qt/IntSizeQt.cpp
IntSize::IntSize(const QSize& r)
    : m_width(r.width())
    , m_height(r.height())
{
}

IntSize::operator QSize() const
{
    return QSize(width(), height());
}
</file>

<file path="litehtml-qt.js_plugin_import.cpp">
// This file is autogenerated by qmake. It imports static plugin classes for
// static plugins specified using QTPLUGIN and QT_PLUGIN_CLASS.<plugin> variables.
#include <QtPlugin>
Q_IMPORT_PLUGIN(QWasmIntegrationPlugin)
Q_IMPORT_PLUGIN(QGifPlugin)
Q_IMPORT_PLUGIN(QICNSPlugin)
Q_IMPORT_PLUGIN(QICOPlugin)
Q_IMPORT_PLUGIN(QJpegPlugin)
Q_IMPORT_PLUGIN(QTgaPlugin)
Q_IMPORT_PLUGIN(QTiffPlugin)
Q_IMPORT_PLUGIN(QWbmpPlugin)
Q_IMPORT_PLUGIN(QWebpPlugin)
Q_IMPORT_PLUGIN(QEglFSEmulatorIntegrationPlugin)
</file>

<file path="mimetyperegistry.cpp">
// this_file: qlith-pro/src/mimetyperegistry.cpp
#include "qlith/mimetyperegistry.h"

#include "qlith/common.h"

//#include "ArchiveFactory.h"
//#include "MediaPlayer.h"

/*#include "config.h"
#include "MIMETypeRegistry.h"

#include "ArchiveFactory.h"
#include "MediaPlayer.h"
#include <wtf/HashMap.h>
#include <wtf/HashSet.h>
#include <wtf/StdLibExtras.h>
#include <wtf/text/StringHash.h>*/

#include <qimagereader.h>
#include <qimagewriter.h>

static HashSet<String>* supportedImageResourceMIMETypes;
static HashSet<String>* supportedImageMIMETypes;
static HashSet<String>* supportedImageMIMETypesForEncoding;
static HashSet<String>* supportedJavaScriptMIMETypes;
static HashSet<String>* supportedNonImageMIMETypes;
static HashSet<String>* supportedMediaMIMETypes;

typedef HashMap<String, QVector<String>*/*, CaseFoldingHash*/> MediaMIMETypeMap;

static void initializeSupportedImageMIMETypes()
{
//#elif PLATFORM(QT)
    QList<QByteArray> formats = QImageReader::supportedImageFormats();
    for (size_t i = 0; i < static_cast<size_t>(formats.size()); ++i) {
/*#if ENABLE(SVG)
        // Qt has support for SVG, but we want to use KSVG2
        if (formats.at(i).toLower().startsWith("svg"))
            continue;
#endif*/
        String mimeType = MIMETypeRegistry::getMIMETypeForExtension(formats.at(i).constData());
        if (!mimeType.isEmpty()) {
            supportedImageMIMETypes->insert(mimeType);
            supportedImageResourceMIMETypes->insert(mimeType);
        }
    }
/*#else
    // assume that all implementations at least support the following standard
    // image types:
    static const char* types[] = {
        "image/jpeg",
        "image/png",
        "image/gif",
        "image/bmp",
        "image/vnd.microsoft.icon",    // ico
        "image/x-icon",    // ico
        "image/x-xbitmap"  // xbm
    };
    for (size_t i = 0; i < sizeof(types) / sizeof(types[0]); ++i) {
        supportedImageMIMETypes->add(types[i]);
        supportedImageResourceMIMETypes->add(types[i]);
    }
#endif*/
}

static void initializeSupportedImageMIMETypesForEncoding()
{
    supportedImageMIMETypesForEncoding = new HashSet<String>;

/*#if PLATFORM(CG)
#if PLATFORM(MAC)
    RetainPtr<CFArrayRef> supportedTypes(AdoptCF, CGImageDestinationCopyTypeIdentifiers());
    CFIndex count = CFArrayGetCount(supportedTypes.get());
    for (CFIndex i = 0; i < count; i++) {
        RetainPtr<CFStringRef> supportedType(AdoptCF, reinterpret_cast<CFStringRef>(CFArrayGetValueAtIndex(supportedTypes.get(), i)));
        String mimeType = MIMETypeForImageSourceType(supportedType.get());
        if (!mimeType.isEmpty())
            supportedImageMIMETypesForEncoding->add(mimeType);
    }
#else
    // FIXME: Add Windows support for all the supported UTI's when a way to convert from MIMEType to UTI reliably is found.
    // For now, only support PNG, JPEG and GIF.  See <rdar://problem/6095286>.
    supportedImageMIMETypesForEncoding->add("image/png");
    supportedImageMIMETypesForEncoding->add("image/jpeg");
    supportedImageMIMETypesForEncoding->add("image/gif");
#endif
#elif PLATFORM(QT)*/
    QList<QByteArray> formats = QImageWriter::supportedImageFormats();
    for (int i = 0; i < formats.size(); ++i) {
        String mimeType = MIMETypeRegistry::getMIMETypeForExtension(formats.at(i).constData());
        if (!mimeType.isEmpty())
            supportedImageMIMETypesForEncoding->insert(mimeType);
    }
/*#elif PLATFORM(GTK)
    supportedImageMIMETypesForEncoding->add("image/png");
    supportedImageMIMETypesForEncoding->add("image/jpeg");
    supportedImageMIMETypesForEncoding->add("image/tiff");
    supportedImageMIMETypesForEncoding->add("image/bmp");
    supportedImageMIMETypesForEncoding->add("image/ico");
#elif PLATFORM(CAIRO)
    supportedImageMIMETypesForEncoding->add("image/png");
#endif*/
}

static void initializeSupportedJavaScriptMIMETypes()
{
    /*
        Mozilla 1.8 and WinIE 7 both accept text/javascript and text/ecmascript.
        Mozilla 1.8 accepts application/javascript, application/ecmascript, and application/x-javascript, but WinIE 7 doesn't.
        WinIE 7 accepts text/javascript1.1 - text/javascript1.3, text/jscript, and text/livescript, but Mozilla 1.8 doesn't.
        Mozilla 1.8 allows leading and trailing whitespace, but WinIE 7 doesn't.
        Mozilla 1.8 and WinIE 7 both accept the empty string, but neither accept a whitespace-only string.
        We want to accept all the values that either of these browsers accept, but not other values.
     */
    static const char* types[] = {
        "text/javascript",
        "text/ecmascript",
        "application/javascript",
        "application/ecmascript",
        "application/x-javascript",
        "text/javascript1.1",
        "text/javascript1.2",
        "text/javascript1.3",
        "text/jscript",
        "text/livescript",
    };
    for (size_t i = 0; i < sizeof(types) / sizeof(types[0]); ++i)
      supportedJavaScriptMIMETypes->insert(types[i]);
}

static void initializeSupportedNonImageMimeTypes()
{
    static const char* types[] = {
/*#if ENABLE(WML)
        "text/vnd.wap.wml",
        "application/vnd.wap.wmlc",
#endif*/
        "text/html",
        "text/xml",
        "text/xsl",
        "text/plain",
        "text/",
        "application/xml",
        "application/xhtml+xml",
        "application/vnd.wap.xhtml+xml",
        "application/rss+xml",
        "application/atom+xml",
        "application/json",
/*#if ENABLE(SVG)
        "image/svg+xml",
#endif
#if ENABLE(FTPDIR)
        "application/x-ftp-directory",
#endif*/
        "multipart/x-mixed-replace"
        // Note: ADDING a new type here will probably render it as HTML. This can
        // result in cross-site scripting.
    };
    /*COMPILE_ASSERT(sizeof(types) / sizeof(types[0]) <= 16,
                   nonimage_mime_types_must_be_less_than_or_equal_to_16);*/

    for (size_t i = 0; i < sizeof(types)/sizeof(types[0]); ++i)
        supportedNonImageMIMETypes->insert(types[i]);

    //ArchiveFactory::registerKnownArchiveMIMETypes();
}

static MediaMIMETypeMap& mediaMIMETypeMap()
{
    struct TypeExtensionPair {
        const char* type;
        const char* extension;
    };

    // A table of common media MIME types and file extenstions used when a platform's
    // specific MIME type lookup doesn't have a match for a media file extension.
    static const TypeExtensionPair pairs[] = {

        // Ogg
        { "application/ogg", "ogx" },
        { "audio/ogg", "ogg" },
        { "audio/ogg", "oga" },
        { "video/ogg", "ogv" },

        // Annodex
        { "application/annodex", "anx" },
        { "audio/annodex", "axa" },
        { "video/annodex", "axv" },
        { "audio/speex", "spx" },

        // WebM
        { "video/webm", "webm" },
        { "audio/webm", "webm" },

        // MPEG
        { "audio/mpeg", "m1a" },
        { "audio/mpeg", "m2a" },
        { "audio/mpeg", "m1s" },
        { "audio/mpeg", "mpa" },
        { "video/mpeg", "mpg" },
        { "video/mpeg", "m15" },
        { "video/mpeg", "m1s" },
        { "video/mpeg", "m1v" },
        { "video/mpeg", "m75" },
        { "video/mpeg", "mpa" },
        { "video/mpeg", "mpeg" },
        { "video/mpeg", "mpm" },
        { "video/mpeg", "mpv" },

        // MPEG playlist
        { "application/vnd.apple.mpegurl", "m3u8" },
        { "application/mpegurl", "m3u8" },
        { "application/x-mpegurl", "m3u8" },
        { "audio/mpegurl", "m3url" },
        { "audio/x-mpegurl", "m3url" },
        { "audio/mpegurl", "m3u" },
        { "audio/x-mpegurl", "m3u" },

        // MPEG-4
        { "video/x-m4v", "m4v" },
        { "audio/x-m4a", "m4a" },
        { "audio/x-m4b", "m4b" },
        { "audio/x-m4p", "m4p" },
        { "audio/mp4", "m4a" },

        // MP3
        { "audio/mp3", "mp3" },
        { "audio/x-mp3", "mp3" },
        { "audio/x-mpeg", "mp3" },

        // MPEG-2
        { "video/x-mpeg2", "mp2" },
        { "video/mpeg2", "vob" },
        { "video/mpeg2", "mod" },
        { "video/m2ts", "m2ts" },
        { "video/x-m2ts", "m2t" },
        { "video/x-m2ts", "ts" },

        // 3GP/3GP2
        { "audio/3gpp", "3gpp" },
        { "audio/3gpp2", "3g2" },
        { "application/x-mpeg", "amc" },

        // AAC
        { "audio/aac", "aac" },
        { "audio/aac", "adts" },
        { "audio/x-aac", "m4r" },

        // CoreAudio File
        { "audio/x-caf", "caf" },
        { "audio/x-gsm", "gsm" }
    };

    DEFINE_STATIC_LOCAL(MediaMIMETypeMap, mediaMIMETypeForExtensionMap, ());

    if (!mediaMIMETypeForExtensionMap.isEmpty())
        return mediaMIMETypeForExtensionMap;

    const unsigned numPairs = sizeof(pairs) / sizeof(pairs[0]);
    for (unsigned ndx = 0; ndx < numPairs; ++ndx) {

        if (mediaMIMETypeForExtensionMap.contains(pairs[ndx].extension))
            mediaMIMETypeForExtensionMap[(pairs[ndx].extension)]->append(pairs[ndx].type);
        else {
            QVector<String>* synonyms = new QVector<String>;

            // If there is a system specific type for this extension, add it as the first type so
            // getMediaMIMETypeForExtension will always return it.
            String systemType = MIMETypeRegistry::getMIMETypeForExtension(pairs[ndx].type);
            if (!systemType.isEmpty() && pairs[ndx].type != systemType)
                synonyms->append(systemType);
            synonyms->append(pairs[ndx].type);
            mediaMIMETypeForExtensionMap.insert(pairs[ndx].extension, synonyms);
        }
    }

    return mediaMIMETypeForExtensionMap;
}

String MIMETypeRegistry::getMediaMIMETypeForExtension(const String& ext)
{
    if (mediaMIMETypeMap().contains(ext))
        return (*mediaMIMETypeMap()[(ext)])[0];

    return String();
}

QVector<String> MIMETypeRegistry::getMediaMIMETypesForExtension(const String& ext)
{
    if (mediaMIMETypeMap().contains(ext))
        return *mediaMIMETypeMap()[(ext)];

    return QVector<String>();
}

static void initializeSupportedMediaMIMETypes()
{
    supportedMediaMIMETypes = new HashSet<String>;
/*#if ENABLE(VIDEO)
    MediaPlayer::getSupportedTypes(*supportedMediaMIMETypes);
#endif*/
}

static void initializeMIMETypeRegistry()
{
    supportedJavaScriptMIMETypes = new HashSet<String>;
    initializeSupportedJavaScriptMIMETypes();

    supportedNonImageMIMETypes = new HashSet<String>(*supportedJavaScriptMIMETypes);
    initializeSupportedNonImageMimeTypes();

    supportedImageResourceMIMETypes = new HashSet<String>;
    supportedImageMIMETypes = new HashSet<String>;
    initializeSupportedImageMIMETypes();
}

String MIMETypeRegistry::getMIMETypeForPath(const String& path)
{
    size_t pos = path.lastIndexOf('.');//path.reverseFind('.');
    if (pos != notFound) {
        // https://doc.qt.io/qt-5/qstring.html#mid
        String extension = path.mid(pos + 1); // path.subString(pos + 1);
        String result = getMIMETypeForExtension(extension);
        if (result.length())
            return result;
    }
    return "application/octet-stream";
}

bool MIMETypeRegistry::isSupportedImageMIMEType(const String& mimeType)
{
    if (mimeType.isEmpty())
        return false;
    if (!supportedImageMIMETypes)
        initializeMIMETypeRegistry();
    return supportedImageMIMETypes->contains(mimeType);
}

bool MIMETypeRegistry::isSupportedImageResourceMIMEType(const String& mimeType)
{
    if (mimeType.isEmpty())
        return false;
    if (!supportedImageResourceMIMETypes)
        initializeMIMETypeRegistry();
    return supportedImageResourceMIMETypes->contains(mimeType);
}

bool MIMETypeRegistry::isSupportedImageMIMETypeForEncoding(const String& mimeType)
{
    //ASSERT(isMainThread());

    if (mimeType.isEmpty())
        return false;
    if (!supportedImageMIMETypesForEncoding)
        initializeSupportedImageMIMETypesForEncoding();
    return supportedImageMIMETypesForEncoding->contains(mimeType);
}

bool MIMETypeRegistry::isSupportedJavaScriptMIMEType(const String& mimeType)
{
    if (mimeType.isEmpty())
        return false;
    if (!supportedJavaScriptMIMETypes)
        initializeMIMETypeRegistry();
    return supportedJavaScriptMIMETypes->contains(mimeType);
}

bool MIMETypeRegistry::isSupportedNonImageMIMEType(const String& mimeType)
{
    if (mimeType.isEmpty())
        return false;
    if (!supportedNonImageMIMETypes)
        initializeMIMETypeRegistry();
    return supportedNonImageMIMETypes->contains(mimeType);
}

bool MIMETypeRegistry::isSupportedMediaMIMEType(const String& mimeType)
{
    if (mimeType.isEmpty())
        return false;
    if (!supportedMediaMIMETypes)
        initializeSupportedMediaMIMETypes();
    return supportedMediaMIMETypes->contains(mimeType);
}

bool MIMETypeRegistry::isJavaAppletMIMEType(const String& mimeType)
{
    // Since this set is very limited and is likely to remain so we won't bother with the overhead
    // of using a hash set.
    // Any of the MIME types below may be followed by any number of specific versions of the JVM,
    // which is why we use startsWith()
    return mimeType.startsWith("application/x-java-applet")//, false)
        || mimeType.startsWith("application/x-java-bean")//, false)
        || mimeType.startsWith("application/x-java-vm");//, false);
}

HashSet<String>& MIMETypeRegistry::getSupportedImageMIMETypes()
{
    if (!supportedImageMIMETypes)
        initializeMIMETypeRegistry();
    return *supportedImageMIMETypes;
}

HashSet<String>& MIMETypeRegistry::getSupportedImageResourceMIMETypes()
{
    if (!supportedImageResourceMIMETypes)
        initializeMIMETypeRegistry();
    return *supportedImageResourceMIMETypes;
}

HashSet<String>& MIMETypeRegistry::getSupportedImageMIMETypesForEncoding()
{
    if (!supportedImageMIMETypesForEncoding)
        initializeSupportedImageMIMETypesForEncoding();
    return *supportedImageMIMETypesForEncoding;
}

HashSet<String>& MIMETypeRegistry::getSupportedNonImageMIMETypes()
{
    if (!supportedNonImageMIMETypes)
        initializeMIMETypeRegistry();
    return *supportedNonImageMIMETypes;
}

HashSet<String>& MIMETypeRegistry::getSupportedMediaMIMETypes()
{
    if (!supportedMediaMIMETypes)
        initializeSupportedMediaMIMETypes();
    return *supportedMediaMIMETypes;
}

const String& defaultMIMEType()
{
    DEFINE_STATIC_LOCAL(const String, defaultMIMEType, ("application/octet-stream"));
    return defaultMIMEType;
}
</file>

<file path="mimetyperegistryqt.cpp">
// this_file: qlith-pro/src/mimetyperegistryqt.cpp
#include "qlith/mimetyperegistryqt.h"
#include "qlith/mimetyperegistry.h"

#include "qlith/common.h"

struct ExtensionMap {
    const char* extension;
    const char* mimeType;
};

static const ExtensionMap extensionMap[] = {
    { "bmp", "image/bmp" },
    { "css", "text/css" },
    { "gif", "image/gif" },
    { "html", "text/html" },
    { "htm", "text/html" },
    { "ico", "image/x-icon" },
    { "jpeg", "image/jpeg" },
    { "jpg", "image/jpeg" },
    { "js", "application/x-javascript" },
    { "mng", "video/x-mng" },
    { "pbm", "image/x-portable-bitmap" },
    { "pgm", "image/x-portable-graymap" },
    { "pdf", "application/pdf" },
    { "png", "image/png" },
    { "ppm", "image/x-portable-pixmap" },
    { "rss", "application/rss+xml" },
    { "svg", "image/svg+xml" },
    { "text", "text/plain" },
    { "tif", "image/tiff" },
    { "tiff", "image/tiff" },
    { "txt", "text/plain" },
    { "xbm", "image/x-xbitmap" },
    { "xml", "text/xml" },
    { "xpm", "image/x-xpm" },
    { "xsl", "text/xsl" },
    { "xhtml", "application/xhtml+xml" },
    { "wml", "text/vnd.wap.wml" },
    { "wmlc", "application/vnd.wap.wmlc" },
    { 0, 0 }
};

String MIMETypeRegistry::getMIMETypeForExtension(const String &ext)
{
    String s = ext.toLower();//lower();

    const ExtensionMap *e = extensionMap;
    while (e->extension) {
        if (s == e->extension)
            return e->mimeType;
        ++e;
    }

    return String();
}

bool MIMETypeRegistry::isApplicationPluginMIMEType(const String& mimeType)
{
    /*return mimeType.startsWith("application/x-qt-plugin", false)
        || mimeType.startsWith("application/x-qt-styled-widget", false);*/
    return false; // TODO
}
</file>

<file path="pathqt.cpp">
// this_file: qlith-pro/src/pathqt.cpp
#include "qlith/pathqt.h"

/*#include "config.h"
#include "Path.h"

#include "AffineTransform.h"
#include "GraphicsContext.h"
#include "ImageBuffer.h"
#include "PlatformString.h"
#include "StrokeStyleApplier.h"*/
#include <QPainterPath>
#include <QTransform>
#include <QString>
#include "qlith/floatrect.h"
#include "qlith/graphicscontext.h"
//#include <wtf/OwnPtr.h>

#define _USE_MATH_DEFINES
#include <cmath>

#ifndef M_PI
#   define M_PI 3.14159265358979323846
#endif

Path::Path()
{
}

Path::~Path()
{
}

Path::Path(const Path& other)
    : m_path(other.m_path)
{
}

Path& Path::operator=(const Path& other)
{
    m_path = other.m_path;
    return *this;
}

static inline bool areCollinear(const QPointF& a, const QPointF& b, const QPointF& c)
{
    // Solved from comparing the slopes of a to b and b to c: (ay-by)/(ax-bx) == (cy-by)/(cx-bx)
    return qFuzzyCompare((c.y() - b.y()) * (a.x() - b.x()), (a.y() - b.y()) * (c.x() - b.x()));
}

static inline bool withinRange(qreal p, qreal a, qreal b)
{
    return (p >= a && p <= b) || (p >= b && p <= a);
}

// Check whether a point is on the border
static bool isPointOnPathBorder(const QPolygonF& border, const QPointF& p)
{
    // null border doesn't contain points
    if (border.isEmpty())
        return false;

    QPointF p1 = border.at(0);
    QPointF p2;

    for (int i = 1; i < border.size(); ++i) {
        p2 = border.at(i);
        if (areCollinear(p, p1, p2)
                // Once we know that the points are collinear we
                // only need to check one of the coordinates
                && (qAbs(p2.x() - p1.x()) > qAbs(p2.y() - p1.y()) ?
                        withinRange(p.x(), p1.x(), p2.x()) :
                        withinRange(p.y(), p1.y(), p2.y()))) {
            return true;
        }
        p1 = p2;
    }
    return false;
}

bool Path::contains(const FloatPoint& point, WindRule rule) const
{
    Qt::FillRule savedRule = m_path.fillRule();
    const_cast<QPainterPath*>(&m_path)->setFillRule(rule == RULE_EVENODD ? Qt::OddEvenFill : Qt::WindingFill);

    bool contains = m_path.contains(point);

    if (!contains) {
        // check whether the point is on the border
        contains = isPointOnPathBorder(m_path.toFillPolygon(), point);
    }

    const_cast<QPainterPath*>(&m_path)->setFillRule(savedRule);
    return contains;
}

static GraphicsContext* scratchContext()
{
    static QImage image(1, 1, QImage::Format_ARGB32_Premultiplied);
    static QPainter painter(&image);
    static GraphicsContext* context = new GraphicsContext(&painter);
    return context;
}

/*bool Path::strokeContains(StrokeStyleApplier* applier, const FloatPoint& point) const
{
    ASSERT(applier);

    QPainterPathStroker stroke;
    GraphicsContext* gc = scratchContext();
    applier->strokeStyle(gc);

    QPen pen = gc->pen();
    stroke.setWidth(pen.widthF());
    stroke.setCapStyle(pen.capStyle());
    stroke.setJoinStyle(pen.joinStyle());
    stroke.setMiterLimit(pen.miterLimit());
    stroke.setDashPattern(pen.dashPattern());
    stroke.setDashOffset(pen.dashOffset());

    return stroke.createStroke(m_path).contains(point);
}*/

void Path::translate(const FloatSize& size)
{
    QTransform matrix;
    matrix.translate(size.width(), size.height());
    m_path = m_path * matrix;
}

FloatRect Path::boundingRect() const
{
    return m_path.boundingRect();
}

/*FloatRect Path::strokeBoundingRect(StrokeStyleApplier* applier)
{
    GraphicsContext* gc = scratchContext();
    QPainterPathStroker stroke;
    if (applier) {
        applier->strokeStyle(gc);

        QPen pen = gc->pen();
        stroke.setWidth(pen.widthF());
        stroke.setCapStyle(pen.capStyle());
        stroke.setJoinStyle(pen.joinStyle());
        stroke.setMiterLimit(pen.miterLimit());
        stroke.setDashPattern(pen.dashPattern());
        stroke.setDashOffset(pen.dashOffset());
    }
    return stroke.createStroke(m_path).boundingRect();
}*/

void Path::moveTo(const FloatPoint& point)
{
    m_path.moveTo(point);
}

void Path::addLineTo(const FloatPoint& p)
{
    m_path.lineTo(p);
}

void Path::addQuadCurveTo(const FloatPoint& cp, const FloatPoint& p)
{
    m_path.quadTo(cp, p);
}

void Path::addBezierCurveTo(const FloatPoint& cp1, const FloatPoint& cp2, const FloatPoint& p)
{
    m_path.cubicTo(cp1, cp2, p);
}

void Path::addArcTo(const FloatPoint& p1, const FloatPoint& p2, float radius)
{
    FloatPoint p0(m_path.currentPosition());

    FloatPoint p1p0((p0.x() - p1.x()), (p0.y() - p1.y()));
    FloatPoint p1p2((p2.x() - p1.x()), (p2.y() - p1.y()));
    float p1p0_length = sqrtf(p1p0.x() * p1p0.x() + p1p0.y() * p1p0.y());
    float p1p2_length = sqrtf(p1p2.x() * p1p2.x() + p1p2.y() * p1p2.y());

    double cos_phi = (p1p0.x() * p1p2.x() + p1p0.y() * p1p2.y()) / (p1p0_length * p1p2_length);

    // The points p0, p1, and p2 are on the same straight line (HTML5, 4.8.11.1.8)
    // We could have used areCollinear() here, but since we're reusing
    // the variables computed above later on we keep this logic.
    if (qFuzzyCompare(qAbs(cos_phi), 1.0)) {
        m_path.lineTo(p1);
        return;
    }

    float tangent = radius / tan(acos(cos_phi) / 2);
    float factor_p1p0 = tangent / p1p0_length;
    FloatPoint t_p1p0((p1.x() + factor_p1p0 * p1p0.x()), (p1.y() + factor_p1p0 * p1p0.y()));

    FloatPoint orth_p1p0(p1p0.y(), -p1p0.x());
    float orth_p1p0_length = sqrt(orth_p1p0.x() * orth_p1p0.x() + orth_p1p0.y() * orth_p1p0.y());
    float factor_ra = radius / orth_p1p0_length;

    // angle between orth_p1p0 and p1p2 to get the right vector orthographic to p1p0
    double cos_alpha = (orth_p1p0.x() * p1p2.x() + orth_p1p0.y() * p1p2.y()) / (orth_p1p0_length * p1p2_length);
    if (cos_alpha < 0.f)
        orth_p1p0 = FloatPoint(-orth_p1p0.x(), -orth_p1p0.y());

    FloatPoint p((t_p1p0.x() + factor_ra * orth_p1p0.x()), (t_p1p0.y() + factor_ra * orth_p1p0.y()));

    // calculate angles for addArc
    orth_p1p0 = FloatPoint(-orth_p1p0.x(), -orth_p1p0.y());
    float sa = acos(orth_p1p0.x() / orth_p1p0_length);
    if (orth_p1p0.y() < 0.f)
        sa = 2 * piDouble - sa;

    // anticlockwise logic
    bool anticlockwise = false;

    float factor_p1p2 = tangent / p1p2_length;
    FloatPoint t_p1p2((p1.x() + factor_p1p2 * p1p2.x()), (p1.y() + factor_p1p2 * p1p2.y()));
    FloatPoint orth_p1p2((t_p1p2.x() - p.x()), (t_p1p2.y() - p.y()));
    float orth_p1p2_length = sqrtf(orth_p1p2.x() * orth_p1p2.x() + orth_p1p2.y() * orth_p1p2.y());
    float ea = acos(orth_p1p2.x() / orth_p1p2_length);
    if (orth_p1p2.y() < 0)
        ea = 2 * piDouble - ea;
    if ((sa > ea) && ((sa - ea) < piDouble))
        anticlockwise = true;
    if ((sa < ea) && ((ea - sa) > piDouble))
        anticlockwise = true;

    m_path.lineTo(t_p1p0);

    addArc(p, radius, sa, ea, anticlockwise);
}

void Path::closeSubpath()
{
    m_path.closeSubpath();
}

#define DEGREES(t) ((t) * 180.0 / M_PI)
void Path::addArc(const FloatPoint& p, float r, float sar, float ear, bool anticlockwise)
{
    qreal xc = p.x();
    qreal yc = p.y();
    qreal radius = r;


    //### HACK
    // In Qt we don't switch the coordinate system for degrees
    // and still use the 0,0 as bottom left for degrees so we need
    // to switch
    sar = -sar;
    ear = -ear;
    anticlockwise = !anticlockwise;
    //end hack

    float sa = DEGREES(sar);
    float ea = DEGREES(ear);

    double span = 0;

    double xs = xc - radius;
    double ys = yc - radius;
    double width  = radius*2;
    double height = radius*2;

    if ((!anticlockwise && (ea - sa >= 360)) || (anticlockwise && (sa - ea >= 360)))
        // If the anticlockwise argument is false and endAngle-startAngle is equal to or greater than 2*PI, or, if the
        // anticlockwise argument is true and startAngle-endAngle is equal to or greater than 2*PI, then the arc is the whole
        // circumference of this circle.
        span = 360;
    else {
        if (!anticlockwise && (ea < sa))
            span += 360;
        else if (anticlockwise && (sa < ea))
            span -= 360;

        // this is also due to switched coordinate system
        // we would end up with a 0 span instead of 360
        if (!(qFuzzyCompare(span + (ea - sa) + 1, 1.0)
            && qFuzzyCompare(qAbs(span), 360.0))) {
            // mod 360
            span += (ea - sa) - (static_cast<int>((ea - sa) / 360)) * 360;
        }
    }

    // If the path is empty, move to where the arc will start to avoid painting a line from (0,0)
    // NOTE: QPainterPath::isEmpty() won't work here since it ignores a lone MoveToElement
    if (!m_path.elementCount())
        m_path.arcMoveTo(xs, ys, width, height, sa);
    else if (!radius) {
        m_path.lineTo(xc, yc);
        return;
    }

    m_path.arcTo(xs, ys, width, height, sa, span);

}

void Path::addRect(const FloatRect& r)
{
    m_path.addRect(r.x(), r.y(), r.width(), r.height());
}

void Path::addEllipse(const FloatRect& r)
{
    m_path.addEllipse(r.x(), r.y(), r.width(), r.height());
}

void Path::clear()
{
    if (!m_path.elementCount())
        return;
    m_path = QPainterPath();
}

bool Path::isEmpty() const
{
    // Don't use QPainterPath::isEmpty(), as that also returns true if there's only
    // one initial MoveTo element in the path.
    return !m_path.elementCount();
}

bool Path::hasCurrentPoint() const
{
    return !isEmpty();
}

FloatPoint Path::currentPoint() const
{
    return m_path.currentPosition();
}

void Path::apply(void* info, PathApplierFunction function) const
{
    PathElement pelement;
    FloatPoint points[3];
    pelement.points = points;
    for (int i = 0; i < m_path.elementCount(); ++i) {
        const QPainterPath::Element& cur = m_path.elementAt(i);

        switch (cur.type) {
            case QPainterPath::MoveToElement:
                pelement.type = PathElementMoveToPoint;
                pelement.points[0] = QPointF(cur);
                function(info, &pelement);
                break;
            case QPainterPath::LineToElement:
                pelement.type = PathElementAddLineToPoint;
                pelement.points[0] = QPointF(cur);
                function(info, &pelement);
                break;
            case QPainterPath::CurveToElement:
            {
                const QPainterPath::Element& c1 = m_path.elementAt(i + 1);
                const QPainterPath::Element& c2 = m_path.elementAt(i + 2);

                Q_ASSERT(c1.type == QPainterPath::CurveToDataElement);
                Q_ASSERT(c2.type == QPainterPath::CurveToDataElement);

                pelement.type = PathElementAddCurveToPoint;
                pelement.points[0] = QPointF(cur);
                pelement.points[1] = QPointF(c1);
                pelement.points[2] = QPointF(c2);
                function(info, &pelement);

                i += 2;
                break;
            }
            case QPainterPath::CurveToDataElement:
                Q_ASSERT(false);
        }
    }
}

void Path::transform(const AffineTransform& transform)
{
    QTransform qTransform(transform);
#if QT_VERSION < QT_VERSION_CHECK(4, 7, 0)
    // Workaround for http://bugreports.qt.nokia.com/browse/QTBUG-11264
    // QTransform.map doesn't handle the MoveTo element because of the isEmpty issue
    if (m_path.isEmpty() && m_path.elementCount()) {
        QPointF point = qTransform.map(m_path.currentPosition());
        moveTo(point);
    } else
#endif
        m_path = qTransform.map(m_path);
}

float Path::length()
{
    return m_path.length();
}

FloatPoint Path::pointAtLength(float length, bool& ok)
{
    ok = (length >= 0 && length <= m_path.length());

    qreal percent = m_path.percentAtLength(length);
    QPointF point = m_path.pointAtPercent(percent);

    return point;
}

float Path::normalAngleAtLength(float length, bool& ok)
{
    ok = (length >= 0 && length <= m_path.length());

    qreal percent = m_path.percentAtLength(length);
    qreal angle = m_path.angleAtPercent(percent);

    return angle;
}

/////////////////
// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/Path.cpp

// Approximation of control point positions on a bezier to simulate a quarter of a circle.
static const float gCircleControlPoint = 0.448f;

void Path::addRoundedRect(const FloatRect& rect, const FloatSize& roundingRadii)
{
    if (rect.isEmpty())
        return;

    FloatSize radius(roundingRadii);
    FloatSize halfSize(rect.width() / 2, rect.height() / 2);

    // If rx is greater than half of the width of the rectangle
    // then set rx to half of the width (required in SVG spec)
    if (radius.width() > halfSize.width())
        radius.setWidth(halfSize.width());

    // If ry is greater than half of the height of the rectangle
    // then set ry to half of the height (required in SVG spec)
    if (radius.height() > halfSize.height())
        radius.setHeight(halfSize.height());

    moveTo(FloatPoint(rect.x() + radius.width(), rect.y()));

    if (radius.width() < halfSize.width())
        addLineTo(FloatPoint(rect.x() + rect.width() - roundingRadii.width(), rect.y()));

    addBezierCurveTo(FloatPoint(rect.x() + rect.width() - radius.width() * gCircleControlPoint, rect.y()), FloatPoint(rect.x() + rect.width(), rect.y() + radius.height() * gCircleControlPoint), FloatPoint(rect.x() + rect.width(), rect.y() + radius.height()));

    if (radius.height() < halfSize.height())
        addLineTo(FloatPoint(rect.x() + rect.width(), rect.y() + rect.height() - radius.height()));

    addBezierCurveTo(FloatPoint(rect.x() + rect.width(), rect.y() + rect.height() - radius.height() * gCircleControlPoint), FloatPoint(rect.x() + rect.width() - radius.width() * gCircleControlPoint, rect.y() + rect.height()), FloatPoint(rect.x() + rect.width() - radius.width(), rect.y() + rect.height()));

    if (radius.width() < halfSize.width())
        addLineTo(FloatPoint(rect.x() + radius.width(), rect.y() + rect.height()));

    addBezierCurveTo(FloatPoint(rect.x() + radius.width() * gCircleControlPoint, rect.y() + rect.height()), FloatPoint(rect.x(), rect.y() + rect.height() - radius.height() * gCircleControlPoint), FloatPoint(rect.x(), rect.y() + rect.height() - radius.height()));

    if (radius.height() < halfSize.height())
        addLineTo(FloatPoint(rect.x(), rect.y() + radius.height()));

    addBezierCurveTo(FloatPoint(rect.x(), rect.y() + radius.height() * gCircleControlPoint), FloatPoint(rect.x() + radius.width() * gCircleControlPoint, rect.y()), FloatPoint(rect.x() + radius.width(), rect.y()));

    closeSubpath();
}

void Path::addRoundedRect(const FloatRect& rect, const FloatSize& topLeftRadius, const FloatSize& topRightRadius, const FloatSize& bottomLeftRadius, const FloatSize& bottomRightRadius)
{
    if (rect.isEmpty())
        return;

    if (rect.width() < topLeftRadius.width() + topRightRadius.width()
            || rect.width() < bottomLeftRadius.width() + bottomRightRadius.width()
            || rect.height() < topLeftRadius.height() + bottomLeftRadius.height()
            || rect.height() < topRightRadius.height() + bottomRightRadius.height()) {
        // If all the radii cannot be accommodated, return a rect.
        addRect(rect);
        return;
    }

    moveTo(FloatPoint(rect.x() + topLeftRadius.width(), rect.y()));

    addLineTo(FloatPoint(rect.x() + rect.width() - topRightRadius.width(), rect.y()));
    addBezierCurveTo(FloatPoint(rect.x() + rect.width() - topRightRadius.width() * gCircleControlPoint, rect.y()),
                     FloatPoint(rect.x() + rect.width(), rect.y() + topRightRadius.height() * gCircleControlPoint),
                     FloatPoint(rect.x() + rect.width(), rect.y() + topRightRadius.height()));
    addLineTo(FloatPoint(rect.x() + rect.width(), rect.y() + rect.height() - bottomRightRadius.height()));
    addBezierCurveTo(FloatPoint(rect.x() + rect.width(), rect.y() + rect.height() - bottomRightRadius.height() * gCircleControlPoint),
                     FloatPoint(rect.x() + rect.width() - bottomRightRadius.width() * gCircleControlPoint, rect.y() + rect.height()),
                     FloatPoint(rect.x() + rect.width() - bottomRightRadius.width(), rect.y() + rect.height()));
    addLineTo(FloatPoint(rect.x() + bottomLeftRadius.width(), rect.y() + rect.height()));
    addBezierCurveTo(FloatPoint(rect.x() + bottomLeftRadius.width() * gCircleControlPoint, rect.y() + rect.height()),
                     FloatPoint(rect.x(), rect.y() + rect.height() - bottomLeftRadius.height() * gCircleControlPoint),
                     FloatPoint(rect.x(), rect.y() + rect.height() - bottomLeftRadius.height()));
    addLineTo(FloatPoint(rect.x(), rect.y() + topLeftRadius.height()));
    addBezierCurveTo(FloatPoint(rect.x(), rect.y() + topLeftRadius.height() * gCircleControlPoint),
                     FloatPoint(rect.x() + topLeftRadius.width() * gCircleControlPoint, rect.y()),
                     FloatPoint(rect.x() + topLeftRadius.width(), rect.y()));

    closeSubpath();
}

// vim: ts=4 sw=4 et
</file>

<file path="pngimagedecoder.cpp">
// this_file: qlith-pro/src/pngimagedecoder.cpp
#include "qlith/pngimagedecoder.h"

#include "qlith/common.h"
#include <png.h>

#if defined(PNG_LIBPNG_VER_MAJOR) && defined(PNG_LIBPNG_VER_MINOR) && (PNG_LIBPNG_VER_MAJOR > 1 || (PNG_LIBPNG_VER_MAJOR == 1 && PNG_LIBPNG_VER_MINOR >= 4))
#define JMPBUF(png_ptr) png_jmpbuf(png_ptr)
#else
#define JMPBUF(png_ptr) png_ptr->jmpbuf
#endif

// Gamma constants.
const double cMaxGamma = 21474.83;
const double cDefaultGamma = 2.2;
const double cInverseGamma = 0.45455;

// Protect against large PNGs. See Mozilla's bug #251381 for more info.
const unsigned long cMaxPNGSize = 1000000UL;

// Called if the decoding of the image fails.
static void PNGAPI decodingFailed(png_structp png, png_const_charp)
{
    longjmp(JMPBUF(png), 1);
}

// Callbacks given to the read struct.  The first is for warnings (we want to
// treat a particular warning as an error, which is why we have to register this
// callback).
static void PNGAPI decodingWarning(png_structp png, png_const_charp warningMsg)
{
    // Mozilla did this, so we will too.
    // Convert a tRNS warning to be an error (see
    // http://bugzilla.mozilla.org/show_bug.cgi?id=251381 )
    if (!strncmp(warningMsg, "Missing PLTE before tRNS", 24))
        png_error(png, warningMsg);
}

// Called when we have obtained the header information (including the size).
static void PNGAPI headerAvailable(png_structp png, png_infop)
{
    static_cast<PNGImageDecoder*>(png_get_progressive_ptr(png))->headerAvailable();
}

// Called when a row is ready.
static void PNGAPI rowAvailable(png_structp png, png_bytep rowBuffer, png_uint_32 rowIndex, int interlacePass)
{
    static_cast<PNGImageDecoder*>(png_get_progressive_ptr(png))->rowAvailable(rowBuffer, rowIndex, interlacePass);
}

// Called when we have completely finished decoding the image.
static void PNGAPI pngComplete(png_structp png, png_infop)
{
    static_cast<PNGImageDecoder*>(png_get_progressive_ptr(png))->pngComplete();
}

class PNGImageReader
{
public:
    PNGImageReader(PNGImageDecoder* decoder)
        : m_readOffset(0)
        , m_decodingSizeOnly(false)
        , m_interlaceBuffer(0)
        , m_hasAlpha(false)
        , m_currentBufferSize(0)
    {
        m_png = png_create_read_struct(PNG_LIBPNG_VER_STRING, 0, decodingFailed, decodingWarning);
        m_info = png_create_info_struct(m_png);
        png_set_progressive_read_fn(m_png, decoder, headerAvailable, rowAvailable, pngComplete);
    }

    ~PNGImageReader()
    {
        close();
    }

    void close()
    {
        if (m_png && m_info)
            // This will zero the pointers.
            png_destroy_read_struct(&m_png, &m_info, 0);
        delete[] m_interlaceBuffer;
        m_interlaceBuffer = 0;
        m_readOffset = 0;
    }

    unsigned currentBufferSize() const { return m_currentBufferSize; }

    bool decode(const SharedBuffer& data, bool sizeOnly)
    {
        m_decodingSizeOnly = sizeOnly;
        PNGImageDecoder* decoder = static_cast<PNGImageDecoder*>(png_get_progressive_ptr(m_png));

        // We need to do the setjmp here. Otherwise bad things will happen.
        if (setjmp(JMPBUF(m_png)))
            return decoder->setFailed();

        const char* segment;
        while (unsigned segmentLength = data.getSomeData(segment, m_readOffset)) {
            m_readOffset += segmentLength;
            m_currentBufferSize = m_readOffset;
            png_process_data(m_png, m_info, reinterpret_cast<png_bytep>(const_cast<char*>(segment)), segmentLength);
            // We explicitly specify the superclass isSizeAvailable() because we
            // merely want to check if we've managed to set the size, not
            // (recursively) trigger additional decoding if we haven't.
            if (sizeOnly ? decoder->ImageDecoder::isSizeAvailable() : decoder->isComplete())
                return true;
        }
        return false;
    }

    bool decodingSizeOnly() const { return m_decodingSizeOnly; }
    png_structp pngPtr() const { return m_png; }
    png_infop infoPtr() const { return m_info; }
    png_bytep interlaceBuffer() const { return m_interlaceBuffer; }
    bool hasAlpha() const { return m_hasAlpha; }

    void setReadOffset(unsigned offset) { m_readOffset = offset; }
    void setHasAlpha(bool b) { m_hasAlpha = b; }

    void createInterlaceBuffer(int size) { m_interlaceBuffer = new png_byte[size]; }

private:
    unsigned m_readOffset;
    bool m_decodingSizeOnly;
    png_structp m_png;
    png_infop m_info;
    png_bytep m_interlaceBuffer;
    bool m_hasAlpha;
    unsigned m_currentBufferSize;
};

PNGImageDecoder::PNGImageDecoder(bool premultiplyAlpha)
    : ImageDecoder(premultiplyAlpha)
    , m_doNothingOnFailure(false)
{
}

PNGImageDecoder::~PNGImageDecoder()
{
}

bool PNGImageDecoder::isSizeAvailable()
{
    if (!ImageDecoder::isSizeAvailable())
         decode(true);

    return ImageDecoder::isSizeAvailable();
}

bool PNGImageDecoder::setSize(unsigned width, unsigned height)
{
    if (!ImageDecoder::setSize(width, height))
        return false;

    prepareScaleDataIfNecessary();
    return true;
}

RGBA32Buffer* PNGImageDecoder::frameBufferAtIndex(size_t index)
{
    if (index)
        return 0;

    if (m_frameBufferCache.isEmpty()) {
        m_frameBufferCache.resize(1);
        m_frameBufferCache[0].setPremultiplyAlpha(m_premultiplyAlpha);
    }

    RGBA32Buffer& frame = m_frameBufferCache[0];
    if (frame.status() != RGBA32Buffer::FrameComplete)
        decode(false);
    return &frame;
}

bool PNGImageDecoder::setFailed()
{
    if (m_doNothingOnFailure)
        return false;
    m_reader.clear();
    return ImageDecoder::setFailed();
}

void PNGImageDecoder::headerAvailable()
{
    png_structp png = m_reader->pngPtr();
    png_infop info = m_reader->infoPtr();
    png_uint_32 width = png->width;
    png_uint_32 height = png->height;

    // Protect against large images.
    if (png->width > cMaxPNGSize || png->height > cMaxPNGSize) {
        longjmp(JMPBUF(png), 1);
        return;
    }

    // We can fill in the size now that the header is available.  Avoid memory
    // corruption issues by neutering setFailed() during this call; if we don't
    // do this, failures will cause |m_reader| to be deleted, and our jmpbuf
    // will cease to exist.  Note that we'll still properly set the failure flag
    // in this case as soon as we longjmp().
    m_doNothingOnFailure = true;
    bool result = setSize(width, height);
    m_doNothingOnFailure = false;
    if (!result) {
        longjmp(JMPBUF(png), 1);
        return;
    }

    int bitDepth, colorType, interlaceType, compressionType, filterType, channels;
    png_get_IHDR(png, info, &width, &height, &bitDepth, &colorType, &interlaceType, &compressionType, &filterType);

    // The options we set here match what Mozilla does.

    // Expand to ensure we use 24-bit for RGB and 32-bit for RGBA.
    if (colorType == PNG_COLOR_TYPE_PALETTE || (colorType == PNG_COLOR_TYPE_GRAY && bitDepth < 8))
        png_set_expand(png);

    png_bytep trns = 0;
    int trnsCount = 0;
    if (png_get_valid(png, info, PNG_INFO_tRNS)) {
        png_get_tRNS(png, info, &trns, &trnsCount, 0);
        png_set_expand(png);
    }

    if (bitDepth == 16)
        png_set_strip_16(png);

    if (colorType == PNG_COLOR_TYPE_GRAY || colorType == PNG_COLOR_TYPE_GRAY_ALPHA)
        png_set_gray_to_rgb(png);

    // Deal with gamma and keep it under our control.
    double gamma;
    if (png_get_gAMA(png, info, &gamma)) {
        if ((gamma <= 0.0) || (gamma > cMaxGamma)) {
            gamma = cInverseGamma;
            png_set_gAMA(png, info, gamma);
        }
        png_set_gamma(png, cDefaultGamma, gamma);
    } else
        png_set_gamma(png, cDefaultGamma, cInverseGamma);

    // Tell libpng to send us rows for interlaced pngs.
    if (interlaceType == PNG_INTERLACE_ADAM7)
        png_set_interlace_handling(png);

    // Update our info now.
    png_read_update_info(png, info);
    channels = png_get_channels(png, info);
    ASSERT(channels == 3 || channels == 4);

    m_reader->setHasAlpha(channels == 4);

    if (m_reader->decodingSizeOnly()) {
        // If we only needed the size, halt the reader.
        m_reader->setReadOffset(m_reader->currentBufferSize() - png->buffer_size);
        png->buffer_size = 0;
    }
}

void PNGImageDecoder::rowAvailable(unsigned char* rowBuffer, unsigned rowIndex, int interlacePass)
{
    if (m_frameBufferCache.isEmpty())
        return;

    // Initialize the framebuffer if needed.
    RGBA32Buffer& buffer = m_frameBufferCache[0];
    if (buffer.status() == RGBA32Buffer::FrameEmpty) {
        if (!buffer.setSize(scaledSize().width(), scaledSize().height())) {
            longjmp(JMPBUF(m_reader->pngPtr()), 1);
            return;
        }
        buffer.setStatus(RGBA32Buffer::FramePartial);
        buffer.setHasAlpha(false);

        // For PNGs, the frame always fills the entire image.
        buffer.setRect(IntRect(IntPoint(), size()));

        if (m_reader->pngPtr()->interlaced)
            m_reader->createInterlaceBuffer((m_reader->hasAlpha() ? 4 : 3) * size().width() * size().height());
    }

    if (!rowBuffer)
        return;

    // libpng comments (pasted in here to explain what follows)
    /*
     * this function is called for every row in the image.  If the
     * image is interlacing, and you turned on the interlace handler,
     * this function will be called for every row in every pass.
     * Some of these rows will not be changed from the previous pass.
     * When the row is not changed, the new_row variable will be NULL.
     * The rows and passes are called in order, so you don't really
     * need the row_num and pass, but I'm supplying them because it
     * may make your life easier.
     *
     * For the non-NULL rows of interlaced images, you must call
     * png_progressive_combine_row() passing in the row and the
     * old row.  You can call this function for NULL rows (it will
     * just return) and for non-interlaced images (it just does the
     * memcpy for you) if it will make the code easier.  Thus, you
     * can just do this for all cases:
     *
     *    png_progressive_combine_row(png_ptr, old_row, new_row);
     *
     * where old_row is what was displayed for previous rows.  Note
     * that the first pass (pass == 0 really) will completely cover
     * the old row, so the rows do not have to be initialized.  After
     * the first pass (and only for interlaced images), you will have
     * to pass the current row, and the function will combine the
     * old row and the new row.
     */

    png_structp png = m_reader->pngPtr();
    bool hasAlpha = m_reader->hasAlpha();
    unsigned colorChannels = hasAlpha ? 4 : 3;
    png_bytep row;
    png_bytep interlaceBuffer = m_reader->interlaceBuffer();
    if (interlaceBuffer) {
        row = interlaceBuffer + (rowIndex * colorChannels * size().width());
        png_progressive_combine_row(png, row, rowBuffer);
    } else
        row = rowBuffer;

    // Copy the data into our buffer.
    int width = scaledSize().width();
    int destY = scaledY(rowIndex);

    // Check that the row is within the image bounds. LibPNG may supply an extra row.
    if (destY < 0 || destY >= scaledSize().height())
        return;
    bool sawAlpha = buffer.hasAlpha();
    for (int x = 0; x < width; ++x) {
        png_bytep pixel = row + (m_scaled ? m_scaledColumns[x] : x) * colorChannels;
        unsigned alpha = hasAlpha ? pixel[3] : 255;
        buffer.setRGBA(x, destY, pixel[0], pixel[1], pixel[2], alpha);
        if (!sawAlpha && alpha < 255) {
            sawAlpha = true;
            buffer.setHasAlpha(true);
        }
    }
}

void PNGImageDecoder::pngComplete()
{
    if (!m_frameBufferCache.isEmpty())
        m_frameBufferCache.first().setStatus(RGBA32Buffer::FrameComplete);
}

void PNGImageDecoder::decode(bool onlySize)
{
    if (failed())
        return;

    if (!m_reader)
        m_reader.set(new PNGImageReader(this));

    // If we couldn't decode the image but we've received all the data, decoding
    // has failed.
    if (!m_reader->decode(*m_data, onlySize) && isAllDataReceived())
        setFailed();
    // If we're done decoding the image, we don't need the PNGImageReader
    // anymore.  (If we failed, |m_reader| has already been cleared.)
    else if (isComplete())
        m_reader.clear();
}
</file>

<file path="purgeablebuffer.cpp">
// this_file: qlith-pro/src/purgeablebuffer.cpp
#include "qlith/purgeablebuffer.h"

/*PurgeableBuffer::PurgeableBuffer()
{

}
*/
</file>

<file path="rgba32bufferqt.cpp">
// this_file: qlith-pro/src/rgba32bufferqt.cpp
#include "qlith/rgba32bufferqt.h"

#include "qlith/common.h"
#include "qlith/imagedecoder.h"

#include <QPixmap>
#include <cstdio>


RGBA32Buffer::RGBA32Buffer()
    : m_hasAlpha(false)
    , m_size()
    , m_status(FrameEmpty)
    , m_duration(0)
    , m_disposalMethod(DisposeNotSpecified)
{
}

RGBA32Buffer& RGBA32Buffer::operator=(const RGBA32Buffer& other)
{
    if (this == &other)
        return *this;

    copyBitmapData(other);
    setRect(other.rect());
    setStatus(other.status());
    setDuration(other.duration());
    setDisposalMethod(other.disposalMethod());
    return *this;
}

void RGBA32Buffer::clear()
{
    m_pixmap = QPixmap();
    m_image = QImage();
    m_status = FrameEmpty;
    // NOTE: Do not reset other members here; clearFrameBufferCache()
    // calls this to free the bitmap data, but other functions like
    // initFrameBuffer() and frameComplete() may still need to read
    // other metadata out of this frame later.
}

void RGBA32Buffer::zeroFill()
{
    if (m_pixmap.isNull() && !m_image.isNull()) {
        m_pixmap = QPixmap(m_image.width(), m_image.height());
        m_image = QImage();
    }
    m_pixmap.fill(QColor(0, 0, 0, 0));
}

bool RGBA32Buffer::copyBitmapData(const RGBA32Buffer& other)
{
    if (this == &other)
        return true;

    m_image = other.m_image;
    m_pixmap = other.m_pixmap;
    m_size = other.m_size;
    m_hasAlpha = other.m_hasAlpha;
    return true;
}

bool RGBA32Buffer::setSize(int newWidth, int newHeight)
{
    // This function should only be called once, it will leak memory
    // otherwise.
    ASSERT(width() == 0 && height() == 0);

    m_size = IntSize(newWidth, newHeight);
    m_image = QImage();
    m_pixmap = QPixmap(newWidth, newHeight);
    if (m_pixmap.isNull())
        return false;

    // Zero the image.
    zeroFill();

    return true;
}

QPixmap* RGBA32Buffer::asNewNativeImage() const
{
    if (m_pixmap.isNull() && !m_image.isNull()) {
        m_pixmap = QPixmap::fromImage(m_image);
        m_image = QImage();
    }
    return new QPixmap(m_pixmap);
}

bool RGBA32Buffer::hasAlpha() const
{
    return m_hasAlpha;
}

void RGBA32Buffer::setHasAlpha(bool alpha)
{
    m_hasAlpha = alpha;
}

void RGBA32Buffer::setStatus(FrameStatus status)
{
    m_status = status;
}

// The image must not have format 8888 pre multiplied...
void RGBA32Buffer::setPixmap(const QPixmap& pixmap)
{
    m_pixmap = pixmap;
    m_image = QImage();
    m_size = pixmap.size();
    m_hasAlpha = pixmap.hasAlphaChannel();
}

int RGBA32Buffer::width() const
{
    return m_size.width();
}

int RGBA32Buffer::height() const
{
    return m_size.height();
}
</file>

<file path="shadowdata.cpp">
// this_file: qlith-pro/src/shadowdata.cpp
#include "qlith/shadowdata.h"

#include "qlith/common.h"

//#include "config.h"
#include "shadowdata.h"

#include "floatrect.h"
#include "intrect.h"

using namespace std;

ShadowData::ShadowData(const ShadowData& o)
    : m_x(o.m_x)
    , m_y(o.m_y)
    , m_blur(o.m_blur)
    , m_spread(o.m_spread)
    , m_style(o.m_style)
    , m_color(o.m_color)
{
    m_next = o.m_next ? new ShadowData(*o.m_next) : 0;
}

bool ShadowData::operator==(const ShadowData& o) const
{
    if ((m_next && !o.m_next) || (!m_next && o.m_next) ||
        (m_next && o.m_next && *m_next != *o.m_next))
        return false;

    return m_x == o.m_x && m_y == o.m_y && m_blur == o.m_blur && m_spread == o.m_spread && m_style == o.m_style && m_color == o.m_color;
}

static inline void calculateShadowExtent(const ShadowData* shadow, int additionalOutlineSize, int& shadowLeft, int& shadowRight, int& shadowTop, int& shadowBottom)
{
    do {
        int blurAndSpread = shadow->blur() + shadow->spread() + additionalOutlineSize;
        if (shadow->style() == Normal) {
            shadowLeft = min(shadow->x() - blurAndSpread, shadowLeft);
            shadowRight = max(shadow->x() + blurAndSpread, shadowRight);
            shadowTop = min(shadow->y() - blurAndSpread, shadowTop);
            shadowBottom = max(shadow->y() + blurAndSpread, shadowBottom);
        }

        shadow = shadow->next();
    } while (shadow);
}

void ShadowData::adjustRectForShadow(IntRect& rect, int additionalOutlineSize) const
{
    int shadowLeft = 0;
    int shadowRight = 0;
    int shadowTop = 0;
    int shadowBottom = 0;
    calculateShadowExtent(this, additionalOutlineSize, shadowLeft, shadowRight, shadowTop, shadowBottom);

    rect.move(shadowLeft, shadowTop);
    rect.setWidth(rect.width() - shadowLeft + shadowRight);
    rect.setHeight(rect.height() - shadowTop + shadowBottom);
}

void ShadowData::adjustRectForShadow(FloatRect& rect, int additionalOutlineSize) const
{
    int shadowLeft = 0;
    int shadowRight = 0;
    int shadowTop = 0;
    int shadowBottom = 0;
    calculateShadowExtent(this, additionalOutlineSize, shadowLeft, shadowRight, shadowTop, shadowBottom);

    rect.move(shadowLeft, shadowTop);
    rect.setWidth(rect.width() - shadowLeft + shadowRight);
    rect.setHeight(rect.height() - shadowTop + shadowBottom);
}
</file>

<file path="sharedbuffer.cpp">
// this_file: qlith-pro/src/sharedbuffer.cpp
#include "qlith/common.h"
#include "qlith/sharedbuffer.h"
#include "qlith/purgeablebuffer.h"

//#include "PurgeableBuffer.h"
//#include <wtf/PassOwnPtr.h>

using namespace std;

static const unsigned segmentSize = 0x1000;
static const unsigned segmentPositionMask = 0x0FFF;

static inline unsigned segmentIndex(unsigned position)
{
    return position / segmentSize;
}

static inline unsigned offsetInSegment(unsigned position)
{
    return position & segmentPositionMask;
}

static inline char* allocateSegment()
{
    return static_cast<char*>(malloc(segmentSize));
}

static inline void freeSegment(char* p)
{
    free(p);
}

SharedBuffer::SharedBuffer()
    : m_size(0)
{
}

SharedBuffer::SharedBuffer(const char* data, int size)
    : m_size(0)
{
    append(data, size);
}

SharedBuffer::SharedBuffer(const unsigned char* data, int size)
    : m_size(0)
{
    append(reinterpret_cast<const char*>(data), size);
}

SharedBuffer::~SharedBuffer()
{
    clear();
}

PassRefPtr<SharedBuffer> SharedBuffer::adoptVector(QVector<char>& vector)
{
    RefPtr<SharedBuffer> buffer = create();
    buffer->m_buffer.swap(vector);
    buffer->m_size = buffer->m_buffer.size();
    return buffer;//buffer.release();
}

PassRefPtr<SharedBuffer> SharedBuffer::adoptPurgeableBuffer(PassOwnPtr<PurgeableBuffer> purgeableBuffer)
{
    ASSERT(!purgeableBuffer->isPurgeable());
    RefPtr<SharedBuffer> buffer = create();
    //buffer->m_purgeableBuffer = purgeableBuffer;
    buffer->m_purgeableBuffer.swap(  purgeableBuffer );
    return buffer;//buffer.release();
}

unsigned SharedBuffer::size() const
{
    if (hasPlatformData())
        return platformDataSize();

    if (m_purgeableBuffer)
        return m_purgeableBuffer->size();

    return m_size;
}

const char* SharedBuffer::data() const
{
    if (hasPlatformData())
        return platformData();

    if (m_purgeableBuffer)
        return m_purgeableBuffer->data();

    return buffer().data();
}

void SharedBuffer::append(const char* data, unsigned length)
{
    ASSERT(!m_purgeableBuffer);

    maybeTransferPlatformData();

    unsigned positionInSegment = offsetInSegment(m_size - m_buffer.size());
    m_size += length;

    if (m_size <= segmentSize) {
        // No need to use segments for small resource data
        //m_buffer.append(data, length);

        //m_buffer.resize(length);
        //memcpy(&m_buffer[0], data,length);
        std::copy(data, data + length, std::back_inserter(m_buffer));
        return;
    }

    char* segment;
    if (!positionInSegment) {
        segment = allocateSegment();
        m_segments.append(segment);
    } else
        segment = m_segments.last() + positionInSegment;

    unsigned segmentFreeSpace = segmentSize - positionInSegment;
    unsigned bytesToCopy = min(length, segmentFreeSpace);

    for (;;) {
        memcpy(segment, data, bytesToCopy);
        if (static_cast<unsigned>(length) == bytesToCopy)
            break;

        length -= bytesToCopy;
        data += bytesToCopy;
        segment = allocateSegment();
        m_segments.append(segment);
        bytesToCopy = min(length, segmentSize);
    }
}

void SharedBuffer::clear()
{
    clearPlatformData();

    for (unsigned i = 0; i < m_segments.size(); ++i)
        freeSegment(m_segments[i]);

    m_segments.clear();
    m_size = 0;

    m_buffer.clear();
    //m_purgeableBuffer.clear();
    m_purgeableBuffer.reset();
}

PassRefPtr<SharedBuffer> SharedBuffer::copy() const
{
    RefPtr<SharedBuffer> clone(adoptRef<SharedBuffer>( ));
    if (m_purgeableBuffer || hasPlatformData()) {
        clone->append(data(), size());
        return clone;
    }

    clone->m_size = m_size;
    clone->m_buffer.reserve(m_size);//reserveCapacity(m_size);
    //clone->m_buffer = m_buffer;//append(m_buffer.data(), m_buffer.size());
    std::copy(m_buffer.data(), m_buffer.data() + m_buffer.size(), std::back_inserter(m_buffer));

    // TODO: do we need it >>>>>????
    ///
    //for (unsigned i = 0; i < m_segments.size(); ++i)
    //    clone->m_buffer.push_back(m_segments[i]);//.append(m_segments[i], segmentSize);

    return clone;
}

PassOwnPtr<PurgeableBuffer> SharedBuffer::releasePurgeableBuffer()
{
    //ASSERT(hasOneRef());
    //return m_purgeableBuffer.release();
    return std::move(m_purgeableBuffer);
}

const QVector<char>& SharedBuffer::buffer() const
{
    unsigned bufferSize = m_buffer.size();
    if (m_size > bufferSize) {
        m_buffer.resize(m_size);
        char* destination = m_buffer.data() + bufferSize;
        unsigned bytesLeft = m_size - bufferSize;
        for (unsigned i = 0; i < m_segments.size(); ++i) {
            unsigned bytesToCopy = min(bytesLeft, segmentSize);
            memcpy(destination, m_segments[i], bytesToCopy);
            destination += bytesToCopy;
            bytesLeft -= bytesToCopy;
            freeSegment(m_segments[i]);
        }
        m_segments.clear();
    }
    return m_buffer;
}

unsigned SharedBuffer::getSomeData(const char*& someData, unsigned position) const
{
    if (hasPlatformData() || m_purgeableBuffer) {
        someData = data() + position;
        return size() - position;
    }

    if (position >= m_size) {
        someData = 0;
        return 0;
    }

    unsigned consecutiveSize = m_buffer.size();
    if (position < consecutiveSize) {
        someData = m_buffer.data() + position;
        return consecutiveSize - position;
    }

    position -= consecutiveSize;
    unsigned segmentedSize = m_size - consecutiveSize;
    unsigned segments = m_segments.size();
    unsigned segment = segmentIndex(position);
    ASSERT(segment < segments);

    unsigned positionInSegment = offsetInSegment(position);
    someData = m_segments[segment] + positionInSegment;
    return segment == segments - 1 ? segmentedSize - position : segmentSize - positionInSegment;
}

//#if !PLATFORM(CF) || PLATFORM(QT) || PLATFORM(CLUTTER)

inline void SharedBuffer::clearPlatformData()
{
}

inline void SharedBuffer::maybeTransferPlatformData()
{
}

inline bool SharedBuffer::hasPlatformData() const
{
    return false;
}

inline const char* SharedBuffer::platformData() const
{
    //ASSERT_NOT_REACHED();

    return 0;
}

inline unsigned SharedBuffer::platformDataSize() const
{
    //ASSERT_NOT_REACHED();

    return 0;
}

//#endif
</file>

<file path="stillimageqt.cpp">
// this_file: qlith-pro/src/stillimageqt.cpp
#include "qlith/stillimageqt.h"

#include "qlith/common.h"

#include "qlith/graphicscontext.h"
#include "qlith/intsize.h"

#include <QPainter>

StillImage::StillImage(const QPixmap& pixmap)
    : m_pixmap(new QPixmap(pixmap))
    , m_ownsPixmap(true)
{}

StillImage::StillImage(const QPixmap* pixmap)
    : m_pixmap(pixmap)
    , m_ownsPixmap(false)
{}

StillImage::~StillImage()
{
    if (m_ownsPixmap)
        delete m_pixmap;
}

IntSize StillImage::size() const
{
    return IntSize(m_pixmap->width(), m_pixmap->height());
}

NativeImagePtr StillImage::nativeImageForCurrentFrame()
{
    return const_cast<NativeImagePtr>(m_pixmap);
}

void StillImage::draw(GraphicsContext* ctxt, const FloatRect& dst,
                      const FloatRect& src, ColorSpace, CompositeOperator op)
{
    if (m_pixmap->isNull())
        return;


    FloatRect normalizedSrc = src.normalized();
    FloatRect normalizedDst = dst.normalized();

    QPainter* painter = ctxt->platformContext();
    QPainter::CompositionMode oldCompositionMode = painter->compositionMode();

    ctxt->setCompositeOperation(op);

    FloatSize shadowOffset;
    float shadowBlur;
    Color shadowColor;

    // TODO

    if (ctxt->getShadow(shadowOffset, shadowBlur, shadowColor)) {
        FloatRect shadowImageRect(normalizedDst);
        shadowImageRect.move(shadowOffset.width(), shadowOffset.height());

        QImage shadowImage(QSize(static_cast<int>(normalizedSrc.width()), static_cast<int>(normalizedSrc.height())), QImage::Format_ARGB32_Premultiplied);
        QPainter p(&shadowImage);
        p.setCompositionMode(QPainter::CompositionMode_Source);
        p.fillRect(shadowImage.rect(), shadowColor);
        p.setCompositionMode(QPainter::CompositionMode_DestinationIn);
        p.drawPixmap(QRect(0, 0, normalizedDst.width(), normalizedDst.height()), *m_pixmap, normalizedSrc);
        p.end();
        painter->drawImage(shadowImageRect, shadowImage, normalizedSrc);
    }

    painter->drawPixmap(normalizedDst, *m_pixmap, normalizedSrc);
    painter->setCompositionMode(oldCompositionMode);
}
</file>

<file path="styleimage.cpp">
// this_file: qlith-pro/src/styleimage.cpp
#include "qlith/styleimage.h"
</file>

<file path="transformationmatrix.cpp">
// this_file: qlith-pro/src/transformationmatrix.cpp
#include "qlith/transformationmatrix.h"

#include "qlith/floatquad.h"
#include "qlith/floatrect.h"
#include "qlith/intrect.h"
#include "qlith/floatpoint3d.h"

/*#include "config.h"
#include "TransformationMatrix.h"

#include "FloatPoint3D.h"
#include "FloatRect.h"
#include "IntRect.h"

#include <wtf/Assertions.h>
#include <wtf/MathExtras.h>*/

//
// Supporting Math Functions
//
// This is a set of function from various places (attributed inline) to do things like
// inversion and decomposition of a 4x4 matrix. They are used throughout the code
//

//
// Adapted from Matrix Inversion by Richard Carling, Graphics Gems <http://tog.acm.org/GraphicsGems/index.html>.

// EULA: The Graphics Gems code is copyright-protected. In other words, you cannot claim the text of the code
// as your own and resell it. Using the code is permitted in any program, product, or library, non-commercial
// or commercial. Giving credit is not required, though is a nice gesture. The code comes as-is, and if there
// are any flaws or problems with any Gems code, nobody involved with Gems - authors, editors, publishers, or
// webmasters - are to be held responsible. Basically, don't be a jerk, and remember that anything free comes
// with no guarantee.

// A Note About row-major vs. column major matrixes
//
// The clients of this class (CSSMatrix and SVGMatrix) assume a column-major ordering.
// That means that when the matrix is initialized with 16 values, the first 4 values
// go in the 4 rows of the first column, etc. And in the dereferencing calls, the first
// digit is the column (e.g., m23() is column 2 row 3). Because C++ uses row-major arrays
// the internal matrix is stored in row-major order, so m[2][0] means row 2, column 0. This
// has no bearing on how the matrix is viewed on the outside, since all access is done
// with function calls. But it does help make the code more clear if you know that.
//
// FIXME: Multiply calls are named for what they do in the internal, row-major world.
// multLeft is actually a multRight in a column-major world, and multiply is a multLeft
// in a column-major world. For now I've left it that way to avoid too many confusing
// changes to the code. In particular AffineTransform uses these same terms for the
// opposite operations. So we have to be VERY careful when we change them.

typedef double Vector4[4];
typedef double Vector3[3];

const double SMALL_NUMBER = 1.e-8;

// inverse(original_matrix, inverse_matrix)
//
// calculate the inverse of a 4x4 matrix
//
// -1
// A  = ___1__ adjoint A
//       det A

//  double = determinant2x2(double a, double b, double c, double d)
//
//  calculate the determinant of a 2x2 matrix.

static double determinant2x2(double a, double b, double c, double d)
{
    return a * d - b * c;
}

//  double = determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3)
//
//  Calculate the determinant of a 3x3 matrix
//  in the form
//
//      | a1,  b1,  c1 |
//      | a2,  b2,  c2 |
//      | a3,  b3,  c3 |

static double determinant3x3(double a1, double a2, double a3, double b1, double b2, double b3, double c1, double c2, double c3)
{
    return a1 * determinant2x2(b2, b3, c2, c3)
         - b1 * determinant2x2(a2, a3, c2, c3)
         + c1 * determinant2x2(a2, a3, b2, b3);
}

//  double = determinant4x4(matrix)
//
//  calculate the determinant of a 4x4 matrix.

static double determinant4x4(const TransformationMatrix::Matrix4& m)
{
    // Assign to individual variable names to aid selecting
    // correct elements

    double a1 = m[0][0];
    double b1 = m[0][1];
    double c1 = m[0][2];
    double d1 = m[0][3];

    double a2 = m[1][0];
    double b2 = m[1][1];
    double c2 = m[1][2];
    double d2 = m[1][3];

    double a3 = m[2][0];
    double b3 = m[2][1];
    double c3 = m[2][2];
    double d3 = m[2][3];

    double a4 = m[3][0];
    double b4 = m[3][1];
    double c4 = m[3][2];
    double d4 = m[3][3];

    return a1 * determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4)
         - b1 * determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4)
         + c1 * determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4)
         - d1 * determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
}

// adjoint( original_matrix, inverse_matrix )
//
//   calculate the adjoint of a 4x4 matrix
//
//    Let  a   denote the minor determinant of matrix A obtained by
//         ij
//
//    deleting the ith row and jth column from A.
//
//                  i+j
//   Let  b   = (-1)    a
//        ij            ji
//
//  The matrix B = (b  ) is the adjoint of A
//                   ij

static void adjoint(const TransformationMatrix::Matrix4& matrix, TransformationMatrix::Matrix4& result)
{
    // Assign to individual variable names to aid
    // selecting correct values
    double a1 = matrix[0][0];
    double b1 = matrix[0][1];
    double c1 = matrix[0][2];
    double d1 = matrix[0][3];

    double a2 = matrix[1][0];
    double b2 = matrix[1][1];
    double c2 = matrix[1][2];
    double d2 = matrix[1][3];

    double a3 = matrix[2][0];
    double b3 = matrix[2][1];
    double c3 = matrix[2][2];
    double d3 = matrix[2][3];

    double a4 = matrix[3][0];
    double b4 = matrix[3][1];
    double c4 = matrix[3][2];
    double d4 = matrix[3][3];

    // Row column labeling reversed since we transpose rows & columns
    result[0][0]  =   determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
    result[1][0]  = - determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
    result[2][0]  =   determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
    result[3][0]  = - determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);

    result[0][1]  = - determinant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
    result[1][1]  =   determinant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
    result[2][1]  = - determinant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
    result[3][1]  =   determinant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);

    result[0][2]  =   determinant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
    result[1][2]  = - determinant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
    result[2][2]  =   determinant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
    result[3][2]  = - determinant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);

    result[0][3]  = - determinant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
    result[1][3]  =   determinant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
    result[2][3]  = - determinant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
    result[3][3]  =   determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);
}

// Returns false if the matrix is not invertible
static bool inverse(const TransformationMatrix::Matrix4& matrix, TransformationMatrix::Matrix4& result)
{
    // Calculate the adjoint matrix
    adjoint(matrix, result);

    // Calculate the 4x4 determinant
    // If the determinant is zero,
    // then the inverse matrix is not unique.
    double det = determinant4x4(matrix);

    if (fabs(det) < SMALL_NUMBER)
        return false;

    // Scale the adjoint matrix to get the inverse

    for (int i = 0; i < 4; i++)
        for (int j = 0; j < 4; j++)
            result[i][j] = result[i][j] / det;

    return true;
}

// End of code adapted from Matrix Inversion by Richard Carling

// Perform a decomposition on the passed matrix, return false if unsuccessful
// From Graphics Gems: unmatrix.c

// Transpose rotation portion of matrix a, return b
static void transposeMatrix4(const TransformationMatrix::Matrix4& a, TransformationMatrix::Matrix4& b)
{
    for (int i = 0; i < 4; i++)
        for (int j = 0; j < 4; j++)
            b[i][j] = a[j][i];
}

// Multiply a homogeneous point by a matrix and return the transformed point
static void v4MulPointByMatrix(const Vector4 p, const TransformationMatrix::Matrix4& m, Vector4 result)
{
    result[0] = (p[0] * m[0][0]) + (p[1] * m[1][0]) +
                (p[2] * m[2][0]) + (p[3] * m[3][0]);
    result[1] = (p[0] * m[0][1]) + (p[1] * m[1][1]) +
                (p[2] * m[2][1]) + (p[3] * m[3][1]);
    result[2] = (p[0] * m[0][2]) + (p[1] * m[1][2]) +
                (p[2] * m[2][2]) + (p[3] * m[3][2]);
    result[3] = (p[0] * m[0][3]) + (p[1] * m[1][3]) +
                (p[2] * m[2][3]) + (p[3] * m[3][3]);
}

static double v3Length(Vector3 a)
{
    return sqrt((a[0] * a[0]) + (a[1] * a[1]) + (a[2] * a[2]));
}

static void v3Scale(Vector3 v, double desiredLength)
{
    double len = v3Length(v);
    if (len != 0) {
        double l = desiredLength / len;
        v[0] *= l;
        v[1] *= l;
        v[2] *= l;
    }
}

static double v3Dot(const Vector3 a, const Vector3 b)
{
    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);
}

// Make a linear combination of two vectors and return the result.
// result = (a * ascl) + (b * bscl)
static void v3Combine(const Vector3 a, const Vector3 b, Vector3 result, double ascl, double bscl)
{
    result[0] = (ascl * a[0]) + (bscl * b[0]);
    result[1] = (ascl * a[1]) + (bscl * b[1]);
    result[2] = (ascl * a[2]) + (bscl * b[2]);
}

// Return the cross product result = a cross b */
static void v3Cross(const Vector3 a, const Vector3 b, Vector3 result)
{
    result[0] = (a[1] * b[2]) - (a[2] * b[1]);
    result[1] = (a[2] * b[0]) - (a[0] * b[2]);
    result[2] = (a[0] * b[1]) - (a[1] * b[0]);
}

static bool decompose(const TransformationMatrix::Matrix4& mat, TransformationMatrix::DecomposedType& result)
{
    TransformationMatrix::Matrix4 localMatrix;
    memcpy(localMatrix, mat, sizeof(TransformationMatrix::Matrix4));

    // Normalize the matrix.
    if (localMatrix[3][3] == 0)
        return false;

    int i, j;
    for (i = 0; i < 4; i++)
        for (j = 0; j < 4; j++)
            localMatrix[i][j] /= localMatrix[3][3];

    // perspectiveMatrix is used to solve for perspective, but it also provides
    // an easy way to test for singularity of the upper 3x3 component.
    TransformationMatrix::Matrix4 perspectiveMatrix;
    memcpy(perspectiveMatrix, localMatrix, sizeof(TransformationMatrix::Matrix4));
    for (i = 0; i < 3; i++)
        perspectiveMatrix[i][3] = 0;
    perspectiveMatrix[3][3] = 1;

    if (determinant4x4(perspectiveMatrix) == 0)
        return false;

    // First, isolate perspective.  This is the messiest.
    if (localMatrix[0][3] != 0 || localMatrix[1][3] != 0 || localMatrix[2][3] != 0) {
        // rightHandSide is the right hand side of the equation.
        Vector4 rightHandSide;
        rightHandSide[0] = localMatrix[0][3];
        rightHandSide[1] = localMatrix[1][3];
        rightHandSide[2] = localMatrix[2][3];
        rightHandSide[3] = localMatrix[3][3];

        // Solve the equation by inverting perspectiveMatrix and multiplying
        // rightHandSide by the inverse.  (This is the easiest way, not
        // necessarily the best.)
        TransformationMatrix::Matrix4 inversePerspectiveMatrix, transposedInversePerspectiveMatrix;
        inverse(perspectiveMatrix, inversePerspectiveMatrix);
        transposeMatrix4(inversePerspectiveMatrix, transposedInversePerspectiveMatrix);

        Vector4 perspectivePoint;
        v4MulPointByMatrix(rightHandSide, transposedInversePerspectiveMatrix, perspectivePoint);

        result.perspectiveX = perspectivePoint[0];
        result.perspectiveY = perspectivePoint[1];
        result.perspectiveZ = perspectivePoint[2];
        result.perspectiveW = perspectivePoint[3];

        // Clear the perspective partition
        localMatrix[0][3] = localMatrix[1][3] = localMatrix[2][3] = 0;
        localMatrix[3][3] = 1;
    } else {
        // No perspective.
        result.perspectiveX = result.perspectiveY = result.perspectiveZ = 0;
        result.perspectiveW = 1;
    }

    // Next take care of translation (easy).
    result.translateX = localMatrix[3][0];
    localMatrix[3][0] = 0;
    result.translateY = localMatrix[3][1];
    localMatrix[3][1] = 0;
    result.translateZ = localMatrix[3][2];
    localMatrix[3][2] = 0;

    // Vector4 type and functions need to be added to the common set.
    Vector3 row[3], pdum3;

    // Now get scale and shear.
    for (i = 0; i < 3; i++) {
        row[i][0] = localMatrix[i][0];
        row[i][1] = localMatrix[i][1];
        row[i][2] = localMatrix[i][2];
    }

    // Compute X scale factor and normalize first row.
    result.scaleX = v3Length(row[0]);
    v3Scale(row[0], 1.0);

    // Compute XY shear factor and make 2nd row orthogonal to 1st.
    result.skewXY = v3Dot(row[0], row[1]);
    v3Combine(row[1], row[0], row[1], 1.0, -result.skewXY);

    // Now, compute Y scale and normalize 2nd row.
    result.scaleY = v3Length(row[1]);
    v3Scale(row[1], 1.0);
    result.skewXY /= result.scaleY;

    // Compute XZ and YZ shears, orthogonalize 3rd row.
    result.skewXZ = v3Dot(row[0], row[2]);
    v3Combine(row[2], row[0], row[2], 1.0, -result.skewXZ);
    result.skewYZ = v3Dot(row[1], row[2]);
    v3Combine(row[2], row[1], row[2], 1.0, -result.skewYZ);

    // Next, get Z scale and normalize 3rd row.
    result.scaleZ = v3Length(row[2]);
    v3Scale(row[2], 1.0);
    result.skewXZ /= result.scaleZ;
    result.skewYZ /= result.scaleZ;

    // At this point, the matrix (in rows[]) is orthonormal.
    // Check for a coordinate system flip.  If the determinant
    // is -1, then negate the matrix and the scaling factors.
    v3Cross(row[1], row[2], pdum3);
    if (v3Dot(row[0], pdum3) < 0) {
        for (i = 0; i < 3; i++) {
            result.scaleX *= -1;
            row[i][0] *= -1;
            row[i][1] *= -1;
            row[i][2] *= -1;
        }
    }

    // Now, get the rotations out, as described in the gem.

    // FIXME - Add the ability to return either quaternions (which are
    // easier to recompose with) or Euler angles (rx, ry, rz), which
    // are easier for authors to deal with. The latter will only be useful
    // when we fix https://bugs.webkit.org/show_bug.cgi?id=23799, so I
    // will leave the Euler angle code here for now.

    // ret.rotateY = asin(-row[0][2]);
    // if (cos(ret.rotateY) != 0) {
    //     ret.rotateX = atan2(row[1][2], row[2][2]);
    //     ret.rotateZ = atan2(row[0][1], row[0][0]);
    // } else {
    //     ret.rotateX = atan2(-row[2][0], row[1][1]);
    //     ret.rotateZ = 0;
    // }

    double s, t, x, y, z, w;

    t = row[0][0] + row[1][1] + row[2][2] + 1.0;

    if (t > 1e-4) {
        s = 0.5 / sqrt(t);
        w = 0.25 / s;
        x = (row[2][1] - row[1][2]) * s;
        y = (row[0][2] - row[2][0]) * s;
        z = (row[1][0] - row[0][1]) * s;
    } else if (row[0][0] > row[1][1] && row[0][0] > row[2][2]) {
        s = sqrt (1.0 + row[0][0] - row[1][1] - row[2][2]) * 2.0; // S=4*qx
        x = 0.25 * s;
        y = (row[0][1] + row[1][0]) / s;
        z = (row[0][2] + row[2][0]) / s;
        w = (row[2][1] - row[1][2]) / s;
    } else if (row[1][1] > row[2][2]) {
        s = sqrt (1.0 + row[1][1] - row[0][0] - row[2][2]) * 2.0; // S=4*qy
        x = (row[0][1] + row[1][0]) / s;
        y = 0.25 * s;
        z = (row[1][2] + row[2][1]) / s;
        w = (row[0][2] - row[2][0]) / s;
    } else {
        s = sqrt(1.0 + row[2][2] - row[0][0] - row[1][1]) * 2.0; // S=4*qz
        x = (row[0][2] + row[2][0]) / s;
        y = (row[1][2] + row[2][1]) / s;
        z = 0.25 * s;
        w = (row[1][0] - row[0][1]) / s;
    }

    result.quaternionX = x;
    result.quaternionY = y;
    result.quaternionZ = z;
    result.quaternionW = w;

    return true;
}

// Perform a spherical linear interpolation between the two
// passed quaternions with 0 <= t <= 1
static void slerp(double qa[4], const double qb[4], double t)
{
    double ax, ay, az, aw;
    double bx, by, bz, bw;
    double cx, cy, cz, cw;
    double angle;
    double th, invth, scale, invscale;

    ax = qa[0]; ay = qa[1]; az = qa[2]; aw = qa[3];
    bx = qb[0]; by = qb[1]; bz = qb[2]; bw = qb[3];

    angle = ax * bx + ay * by + az * bz + aw * bw;

    if (angle < 0.0) {
        ax = -ax; ay = -ay;
        az = -az; aw = -aw;
        angle = -angle;
    }

    if (angle + 1.0 > .05) {
        if (1.0 - angle >= .05) {
            th = acos (angle);
            invth = 1.0 / sin (th);
            scale = sin (th * (1.0 - t)) * invth;
            invscale = sin (th * t) * invth;
        } else {
            scale = 1.0 - t;
            invscale = t;
        }
    } else {
        bx = -ay;
        by = ax;
        bz = -aw;
        bw = az;
        scale = sin(piDouble * (.5 - t));
        invscale = sin (piDouble * t);
    }

    cx = ax * scale + bx * invscale;
    cy = ay * scale + by * invscale;
    cz = az * scale + bz * invscale;
    cw = aw * scale + bw * invscale;

    qa[0] = cx; qa[1] = cy; qa[2] = cz; qa[3] = cw;
}

// End of Supporting Math Functions

TransformationMatrix& TransformationMatrix::scale(double s)
{
    return scaleNonUniform(s, s);
}

TransformationMatrix& TransformationMatrix::rotateFromVector(double x, double y)
{
    return rotate(rad2deg(atan2(y, x)));
}

TransformationMatrix& TransformationMatrix::flipX()
{
    return scaleNonUniform(-1.0f, 1.0f);
}

TransformationMatrix& TransformationMatrix::flipY()
{
    return scaleNonUniform(1.0f, -1.0f);
}

FloatPoint TransformationMatrix::projectPoint(const FloatPoint& p) const
{
    // This is basically raytracing. We have a point in the destination
    // plane with z=0, and we cast a ray parallel to the z-axis from that
    // point to find the z-position at which it intersects the z=0 plane
    // with the transform applied. Once we have that point we apply the
    // inverse transform to find the corresponding point in the source
    // space.
    //
    // Given a plane with normal Pn, and a ray starting at point R0 and
    // with direction defined by the vector Rd, we can find the
    // intersection point as a distance d from R0 in units of Rd by:
    //
    // d = -dot (Pn', R0) / dot (Pn', Rd)

    double x = p.x();
    double y = p.y();
    double z = -(m13() * x + m23() * y + m43()) / m33();

    double outX = x * m11() + y * m21() + z * m31() + m41();
    double outY = x * m12() + y * m22() + z * m32() + m42();

    double w = x * m14() + y * m24() + z * m34() + m44();
    if (w != 1 && w != 0) {
        outX /= w;
        outY /= w;
    }

    return FloatPoint(static_cast<float>(outX), static_cast<float>(outY));
}

FloatQuad TransformationMatrix::projectQuad(const FloatQuad& q) const
{
    FloatQuad projectedQuad;
    projectedQuad.setP1(projectPoint(q.p1()));
    projectedQuad.setP2(projectPoint(q.p2()));
    projectedQuad.setP3(projectPoint(q.p3()));
    projectedQuad.setP4(projectPoint(q.p4()));
    return projectedQuad;
}

FloatPoint TransformationMatrix::mapPoint(const FloatPoint& p) const
{
    if (isIdentityOrTranslation())
        return FloatPoint(p.x() + static_cast<float>(m_matrix[3][0]), p.y() + static_cast<float>(m_matrix[3][1]));

    double x, y;
    multVecMatrix(p.x(), p.y(), x, y);
    return FloatPoint(static_cast<float>(x), static_cast<float>(y));
}

FloatPoint3D TransformationMatrix::mapPoint(const FloatPoint3D& p) const
{
    if (isIdentityOrTranslation())
        return FloatPoint3D(p.x() + static_cast<float>(m_matrix[3][0]),
                            p.y() + static_cast<float>(m_matrix[3][1]),
                            p.z() + static_cast<float>(m_matrix[3][2]));

    double x, y, z;
    multVecMatrix(p.x(), p.y(), p.z(), x, y, z);
    return FloatPoint3D(static_cast<float>(x), static_cast<float>(y), static_cast<float>(z));
}

IntRect TransformationMatrix::mapRect(const IntRect &rect) const
{
    return enclosingIntRect(mapRect(FloatRect(rect)));
}

FloatRect TransformationMatrix::mapRect(const FloatRect& r) const
{
    if (isIdentityOrTranslation()) {
        FloatRect mappedRect(r);
        mappedRect.move(static_cast<float>(m_matrix[3][0]), static_cast<float>(m_matrix[3][1]));
        return mappedRect;
    }

    FloatQuad resultQuad = mapQuad(FloatQuad(r));
    return resultQuad.boundingBox();
}

FloatQuad TransformationMatrix::mapQuad(const FloatQuad& q) const
{
    if (isIdentityOrTranslation()) {
        FloatQuad mappedQuad(q);
        mappedQuad.move(static_cast<float>(m_matrix[3][0]), static_cast<float>(m_matrix[3][1]));
        return mappedQuad;
    }

    FloatQuad result;
    result.setP1(mapPoint(q.p1()));
    result.setP2(mapPoint(q.p2()));
    result.setP3(mapPoint(q.p3()));
    result.setP4(mapPoint(q.p4()));
    return result;
}

TransformationMatrix& TransformationMatrix::scaleNonUniform(double sx, double sy)
{
    TransformationMatrix mat;
    mat.m_matrix[0][0] = sx;
    mat.m_matrix[1][1] = sy;

    multLeft(mat);
    return *this;
}

TransformationMatrix& TransformationMatrix::scale3d(double sx, double sy, double sz)
{
    TransformationMatrix mat;
    mat.m_matrix[0][0] = sx;
    mat.m_matrix[1][1] = sy;
    mat.m_matrix[2][2] = sz;

    multLeft(mat);
    return *this;
}

TransformationMatrix& TransformationMatrix::rotate3d(double x, double y, double z, double angle)
{
    // angles are in degrees. Switch to radians
    angle = deg2rad(angle);

    angle /= 2.0f;
    double sinA = sin(angle);
    double cosA = cos(angle);
    double sinA2 = sinA * sinA;

    // normalize
    double length = sqrt(x * x + y * y + z * z);
    if (length == 0) {
        // bad vector, just use something reasonable
        x = 0;
        y = 0;
        z = 1;
    } else if (length != 1) {
        x /= length;
        y /= length;
        z /= length;
    }

    TransformationMatrix mat;

    // optimize case where axis is along major axis
    if (x == 1.0f && y == 0.0f && z == 0.0f) {
        mat.m_matrix[0][0] = 1.0f;
        mat.m_matrix[0][1] = 0.0f;
        mat.m_matrix[0][2] = 0.0f;
        mat.m_matrix[1][0] = 0.0f;
        mat.m_matrix[1][1] = 1.0f - 2.0f * sinA2;
        mat.m_matrix[1][2] = 2.0f * sinA * cosA;
        mat.m_matrix[2][0] = 0.0f;
        mat.m_matrix[2][1] = -2.0f * sinA * cosA;
        mat.m_matrix[2][2] = 1.0f - 2.0f * sinA2;
        mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0f;
        mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0f;
        mat.m_matrix[3][3] = 1.0f;
    } else if (x == 0.0f && y == 1.0f && z == 0.0f) {
        mat.m_matrix[0][0] = 1.0f - 2.0f * sinA2;
        mat.m_matrix[0][1] = 0.0f;
        mat.m_matrix[0][2] = -2.0f * sinA * cosA;
        mat.m_matrix[1][0] = 0.0f;
        mat.m_matrix[1][1] = 1.0f;
        mat.m_matrix[1][2] = 0.0f;
        mat.m_matrix[2][0] = 2.0f * sinA * cosA;
        mat.m_matrix[2][1] = 0.0f;
        mat.m_matrix[2][2] = 1.0f - 2.0f * sinA2;
        mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0f;
        mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0f;
        mat.m_matrix[3][3] = 1.0f;
    } else if (x == 0.0f && y == 0.0f && z == 1.0f) {
        mat.m_matrix[0][0] = 1.0f - 2.0f * sinA2;
        mat.m_matrix[0][1] = 2.0f * sinA * cosA;
        mat.m_matrix[0][2] = 0.0f;
        mat.m_matrix[1][0] = -2.0f * sinA * cosA;
        mat.m_matrix[1][1] = 1.0f - 2.0f * sinA2;
        mat.m_matrix[1][2] = 0.0f;
        mat.m_matrix[2][0] = 0.0f;
        mat.m_matrix[2][1] = 0.0f;
        mat.m_matrix[2][2] = 1.0f;
        mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0f;
        mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0f;
        mat.m_matrix[3][3] = 1.0f;
    } else {
        double x2 = x*x;
        double y2 = y*y;
        double z2 = z*z;

        mat.m_matrix[0][0] = 1.0f - 2.0f * (y2 + z2) * sinA2;
        mat.m_matrix[0][1] = 2.0f * (x * y * sinA2 + z * sinA * cosA);
        mat.m_matrix[0][2] = 2.0f * (x * z * sinA2 - y * sinA * cosA);
        mat.m_matrix[1][0] = 2.0f * (y * x * sinA2 - z * sinA * cosA);
        mat.m_matrix[1][1] = 1.0f - 2.0f * (z2 + x2) * sinA2;
        mat.m_matrix[1][2] = 2.0f * (y * z * sinA2 + x * sinA * cosA);
        mat.m_matrix[2][0] = 2.0f * (z * x * sinA2 + y * sinA * cosA);
        mat.m_matrix[2][1] = 2.0f * (z * y * sinA2 - x * sinA * cosA);
        mat.m_matrix[2][2] = 1.0f - 2.0f * (x2 + y2) * sinA2;
        mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0f;
        mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0f;
        mat.m_matrix[3][3] = 1.0f;
    }
    multLeft(mat);
    return *this;
}

TransformationMatrix& TransformationMatrix::rotate3d(double rx, double ry, double rz)
{
    // angles are in degrees. Switch to radians
    rx = deg2rad(rx);
    ry = deg2rad(ry);
    rz = deg2rad(rz);

    TransformationMatrix mat;

    rz /= 2.0f;
    double sinA = sin(rz);
    double cosA = cos(rz);
    double sinA2 = sinA * sinA;

    mat.m_matrix[0][0] = 1.0f - 2.0f * sinA2;
    mat.m_matrix[0][1] = 2.0f * sinA * cosA;
    mat.m_matrix[0][2] = 0.0f;
    mat.m_matrix[1][0] = -2.0f * sinA * cosA;
    mat.m_matrix[1][1] = 1.0f - 2.0f * sinA2;
    mat.m_matrix[1][2] = 0.0f;
    mat.m_matrix[2][0] = 0.0f;
    mat.m_matrix[2][1] = 0.0f;
    mat.m_matrix[2][2] = 1.0f;
    mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0f;
    mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0f;
    mat.m_matrix[3][3] = 1.0f;

    TransformationMatrix rmat(mat);

    ry /= 2.0f;
    sinA = sin(ry);
    cosA = cos(ry);
    sinA2 = sinA * sinA;

    mat.m_matrix[0][0] = 1.0f - 2.0f * sinA2;
    mat.m_matrix[0][1] = 0.0f;
    mat.m_matrix[0][2] = -2.0f * sinA * cosA;
    mat.m_matrix[1][0] = 0.0f;
    mat.m_matrix[1][1] = 1.0f;
    mat.m_matrix[1][2] = 0.0f;
    mat.m_matrix[2][0] = 2.0f * sinA * cosA;
    mat.m_matrix[2][1] = 0.0f;
    mat.m_matrix[2][2] = 1.0f - 2.0f * sinA2;
    mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0f;
    mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0f;
    mat.m_matrix[3][3] = 1.0f;

    rmat.multLeft(mat);

    rx /= 2.0f;
    sinA = sin(rx);
    cosA = cos(rx);
    sinA2 = sinA * sinA;

    mat.m_matrix[0][0] = 1.0f;
    mat.m_matrix[0][1] = 0.0f;
    mat.m_matrix[0][2] = 0.0f;
    mat.m_matrix[1][0] = 0.0f;
    mat.m_matrix[1][1] = 1.0f - 2.0f * sinA2;
    mat.m_matrix[1][2] = 2.0f * sinA * cosA;
    mat.m_matrix[2][0] = 0.0f;
    mat.m_matrix[2][1] = -2.0f * sinA * cosA;
    mat.m_matrix[2][2] = 1.0f - 2.0f * sinA2;
    mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0f;
    mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0f;
    mat.m_matrix[3][3] = 1.0f;

    rmat.multLeft(mat);

    multLeft(rmat);
    return *this;
}

TransformationMatrix& TransformationMatrix::translate(double tx, double ty)
{
    m_matrix[3][0] += tx * m_matrix[0][0] + ty * m_matrix[1][0];
    m_matrix[3][1] += tx * m_matrix[0][1] + ty * m_matrix[1][1];
    m_matrix[3][2] += tx * m_matrix[0][2] + ty * m_matrix[1][2];
    m_matrix[3][3] += tx * m_matrix[0][3] + ty * m_matrix[1][3];
    return *this;
}

TransformationMatrix& TransformationMatrix::translate3d(double tx, double ty, double tz)
{
    m_matrix[3][0] += tx * m_matrix[0][0] + ty * m_matrix[1][0] + tz * m_matrix[2][0];
    m_matrix[3][1] += tx * m_matrix[0][1] + ty * m_matrix[1][1] + tz * m_matrix[2][1];
    m_matrix[3][2] += tx * m_matrix[0][2] + ty * m_matrix[1][2] + tz * m_matrix[2][2];
    m_matrix[3][3] += tx * m_matrix[0][3] + ty * m_matrix[1][3] + tz * m_matrix[2][3];
    return *this;
}

TransformationMatrix& TransformationMatrix::translateRight(double tx, double ty)
{
    if (tx != 0) {
        m_matrix[0][0] +=  m_matrix[0][3] * tx;
        m_matrix[1][0] +=  m_matrix[1][3] * tx;
        m_matrix[2][0] +=  m_matrix[2][3] * tx;
        m_matrix[3][0] +=  m_matrix[3][3] * tx;
    }

    if (ty != 0) {
        m_matrix[0][1] +=  m_matrix[0][3] * ty;
        m_matrix[1][1] +=  m_matrix[1][3] * ty;
        m_matrix[2][1] +=  m_matrix[2][3] * ty;
        m_matrix[3][1] +=  m_matrix[3][3] * ty;
    }

    return *this;
}

TransformationMatrix& TransformationMatrix::translateRight3d(double tx, double ty, double tz)
{
    translateRight(tx, ty);
    if (tz != 0) {
        m_matrix[0][2] +=  m_matrix[0][3] * tz;
        m_matrix[1][2] +=  m_matrix[1][3] * tz;
        m_matrix[2][2] +=  m_matrix[2][3] * tz;
        m_matrix[3][2] +=  m_matrix[3][3] * tz;
    }

    return *this;
}

TransformationMatrix& TransformationMatrix::skew(double sx, double sy)
{
    // angles are in degrees. Switch to radians
    sx = deg2rad(sx);
    sy = deg2rad(sy);

    TransformationMatrix mat;
    mat.m_matrix[0][1] = tan(sy); // note that the y shear goes in the first row
    mat.m_matrix[1][0] = tan(sx); // and the x shear in the second row

    multLeft(mat);
    return *this;
}

TransformationMatrix& TransformationMatrix::applyPerspective(double p)
{
    TransformationMatrix mat;
    if (p != 0)
        mat.m_matrix[2][3] = -1/p;

    multLeft(mat);
    return *this;
}

TransformationMatrix TransformationMatrix::rectToRect(const FloatRect& from, const FloatRect& to)
{
    ASSERT(!from.isEmpty());
    return TransformationMatrix(to.width() / from.width(),
                                0, 0,
                                to.height() / from.height(),
                                to.x() - from.x(),
                                to.y() - from.y());
}

//
// *this = mat * *this
//
TransformationMatrix& TransformationMatrix::multLeft(const TransformationMatrix& mat)
{
    Matrix4 tmp;

    tmp[0][0] = (mat.m_matrix[0][0] * m_matrix[0][0] + mat.m_matrix[0][1] * m_matrix[1][0]
               + mat.m_matrix[0][2] * m_matrix[2][0] + mat.m_matrix[0][3] * m_matrix[3][0]);
    tmp[0][1] = (mat.m_matrix[0][0] * m_matrix[0][1] + mat.m_matrix[0][1] * m_matrix[1][1]
               + mat.m_matrix[0][2] * m_matrix[2][1] + mat.m_matrix[0][3] * m_matrix[3][1]);
    tmp[0][2] = (mat.m_matrix[0][0] * m_matrix[0][2] + mat.m_matrix[0][1] * m_matrix[1][2]
               + mat.m_matrix[0][2] * m_matrix[2][2] + mat.m_matrix[0][3] * m_matrix[3][2]);
    tmp[0][3] = (mat.m_matrix[0][0] * m_matrix[0][3] + mat.m_matrix[0][1] * m_matrix[1][3]
               + mat.m_matrix[0][2] * m_matrix[2][3] + mat.m_matrix[0][3] * m_matrix[3][3]);

    tmp[1][0] = (mat.m_matrix[1][0] * m_matrix[0][0] + mat.m_matrix[1][1] * m_matrix[1][0]
               + mat.m_matrix[1][2] * m_matrix[2][0] + mat.m_matrix[1][3] * m_matrix[3][0]);
    tmp[1][1] = (mat.m_matrix[1][0] * m_matrix[0][1] + mat.m_matrix[1][1] * m_matrix[1][1]
               + mat.m_matrix[1][2] * m_matrix[2][1] + mat.m_matrix[1][3] * m_matrix[3][1]);
    tmp[1][2] = (mat.m_matrix[1][0] * m_matrix[0][2] + mat.m_matrix[1][1] * m_matrix[1][2]
               + mat.m_matrix[1][2] * m_matrix[2][2] + mat.m_matrix[1][3] * m_matrix[3][2]);
    tmp[1][3] = (mat.m_matrix[1][0] * m_matrix[0][3] + mat.m_matrix[1][1] * m_matrix[1][3]
               + mat.m_matrix[1][2] * m_matrix[2][3] + mat.m_matrix[1][3] * m_matrix[3][3]);

    tmp[2][0] = (mat.m_matrix[2][0] * m_matrix[0][0] + mat.m_matrix[2][1] * m_matrix[1][0]
               + mat.m_matrix[2][2] * m_matrix[2][0] + mat.m_matrix[2][3] * m_matrix[3][0]);
    tmp[2][1] = (mat.m_matrix[2][0] * m_matrix[0][1] + mat.m_matrix[2][1] * m_matrix[1][1]
               + mat.m_matrix[2][2] * m_matrix[2][1] + mat.m_matrix[2][3] * m_matrix[3][1]);
    tmp[2][2] = (mat.m_matrix[2][0] * m_matrix[0][2] + mat.m_matrix[2][1] * m_matrix[1][2]
               + mat.m_matrix[2][2] * m_matrix[2][2] + mat.m_matrix[2][3] * m_matrix[3][2]);
    tmp[2][3] = (mat.m_matrix[2][0] * m_matrix[0][3] + mat.m_matrix[2][1] * m_matrix[1][3]
               + mat.m_matrix[2][2] * m_matrix[2][3] + mat.m_matrix[2][3] * m_matrix[3][3]);

    tmp[3][0] = (mat.m_matrix[3][0] * m_matrix[0][0] + mat.m_matrix[3][1] * m_matrix[1][0]
               + mat.m_matrix[3][2] * m_matrix[2][0] + mat.m_matrix[3][3] * m_matrix[3][0]);
    tmp[3][1] = (mat.m_matrix[3][0] * m_matrix[0][1] + mat.m_matrix[3][1] * m_matrix[1][1]
               + mat.m_matrix[3][2] * m_matrix[2][1] + mat.m_matrix[3][3] * m_matrix[3][1]);
    tmp[3][2] = (mat.m_matrix[3][0] * m_matrix[0][2] + mat.m_matrix[3][1] * m_matrix[1][2]
               + mat.m_matrix[3][2] * m_matrix[2][2] + mat.m_matrix[3][3] * m_matrix[3][2]);
    tmp[3][3] = (mat.m_matrix[3][0] * m_matrix[0][3] + mat.m_matrix[3][1] * m_matrix[1][3]
               + mat.m_matrix[3][2] * m_matrix[2][3] + mat.m_matrix[3][3] * m_matrix[3][3]);

    setMatrix(tmp);
    return *this;
}

void TransformationMatrix::multVecMatrix(double x, double y, double& resultX, double& resultY) const
{
    resultX = m_matrix[3][0] + x * m_matrix[0][0] + y * m_matrix[1][0];
    resultY = m_matrix[3][1] + x * m_matrix[0][1] + y * m_matrix[1][1];
    double w = m_matrix[3][3] + x * m_matrix[0][3] + y * m_matrix[1][3];
    if (w != 1 && w != 0) {
        resultX /= w;
        resultY /= w;
    }
}

void TransformationMatrix::multVecMatrix(double x, double y, double z, double& resultX, double& resultY, double& resultZ) const
{
    resultX = m_matrix[3][0] + x * m_matrix[0][0] + y * m_matrix[1][0] + z * m_matrix[2][0];
    resultY = m_matrix[3][1] + x * m_matrix[0][1] + y * m_matrix[1][1] + z * m_matrix[2][1];
    resultZ = m_matrix[3][2] + x * m_matrix[0][2] + y * m_matrix[1][2] + z * m_matrix[2][2];
    double w = m_matrix[3][3] + x * m_matrix[0][3] + y * m_matrix[1][3] + z * m_matrix[2][3];
    if (w != 1 && w != 0) {
        resultX /= w;
        resultY /= w;
        resultZ /= w;
    }
}

bool TransformationMatrix::isInvertible() const
{
    if (isIdentityOrTranslation())
        return true;

    //double det = WebCore::determinant4x4(m_matrix);
    double det = ::determinant4x4(m_matrix);

    if (fabs(det) < SMALL_NUMBER)
        return false;

    return true;
}

TransformationMatrix TransformationMatrix::inverse() const
{
    if (isIdentityOrTranslation()) {
        // identity matrix
        if (m_matrix[3][0] == 0 && m_matrix[3][1] == 0 && m_matrix[3][2] == 0)
            return TransformationMatrix();

        // translation
        return TransformationMatrix(1, 0, 0, 0,
                                    0, 1, 0, 0,
                                    0, 0, 1, 0,
                                    -m_matrix[3][0], -m_matrix[3][1], -m_matrix[3][2], 1);
    }

    TransformationMatrix invMat;
    //bool inverted = WebCore::inverse(m_matrix, invMat.m_matrix);
    bool inverted = ::inverse(m_matrix, invMat.m_matrix);
    if (!inverted)
        return TransformationMatrix();

    return invMat;
}

void TransformationMatrix::makeAffine()
{
    m_matrix[0][2] = 0;
    m_matrix[0][3] = 0;

    m_matrix[1][2] = 0;
    m_matrix[1][3] = 0;

    m_matrix[2][0] = 0;
    m_matrix[2][1] = 0;
    m_matrix[2][2] = 1;
    m_matrix[2][3] = 0;

    m_matrix[3][2] = 0;
    m_matrix[3][3] = 1;
}

AffineTransform TransformationMatrix::toAffineTransform() const
{
    return AffineTransform(m_matrix[0][0], m_matrix[0][1], m_matrix[1][0],
                           m_matrix[1][1], m_matrix[3][0], m_matrix[3][1]);
}

static inline void blendFloat(double& from, double to, double progress)
{
    if (from != to)
        from = from + (to - from) * progress;
}

void TransformationMatrix::blend(const TransformationMatrix& from, double progress)
{
    if (from.isIdentity() && isIdentity())
        return;

    // decompose
    DecomposedType fromDecomp;
    DecomposedType toDecomp;
    from.decompose(fromDecomp);
    decompose(toDecomp);

    // interpolate
    blendFloat(fromDecomp.scaleX, toDecomp.scaleX, progress);
    blendFloat(fromDecomp.scaleY, toDecomp.scaleY, progress);
    blendFloat(fromDecomp.scaleZ, toDecomp.scaleZ, progress);
    blendFloat(fromDecomp.skewXY, toDecomp.skewXY, progress);
    blendFloat(fromDecomp.skewXZ, toDecomp.skewXZ, progress);
    blendFloat(fromDecomp.skewYZ, toDecomp.skewYZ, progress);
    blendFloat(fromDecomp.translateX, toDecomp.translateX, progress);
    blendFloat(fromDecomp.translateY, toDecomp.translateY, progress);
    blendFloat(fromDecomp.translateZ, toDecomp.translateZ, progress);
    blendFloat(fromDecomp.perspectiveX, toDecomp.perspectiveX, progress);
    blendFloat(fromDecomp.perspectiveY, toDecomp.perspectiveY, progress);
    blendFloat(fromDecomp.perspectiveZ, toDecomp.perspectiveZ, progress);
    blendFloat(fromDecomp.perspectiveW, toDecomp.perspectiveW, progress);

    slerp(&fromDecomp.quaternionX, &toDecomp.quaternionX, progress);

    // recompose
    recompose(fromDecomp);
}

bool TransformationMatrix::decompose(DecomposedType& decomp) const
{
    if (isIdentity()) {
        memset(&decomp, 0, sizeof(decomp));
        decomp.perspectiveW = 1;
        decomp.scaleX = 1;
        decomp.scaleY = 1;
        decomp.scaleZ = 1;
    }

    /*if (!WebCore::decompose(m_matrix, decomp))
        return false;*/
    if (!::decompose(m_matrix, decomp))
        return false;
    return true;
}

void TransformationMatrix::recompose(const DecomposedType& decomp)
{
    makeIdentity();

    // first apply perspective
    m_matrix[0][3] = (float) decomp.perspectiveX;
    m_matrix[1][3] = (float) decomp.perspectiveY;
    m_matrix[2][3] = (float) decomp.perspectiveZ;
    m_matrix[3][3] = (float) decomp.perspectiveW;

    // now translate
    translate3d((float) decomp.translateX, (float) decomp.translateY, (float) decomp.translateZ);

    // apply rotation
    double xx = decomp.quaternionX * decomp.quaternionX;
    double xy = decomp.quaternionX * decomp.quaternionY;
    double xz = decomp.quaternionX * decomp.quaternionZ;
    double xw = decomp.quaternionX * decomp.quaternionW;
    double yy = decomp.quaternionY * decomp.quaternionY;
    double yz = decomp.quaternionY * decomp.quaternionZ;
    double yw = decomp.quaternionY * decomp.quaternionW;
    double zz = decomp.quaternionZ * decomp.quaternionZ;
    double zw = decomp.quaternionZ * decomp.quaternionW;

    // Construct a composite rotation matrix from the quaternion values
    TransformationMatrix rotationMatrix(1 - 2 * (yy + zz), 2 * (xy - zw), 2 * (xz + yw), 0,
                           2 * (xy + zw), 1 - 2 * (xx + zz), 2 * (yz - xw), 0,
                           2 * (xz - yw), 2 * (yz + xw), 1 - 2 * (xx + yy), 0,
                           0, 0, 0, 1);

    multLeft(rotationMatrix);

    // now apply skew
    if (decomp.skewYZ) {
        TransformationMatrix tmp;
        tmp.setM32((float) decomp.skewYZ);
        multLeft(tmp);
    }

    if (decomp.skewXZ) {
        TransformationMatrix tmp;
        tmp.setM31((float) decomp.skewXZ);
        multLeft(tmp);
    }

    if (decomp.skewXY) {
        TransformationMatrix tmp;
        tmp.setM21((float) decomp.skewXY);
        multLeft(tmp);
    }

    // finally, apply scale
    scale3d((float) decomp.scaleX, (float) decomp.scaleY, (float) decomp.scaleZ);
}

/////////////////
// https://github.com/rkudiyarov/ClutterWebkit/blob/05d919e0598691bcd34f57d27f44872919e39e92/WebCore/platform/graphics/qt/TransformationMatrixQt.cpp

TransformationMatrix::operator QTransform() const
{
    return QTransform(m11(), m12(), m14(), m21(), m22(), m24(), m41(), m42(), m44());
}

AffineTransform::operator QTransform() const
{
    return QTransform(a(), b(), c(), d(), e(), f());
}
</file>

<file path="color_test.cpp">
#include <iostream>
#include <litehtml.h>
#include <memory>
#include <string>
#include <QDebug>
#include <QApplication>
#include <QObject>

// Create a simplified mock container for testing colors
class mock_container : public litehtml::document_container {
private:
    using ColorResolverFunc = std::function<std::string(const std::string&)>;
    ColorResolverFunc m_customColorResolver;

public:
    // Constructor
    mock_container() {
        std::cout << "Mock container created" << std::endl;
    }

    // Set custom color resolver
    void setCustomColorResolver(ColorResolverFunc resolver) {
        m_customColorResolver = resolver;
    }

    // Implement just the minimal set of required functions
    litehtml::uint_ptr create_font(const litehtml::font_description& descr, const litehtml::document* doc, litehtml::font_metrics* fm) override {
        // Return a dummy font handle
        return 1;
    }

    void delete_font(litehtml::uint_ptr hFont) override {}

    int text_width(const char* text, litehtml::uint_ptr hFont) override {
        return 100; // dummy width
    }

    void draw_text(litehtml::uint_ptr hdc, const char* text, litehtml::uint_ptr hFont, litehtml::web_color color, const litehtml::position& pos) override {}

    int pt_to_px(int pt) const override {
        return pt * 4 / 3; // standard conversion
    }

    int get_default_font_size() const override {
        return 16;
    }

    const char* get_default_font_name() const override {
        return "Arial";
    }

    void draw_list_marker(litehtml::uint_ptr hdc, const litehtml::list_marker& marker) override {}

    void load_image(const char* src, const char* baseurl, bool redraw_on_ready) override {}

    void get_image_size(const char* src, const char* baseurl, litehtml::size& sz) override {
        sz.width = 0;
        sz.height = 0;
    }

    void draw_image(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const std::string& url, const std::string& base_url) override {}

    void draw_solid_fill(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::web_color& color) override {}

    void draw_linear_gradient(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::background_layer::linear_gradient& gradient) override {}

    void draw_radial_gradient(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::background_layer::radial_gradient& gradient) override {}

    void draw_conic_gradient(litehtml::uint_ptr hdc, const litehtml::background_layer& layer, const litehtml::background_layer::conic_gradient& gradient) override {}

    void draw_borders(litehtml::uint_ptr hdc, const litehtml::borders& borders, const litehtml::position& draw_pos, bool root) override {}

    void set_caption(const char* caption) override {}

    void set_base_url(const char* base_url) override {}

    void link(const std::shared_ptr<litehtml::document>& doc, const litehtml::element::ptr& el) override {}

    void on_anchor_click(const char* url, const litehtml::element::ptr& el) override {}

    void on_mouse_event(const litehtml::element::ptr& el, litehtml::mouse_event event) override {}

    void set_cursor(const char* cursor) override {}

    void transform_text(litehtml::string& text, litehtml::text_transform tt) override {
        // Very basic text transformation - not all transformations are implemented
        if (tt == litehtml::text_transform_uppercase) {
            std::transform(text.begin(), text.end(), text.begin(), ::toupper);
        } else if (tt == litehtml::text_transform_lowercase) {
            std::transform(text.begin(), text.end(), text.begin(), ::tolower);
        }
    }

    void import_css(litehtml::string& text, const litehtml::string& url, litehtml::string& baseurl) override {}

    void set_clip(const litehtml::position& pos, const litehtml::border_radiuses& bdr_radius) override {}

    void del_clip() override {}

    void get_viewport(litehtml::position& viewport) const override {
        viewport.width = 800;
        viewport.height = 600;
    }

    void get_media_features(litehtml::media_features& media) const override {
        media.type = litehtml::media_type_screen;
        media.width = 800;
        media.height = 600;
        media.device_width = 800;
        media.device_height = 600;
        media.color = 8;
        media.resolution = 96;
    }

    void get_language(litehtml::string& language, litehtml::string& culture) const override {
        language = "en";
        culture = "US";
    }

    litehtml::element::ptr create_element(const char* tag_name,
                                        const litehtml::string_map& attributes,
                                        const std::shared_ptr<litehtml::document>& doc) override {
        return nullptr; // Let litehtml create default element
    }

    litehtml::string resolve_color(const litehtml::string& color) const override {
        if (m_customColorResolver) {
            return m_customColorResolver(color);
        }
        return color;
    }
};

// Simple test program to verify color parsing fixes
int main(int argc, char** argv)
{
    QApplication app(argc, argv);

    std::cout << "Color parsing test program" << std::endl;

    // Create a simple document container
    auto container = std::make_shared<mock_container>();

    // Test 1: Basic HTML with simple colors
    const char* simple_html = R"(
        <html>
        <head>
            <style>
                body { color: blue; }
                h1 { color: #ff0000; }
                p { color: rgb(0, 128, 0); }
            </style>
        </head>
        <body>
            <h1>Test Header</h1>
            <p>Test paragraph</p>
        </body>
        </html>
    )";

    std::cout << "Testing simple HTML with standard colors..." << std::endl;
    auto document = litehtml::document::createFromString(simple_html, container.get());
    if (document) {
        std::cout << "  Success: Document created" << std::endl;
    } else {
        std::cout << "  Failure: Document creation failed" << std::endl;
        return 1;
    }

    // Test 2: Named color resolution
    const char* named_colors_html = R"(
        <html>
        <head>
            <style>
                .c1 { color: aliceblue; }
                .c2 { color: chartreuse; }
                .c3 { color: darkmagenta; }
                .c4 { color: thisDoesNotExist; }
            </style>
        </head>
        <body>
            <div class="c1">Color 1</div>
            <div class="c2">Color 2</div>
            <div class="c3">Color 3</div>
            <div class="c4">Color 4</div>
        </body>
        </html>
    )";

    std::cout << "Testing named color resolution..." << std::endl;
    auto document2 = litehtml::document::createFromString(named_colors_html, container.get());
    if (document2) {
        std::cout << "  Success: Document with named colors created" << std::endl;
    } else {
        std::cout << "  Failure: Document with named colors creation failed" << std::endl;
        return 1;
    }

    // Test 3: Recursion prevention
    const char* recursive_html = R"(
        <html>
        <head>
            <style>
                body { color: recursiveColor; }
            </style>
        </head>
        <body>
            <p>Test recursion prevention</p>
        </body>
        </html>
    )";

    // Override resolve_color to create a recursive scenario
    container->setCustomColorResolver([](const std::string& color) -> std::string {
        if (color == "recursiveColor") {
            return "recursiveColor"; // This would normally cause infinite recursion
        }
        return color;
    });

    std::cout << "Testing recursion prevention..." << std::endl;
    auto document3 = litehtml::document::createFromString(recursive_html, container.get());
    if (document3) {
        std::cout << "  Success: Document with potential recursion created safely" << std::endl;
    } else {
        std::cout << "  Failure: Document with potential recursion creation failed" << std::endl;
        return 1;
    }

    std::cout << "All tests completed successfully!" << std::endl;
    return 0;
}
</file>

</files>
